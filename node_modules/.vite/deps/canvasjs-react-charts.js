import {
  require_react
} from "./chunk-4UQS7KPA.js";
import {
  __commonJS
} from "./chunk-2GTGKKMZ.js";

// node_modules/canvasjs-react-charts/canvasjs.min.js
var require_canvasjs_min = __commonJS({
  "node_modules/canvasjs-react-charts/canvasjs.min.js"(exports, module) {
    (function() {
      function qa(h, p) {
        h.prototype = eb(p.prototype);
        h.prototype.constructor = h;
        h.base = p.prototype;
      }
      function eb(h) {
        function p() {
        }
        p.prototype = h;
        return new p();
      }
      function Ya(h, p, D) {
        "millisecond" === D ? h.setMilliseconds(h.getMilliseconds() + 1 * p) : "second" === D ? h.setSeconds(h.getSeconds() + 1 * p) : "minute" === D ? h.setMinutes(h.getMinutes() + 1 * p) : "hour" === D ? h.setHours(h.getHours() + 1 * p) : "day" === D ? h.setDate(h.getDate() + 1 * p) : "week" === D ? h.setDate(h.getDate() + 7 * p) : "month" === D ? h.setMonth(h.getMonth() + 1 * p) : "year" === D && h.setFullYear(h.getFullYear() + 1 * p);
        return h;
      }
      function $(h, p) {
        var D = false;
        0 > h && (D = true, h *= -1);
        h = "" + h;
        for (p = p ? p : 1; h.length < p; )
          h = "0" + h;
        return D ? "-" + h : h;
      }
      function Ia(h) {
        if (!h)
          return h;
        h = h.replace(/^\s\s*/, "");
        for (var p = /\s/, D = h.length; p.test(h.charAt(--D)); )
          ;
        return h.slice(0, D + 1);
      }
      function Ea(h) {
        h.roundRect = function(h2, D, r2, u2, H, F, z, v2) {
          z && (this.fillStyle = z);
          v2 && (this.strokeStyle = v2);
          "undefined" === typeof H && (H = 5);
          this.lineWidth = F;
          this.beginPath();
          this.moveTo(h2 + H, D);
          this.lineTo(h2 + r2 - H, D);
          this.quadraticCurveTo(h2 + r2, D, h2 + r2, D + H);
          this.lineTo(h2 + r2, D + u2 - H);
          this.quadraticCurveTo(h2 + r2, D + u2, h2 + r2 - H, D + u2);
          this.lineTo(h2 + H, D + u2);
          this.quadraticCurveTo(h2, D + u2, h2, D + u2 - H);
          this.lineTo(h2, D + H);
          this.quadraticCurveTo(h2, D, h2 + H, D);
          this.closePath();
          z && this.fill();
          v2 && 0 < F && this.stroke();
        };
      }
      function Sa(h, p) {
        return h - p;
      }
      function Ta(h, p, D) {
        if (h && p && D) {
          D = D + "." + p;
          var r2 = "image/" + p;
          h = h.toDataURL(r2);
          var u2 = false, H = document.createElement("a");
          H.download = D;
          H.href = h;
          if ("undefined" !== typeof Blob && new Blob()) {
            for (var F = h.replace(/^data:[a-z\/]*;base64,/, ""), F = atob(F), z = new ArrayBuffer(F.length), z = new Uint8Array(z), v2 = 0; v2 < F.length; v2++)
              z[v2] = F.charCodeAt(v2);
            p = new Blob([z.buffer], { type: "image/" + p });
            try {
              window.navigator.msSaveBlob(p, D), u2 = true;
            } catch (L) {
              H.dataset.downloadurl = [r2, H.download, H.href].join(":"), H.href = window.URL.createObjectURL(p);
            }
          }
          if (!u2)
            try {
              event = document.createEvent("MouseEvents"), event.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null), H.dispatchEvent ? H.dispatchEvent(event) : H.fireEvent && H.fireEvent("onclick");
            } catch (E2) {
              p = window.open(), p.document.write("<img src='" + h + "'></img><div>Please right click on the image and save it to your device</div>"), p.document.close();
            }
        }
      }
      function N(h) {
        var p = ((h & 16711680) >> 16).toString(16), D = ((h & 65280) >> 8).toString(16);
        h = ((h & 255) >> 0).toString(16);
        p = 2 > p.length ? "0" + p : p;
        D = 2 > D.length ? "0" + D : D;
        h = 2 > h.length ? "0" + h : h;
        return "#" + p + D + h;
      }
      function fb(h, p) {
        var D = this.length >>> 0, r2 = Number(p) || 0, r2 = 0 > r2 ? Math.ceil(r2) : Math.floor(r2);
        for (0 > r2 && (r2 += D); r2 < D; r2++)
          if (r2 in this && this[r2] === h)
            return r2;
        return -1;
      }
      function u(h) {
        return null === h || "undefined" === typeof h;
      }
      function Fa(h) {
        h.indexOf || (h.indexOf = fb);
        return h;
      }
      function gb(h) {
        if (U.fSDec)
          h[ja("`eeDwdouMhrudods")](
            ja("e`u`@ohl`uhnoHuds`uhnoDoe"),
            function() {
              U._fTWm && U._fTWm(h);
            }
          );
      }
      function Za(h, p, D) {
        D = D || "normal";
        var r2 = h + "_" + p + "_" + D, u2 = $a[r2];
        if (isNaN(u2)) {
          try {
            h = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" + h + "; font-size:" + p + "px; font-weight:" + D + ";";
            if (!xa) {
              var H = document.body;
              xa = document.createElement("span");
              xa.innerHTML = "";
              var F = document.createTextNode("Mpgyi");
              xa.appendChild(F);
              H.appendChild(xa);
            }
            xa.style.display = "";
            xa.setAttribute("style", h);
            u2 = Math.round(xa.offsetHeight);
            xa.style.display = "none";
          } catch (z) {
            u2 = Math.ceil(1.1 * p);
          }
          u2 = Math.max(u2, p);
          $a[r2] = u2;
        }
        return u2;
      }
      function R(h, p) {
        var D = [];
        if (D = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[h || "solid"])
          for (var r2 = 0; r2 < D.length; r2++)
            D[r2] *= p;
        else
          D = [];
        return D;
      }
      function O(h, p, D, r2, u2) {
        r2 = r2 || [];
        u2 = u2 || false;
        r2.push([h, p, D, u2]);
        return h.addEventListener ? (h.addEventListener(p, D, u2), D) : h.attachEvent ? (r2 = function(p2) {
          p2 = p2 || window.event;
          p2.preventDefault = p2.preventDefault || function() {
            p2.returnValue = false;
          };
          p2.stopPropagation = p2.stopPropagation || function() {
            p2.cancelBubble = true;
          };
          D.call(h, p2);
        }, h.attachEvent("on" + p, r2), r2) : false;
      }
      function ab(h, p, D) {
        h *= W;
        p *= W;
        h = D.getImageData(h, p, 2, 2).data;
        p = true;
        for (D = 0; 4 > D; D++)
          if (h[D] !== h[D + 4] | h[D] !== h[D + 8] | h[D] !== h[D + 12]) {
            p = false;
            break;
          }
        return p ? h[0] << 16 | h[1] << 8 | h[2] : 0;
      }
      function na(h, p, D) {
        return h in p ? p[h] : D[h];
      }
      function Oa(h, p, D) {
        if (r && bb) {
          var u2 = h.getContext("2d");
          Pa = u2.webkitBackingStorePixelRatio || u2.mozBackingStorePixelRatio || u2.msBackingStorePixelRatio || u2.oBackingStorePixelRatio || u2.backingStorePixelRatio || 1;
          W = Ua / Pa;
          h.width = p * W;
          h.height = D * W;
          Ua !== Pa && (h.style.width = p + "px", h.style.height = D + "px", u2.scale(W, W));
        } else
          h.width = p, h.height = D;
      }
      function hb(h) {
        if (!ib) {
          var p = false, D = false;
          "undefined" === typeof ra.Chart.creditHref ? (h.creditHref = ja("iuuqr;..b`ow`rkr/bnl."), h.creditText = ja("B`ow`rKR/bnl")) : (p = h.updateOption("creditText"), D = h.updateOption("creditHref"));
          if (h.creditHref && h.creditText) {
            h._creditLink || (h._creditLink = document.createElement("a"), h._creditLink.setAttribute("class", "canvasjs-chart-credit"), h._creditLink.setAttribute("title", "JavaScript Charts"), h._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (h.height - 14) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"), h._creditLink.setAttribute("tabIndex", -1), h._creditLink.setAttribute("target", "_blank"));
            if (0 === h.renderCount || p || D)
              h._creditLink.setAttribute("href", h.creditHref), h._creditLink.innerHTML = h.creditText;
            h._creditLink && h.creditHref && h.creditText ? (h._creditLink.parentElement || h._canvasJSContainer.appendChild(h._creditLink), h._creditLink.style.top = h.height - 14 + "px") : h._creditLink.parentElement && h._canvasJSContainer.removeChild(h._creditLink);
          }
        }
      }
      function ta(h, p) {
        Ja && (this.canvasCount |= 0, window.console.log(++this.canvasCount));
        var D = document.createElement("canvas");
        D.setAttribute("class", "canvasjs-chart-canvas");
        Oa(
          D,
          h,
          p
        );
        r || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(D);
        return D;
      }
      function sa(h, p, D) {
        for (var r2 in D)
          p.style[r2] = D[r2];
      }
      function ua(h, p, D) {
        p.getAttribute("state") || (p.style.backgroundColor = h.toolbar.backgroundColor, p.style.color = h.toolbar.fontColor, p.style.border = "none", sa(h, p, { WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" }));
        p.getAttribute("state") !== D && (p.setAttribute("state", D), p.setAttribute("type", "button"), sa(h, p, {
          padding: "5px 12px",
          cursor: "pointer",
          "float": "left",
          width: "40px",
          height: "25px",
          outline: "0px",
          verticalAlign: "baseline",
          lineHeight: "0"
        }), p.setAttribute("title", h._cultureInfo[D + "Text"]), p.innerHTML = "<img style='height:95%; pointer-events: none;' src='" + jb[D].image + "' alt='" + h._cultureInfo[D + "Text"] + "' />");
      }
      function Qa() {
        for (var h = null, p = 0; p < arguments.length; p++)
          h = arguments[p], h.style && (h.style.display = "inline");
      }
      function va() {
        for (var h = null, p = 0; p < arguments.length; p++)
          (h = arguments[p]) && h.style && (h.style.display = "none");
      }
      function V(h, p, D, r2, v2) {
        this._defaultsKey = h;
        this._themeOptionsKey = p;
        this._index = r2;
        this.parent = v2;
        this._eventListeners = [];
        h = {};
        this.theme && u(p) && u(r2) ? h = u(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[p]) && (null === r2 ? h = this.parent.themeOptions[p] : 0 < this.parent.themeOptions[p].length && (r2 = Math.min(this.parent.themeOptions[p].length - 1, r2), h = this.parent.themeOptions[p][r2]));
        this.themeOptions = h;
        this.options = D ? D : { _isPlaceholder: true };
        this.setOptions(
          this.options,
          h
        );
      }
      function Ga(h, p, r2, u2, v2) {
        "undefined" === typeof v2 && (v2 = 0);
        this._padding = v2;
        this._x1 = h;
        this._y1 = p;
        this._x2 = r2;
        this._y2 = u2;
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      }
      function ka(h, p) {
        ka.base.constructor.call(this, "TextBlock", null, p, null, null);
        this.ctx = h;
        this._isDirty = true;
        this._wrappedText = null;
        this._initialize();
      }
      function Va(h, p) {
        Va.base.constructor.call(this, "Toolbar", "toolbar", p, null, h);
        this.chart = h;
        this.canvas = h.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "toolbar";
      }
      function Aa(h, p) {
        Aa.base.constructor.call(this, "Title", "title", p, null, h);
        this.chart = h;
        this.canvas = h.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "title";
        if (u(this.options.margin) && h.options.subtitles) {
          for (var r2 = h.options.subtitles, za = 0; za < r2.length; za++)
            if ((u(r2[za].horizontalAlign) && "center" === this.horizontalAlign || r2[za].horizontalAlign === this.horizontalAlign) && (u(r2[za].verticalAlign) && "top" === this.verticalAlign || r2[za].verticalAlign === this.verticalAlign) && !r2[za].dockInsidePlotArea === !this.dockInsidePlotArea) {
              this.margin = 0;
              break;
            }
        }
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function Ka(h, p, r2) {
        Ka.base.constructor.call(this, "Subtitle", "subtitles", p, r2, h);
        this.chart = h;
        this.canvas = h.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "subtitles";
        this.isOptionsInArray = true;
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function Wa() {
        this.pool = [];
      }
      function La(h) {
        var p;
        h && Ma[h] && (p = Ma[h]);
        La.base.constructor.call(this, "CultureInfo", null, p, null, null);
      }
      var Ja = false, U = {}, r = !!document.createElement("canvas").getContext, ra = { Chart: {
        width: 500,
        height: 400,
        zoomEnabled: false,
        zoomType: "x",
        backgroundColor: "white",
        theme: "light1",
        animationEnabled: false,
        animationDuration: 1200,
        dataPointWidth: null,
        dataPointMinWidth: null,
        dataPointMaxWidth: null,
        colorSet: "colorSet1",
        culture: "en",
        creditHref: "",
        creditText: "CanvasJS",
        interactivityEnabled: true,
        exportEnabled: false,
        exportFileName: "Chart",
        rangeChanging: null,
        rangeChanged: null,
        publicProperties: { title: "readWrite", subtitles: "readWrite", toolbar: "readWrite", toolTip: "readWrite", legend: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly" }
      }, Title: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 20,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: r ? "transparent" : null,
        margin: 5,
        wrap: true,
        maxWidth: null,
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Subtitle: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 14,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: null,
        margin: 2,
        wrap: true,
        maxWidth: null,
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Toolbar: { backgroundColor: "white", backgroundColorOnHover: "#2196f3", borderColor: "#2196f3", borderThickness: 1, fontColor: "black", fontColorOnHover: "white", publicProperties: { options: "readWrite", chart: "readOnly" } }, Legend: {
        name: null,
        verticalAlign: "center",
        horizontalAlign: "right",
        fontSize: 14,
        fontFamily: "calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        cursor: null,
        itemmouseover: null,
        itemmouseout: null,
        itemmousemove: null,
        itemclick: null,
        dockInsidePlotArea: false,
        reversed: false,
        backgroundColor: r ? "transparent" : null,
        borderColor: r ? "transparent" : null,
        borderThickness: 0,
        cornerRadius: 0,
        maxWidth: null,
        maxHeight: null,
        markerMargin: null,
        itemMaxWidth: null,
        itemWidth: null,
        itemWrap: true,
        itemTextFormatter: null,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, ToolTip: {
        enabled: true,
        shared: false,
        animationEnabled: true,
        content: null,
        contentFormatter: null,
        reversed: false,
        backgroundColor: r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
        borderColor: null,
        borderThickness: 2,
        cornerRadius: 5,
        fontSize: 14,
        fontColor: "black",
        fontFamily: "Calibri, Arial, Georgia, serif;",
        fontWeight: "normal",
        fontStyle: "italic",
        publicProperties: { options: "readWrite", chart: "readOnly" }
      }, Axis: {
        minimum: null,
        maximum: null,
        viewportMinimum: null,
        viewportMaximum: null,
        interval: null,
        intervalType: null,
        reversed: false,
        logarithmic: false,
        logarithmBase: 10,
        title: null,
        titleFontColor: "black",
        titleFontSize: 20,
        titleFontFamily: "arial",
        titleFontWeight: "normal",
        titleFontStyle: "normal",
        titleWrap: true,
        titleMaxWidth: null,
        titleBackgroundColor: r ? "transparent" : null,
        titleBorderColor: r ? "transparent" : null,
        titleBorderThickness: 0,
        titleCornerRadius: 0,
        labelAngle: 0,
        labelFontFamily: "arial",
        labelFontColor: "black",
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelAutoFit: true,
        labelWrap: true,
        labelMaxWidth: null,
        labelFormatter: null,
        labelBackgroundColor: r ? "transparent" : null,
        labelBorderColor: r ? "transparent" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelPlacement: "outside",
        prefix: "",
        suffix: "",
        includeZero: true,
        tickLength: 5,
        tickColor: "black",
        tickThickness: 1,
        lineColor: "black",
        lineThickness: 1,
        lineDashType: "solid",
        gridColor: "A0A0A0",
        gridThickness: 0,
        gridDashType: "solid",
        interlacedColor: r ? "transparent" : null,
        valueFormatString: null,
        margin: 2,
        publicProperties: { options: "readWrite", stripLines: "readWrite", scaleBreaks: "readWrite", crosshair: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, StripLine: {
        value: null,
        startValue: null,
        endValue: null,
        color: "orange",
        opacity: null,
        thickness: 2,
        lineDashType: "solid",
        label: "",
        labelPlacement: "inside",
        labelAlign: "far",
        labelWrap: true,
        labelMaxWidth: null,
        labelBackgroundColor: null,
        labelBorderColor: r ? "transparent" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelFontFamily: "arial",
        labelFontColor: "orange",
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelFormatter: null,
        showOnTop: false,
        publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, ScaleBreaks: {
        autoCalculate: false,
        collapsibleThreshold: "25%",
        maxNumberOfAutoBreaks: 2,
        spacing: 8,
        type: "straight",
        color: "#FFFFFF",
        fillOpacity: 0.9,
        lineThickness: 2,
        lineColor: "#E16E6E",
        lineDashType: "solid",
        publicProperties: { options: "readWrite", customBreaks: "readWrite", axis: "readOnly", autoBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, Break: { startValue: null, endValue: null, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", scaleBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" } }, Crosshair: {
        enabled: false,
        snapToDataPoint: false,
        color: "grey",
        opacity: null,
        thickness: 2,
        lineDashType: "solid",
        label: "",
        labelWrap: true,
        labelMaxWidth: null,
        labelBackgroundColor: r ? "grey" : null,
        labelBorderColor: r ? "grey" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelFontFamily: r ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
        labelFontSize: 12,
        labelFontColor: "#fff",
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelFormatter: null,
        valueFormatString: null,
        publicProperties: {
          options: "readWrite",
          axis: "readOnly",
          bounds: "readOnly",
          chart: "readOnly"
        }
      }, DataSeries: {
        name: null,
        dataPoints: null,
        label: "",
        bevelEnabled: false,
        highlightEnabled: true,
        cursor: "default",
        indexLabel: "",
        indexLabelPlacement: "auto",
        indexLabelOrientation: "horizontal",
        indexLabelFontColor: "black",
        indexLabelFontSize: 12,
        indexLabelFontStyle: "normal",
        indexLabelFontFamily: "Arial",
        indexLabelFontWeight: "normal",
        indexLabelBackgroundColor: null,
        indexLabelLineColor: "gray",
        indexLabelLineThickness: 1,
        indexLabelLineDashType: "solid",
        indexLabelMaxWidth: null,
        indexLabelWrap: true,
        indexLabelFormatter: null,
        lineThickness: 2,
        lineDashType: "solid",
        connectNullData: false,
        nullDataLineDashType: "dash",
        color: null,
        lineColor: null,
        risingColor: "white",
        fallingColor: "red",
        fillOpacity: null,
        startAngle: 0,
        radius: null,
        innerRadius: null,
        neckHeight: null,
        neckWidth: null,
        reversed: false,
        valueRepresents: null,
        linkedDataSeriesIndex: null,
        whiskerThickness: 2,
        whiskerDashType: "solid",
        whiskerColor: null,
        whiskerLength: null,
        stemThickness: 2,
        stemColor: null,
        stemDashType: "solid",
        upperBoxColor: "white",
        lowerBoxColor: "white",
        type: "column",
        xValueType: "number",
        axisXType: "primary",
        axisYType: "primary",
        axisXIndex: 0,
        axisYIndex: 0,
        xValueFormatString: null,
        yValueFormatString: null,
        zValueFormatString: null,
        percentFormatString: null,
        showInLegend: null,
        legendMarkerType: null,
        legendMarkerColor: null,
        legendText: null,
        legendMarkerBorderColor: r ? "transparent" : null,
        legendMarkerBorderThickness: 0,
        markerType: "circle",
        markerColor: null,
        markerSize: null,
        markerBorderColor: r ? "transparent" : null,
        markerBorderThickness: 0,
        mouseover: null,
        mouseout: null,
        mousemove: null,
        click: null,
        toolTipContent: null,
        visible: true,
        publicProperties: { options: "readWrite", axisX: "readWrite", axisY: "readWrite", chart: "readOnly" }
      }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: "", horizontalAlign: "center", fontSize: 12, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, textBaseline: "top" }, CultureInfo: {
        decimalSeparator: ".",
        digitGroupSeparator: ",",
        zoomText: "Zoom",
        panText: "Pan",
        resetText: "Reset",
        menuText: "More Options",
        saveJPGText: "Save as JPEG",
        savePNGText: "Save as PNG",
        printText: "Print",
        days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
      } }, Ma = { en: {} }, v = r ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", Ha = r ? "Impact, Charcoal, sans-serif" : "Arial", Ba = { colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "), colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "), colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ") }, I, fa, Q, ha, ga;
      fa = "#333333";
      Q = "#000000";
      I = "#666666";
      ga = ha = "#000000";
      var X = 20, E = 14, Xa = {
        colorSet: "colorSet1",
        backgroundColor: "#FFFFFF",
        title: { fontFamily: Ha, fontSize: 32, fontColor: fa, fontWeight: "normal", verticalAlign: "top", margin: 5 },
        subtitles: [{ fontFamily: Ha, fontSize: E, fontColor: fa, fontWeight: "normal", verticalAlign: "top", margin: 5 }],
        data: [{ indexLabelFontFamily: v, indexLabelFontSize: E, indexLabelFontColor: fa, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }],
        axisX: [{
          titleFontFamily: v,
          titleFontSize: X,
          titleFontColor: fa,
          titleFontWeight: "normal",
          labelFontFamily: v,
          labelFontSize: E,
          labelFontColor: Q,
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: I,
          tickThickness: 1,
          tickColor: I,
          gridThickness: 0,
          gridColor: I,
          stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
          crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: "dash" },
          scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }],
        axisX2: [{
          titleFontFamily: v,
          titleFontSize: X,
          titleFontColor: fa,
          titleFontWeight: "normal",
          labelFontFamily: v,
          labelFontSize: E,
          labelFontColor: Q,
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: I,
          tickThickness: 1,
          tickColor: I,
          gridThickness: 0,
          gridColor: I,
          stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
          crosshair: {
            labelFontFamily: v,
            labelFontSize: E,
            labelFontColor: "#EEEEEE",
            labelFontWeight: "normal",
            labelBackgroundColor: ga,
            color: ha,
            thickness: 1,
            lineDashType: "dash"
          },
          scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }],
        axisY: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: fa, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{
          labelFontFamily: v,
          labelFontSize: E,
          labelFontColor: "#FF7300",
          labelFontWeight: "normal",
          labelBackgroundColor: null,
          color: "#FF7300",
          thickness: 1
        }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }],
        axisY2: [{
          titleFontFamily: v,
          titleFontSize: X,
          titleFontColor: fa,
          titleFontWeight: "normal",
          labelFontFamily: v,
          labelFontSize: E,
          labelFontColor: Q,
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: I,
          tickThickness: 1,
          tickColor: I,
          gridThickness: 1,
          gridColor: I,
          stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
          crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: "dash" },
          scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }],
        legend: {
          fontFamily: v,
          fontSize: 14,
          fontColor: fa,
          fontWeight: "bold",
          verticalAlign: "bottom",
          horizontalAlign: "center"
        },
        toolTip: { fontFamily: v, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }
      };
      Q = fa = "#F5F5F5";
      I = "#FFFFFF";
      ha = "#40BAF1";
      ga = "#F5F5F5";
      var X = 20, E = 14, cb = { colorSet: "colorSet2", title: { fontFamily: v, fontSize: 33, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: v, fontSize: E, fontColor: "#3A3A3A", fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{
        indexLabelFontFamily: v,
        indexLabelFontSize: E,
        indexLabelFontColor: "#666666",
        indexLabelFontWeight: "normal",
        indexLabelLineThickness: 1
      }], axisX: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickThickness: 1, tickColor: "#BBBBBB", gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#EEEEEE",
        labelFontWeight: "normal",
        labelBackgroundColor: "black",
        color: "black",
        thickness: 1,
        lineDashType: "dot"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisX2: [{
        titleFontFamily: v,
        titleFontSize: X,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: "#BBBBBB",
        tickColor: "#BBBBBB",
        tickThickness: 1,
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
      }], axisY: [{
        titleFontFamily: v,
        titleFontSize: X,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: "#BBBBBB",
        tickColor: "#BBBBBB",
        tickThickness: 1,
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
      }], axisY2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#FFA500",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FFA500",
        thickness: 1
      }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], legend: { fontFamily: v, fontSize: 14, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 } };
      Q = fa = "#F5F5F5";
      I = "#FFFFFF";
      ha = "#40BAF1";
      ga = "#F5F5F5";
      X = 20;
      E = 14;
      Ha = { colorSet: "colorSet12", backgroundColor: "#2A2A2A", title: { fontFamily: Ha, fontSize: 32, fontColor: fa, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: Ha, fontSize: E, fontColor: fa, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{
        indexLabelFontFamily: v,
        indexLabelFontSize: E,
        indexLabelFontColor: Q,
        indexLabelFontWeight: "normal",
        indexLabelLineThickness: 1
      }], axisX: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ga,
        color: ha,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisX2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY: [{
        titleFontFamily: v,
        titleFontSize: X,
        titleFontColor: Q,
        titleFontWeight: "normal",
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: Q,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: I,
        tickThickness: 1,
        tickColor: I,
        gridThickness: 1,
        gridColor: I,
        stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#777777",
          lineThickness: 1,
          lineDashType: "solid",
          color: "#111111"
        }
      }], axisY2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ga,
        color: ha,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], legend: { fontFamily: v, fontSize: 14, fontColor: fa, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: Q, backgroundColor: "rgba(0, 0, 0, .7)" } };
      I = "#FFFFFF";
      Q = fa = "#FAFAFA";
      ha = "#40BAF1";
      ga = "#F5F5F5";
      var X = 20, E = 14, ya = { light1: Xa, light2: cb, dark1: Ha, dark2: { colorSet: "colorSet2", backgroundColor: "#32373A", title: { fontFamily: v, fontSize: 32, fontColor: fa, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: v, fontSize: E, fontColor: fa, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{
        indexLabelFontFamily: v,
        indexLabelFontSize: E,
        indexLabelFontColor: Q,
        indexLabelFontWeight: "normal",
        indexLabelLineThickness: 1
      }], axisX: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ga,
        color: ha,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisX2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY: [{
        titleFontFamily: v,
        titleFontSize: X,
        titleFontColor: Q,
        titleFontWeight: "normal",
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: Q,
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: I,
        tickThickness: 1,
        tickColor: I,
        gridThickness: 1,
        gridColor: I,
        stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#777777",
          lineThickness: 1,
          lineDashType: "solid",
          color: "#111111"
        }
      }], axisY2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: "normal", lineThickness: 0, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: E,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ga,
        color: ha,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], legend: { fontFamily: v, fontSize: 14, fontColor: fa, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: Q, backgroundColor: "rgba(0, 0, 0, .7)" } }, theme1: Xa, theme2: cb, theme3: Xa }, S = {
        numberDuration: 1,
        yearDuration: 314496e5,
        monthDuration: 2592e6,
        weekDuration: 6048e5,
        dayDuration: 864e5,
        hourDuration: 36e5,
        minuteDuration: 6e4,
        secondDuration: 1e3,
        millisecondDuration: 1,
        dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
      };
      (function() {
        U.fSDec = function(h) {
          for (var p = "", r2 = 0; r2 < h.length; r2++)
            p += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(r2));
          return p;
        };
        U.obj = {
          trVs: "Ush`m!Wdsrhno",
          fntStr: "qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg",
          txtBl: "udyuC`rdmhod",
          fnt: "gnou",
          fSy: "ghmmRuxmd",
          fTx: "ghmmUdyu",
          grClr: "fsdx",
          cntx: "buy",
          tp: "unq"
        };
        delete ra[U.fSDec("Bi`su")][U.fSDec("bsdehuIsdg")];
        U.pro = { sCH: ra[U.fSDec("Bi`su")][U.fSDec("bsdehuIsdg")] };
        U._fTWm = function(h) {
          if ("undefined" === typeof U.pro.sCH && !db)
            try {
              var p = h[U.fSDec(U.obj.cntx)];
              p[U.fSDec(U.obj.txtBl)] = U.fSDec(U.obj.tp);
              p[U.fSDec(U.obj.fnt)] = 11 + U.fSDec(U.obj.fntStr);
              p[U.fSDec(U.obj.fSy)] = U.fSDec(U.obj.grClr);
              p[U.fSDec(U.obj.fTx)](U.fSDec(U.obj.trVs), 2, h.height - 11 - 2);
            } catch (r2) {
            }
        };
      })();
      var $a = {}, xa = null, kb = function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height));
      }, lb = function(h, p, r2) {
        p = Math.min(this.width, this.height);
        return Math.max("theme4" === this.theme ? 0 : 300 <= p ? 12 : 10, Math.round(p * (h / 400)));
      }, Ca = function() {
        var h = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, p = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), r2 = "Sun Mon Tue Wed Thu Fri Sat".split(" "), u2 = "January February March April May June July August September October November December".split(" "), v2 = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), H = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, F = /[^-+\dA-Z]/g;
        return function(z, E2, L) {
          var R2 = L ? L.days : p, I2 = L ? L.months : u2, N2 = L ? L.shortDays : r2, O2 = L ? L.shortMonths : v2;
          L = "";
          var S2 = false;
          z = z && z.getTime ? z : z ? new Date(z) : /* @__PURE__ */ new Date();
          if (isNaN(z))
            throw SyntaxError("invalid date");
          "UTC:" === E2.slice(0, 4) && (E2 = E2.slice(4), S2 = true);
          L = S2 ? "getUTC" : "get";
          var U2 = z[L + "Date"](), V2 = z[L + "Day"](), M = z[L + "Month"](), Q2 = z[L + "FullYear"](), a = z[L + "Hours"](), d = z[L + "Minutes"](), b = z[L + "Seconds"](), c = z[L + "Milliseconds"](), e = S2 ? 0 : z.getTimezoneOffset();
          return L = E2.replace(h, function(g) {
            switch (g) {
              case "D":
                return U2;
              case "DD":
                return $(U2, 2);
              case "DDD":
                return N2[V2];
              case "DDDD":
                return R2[V2];
              case "M":
                return M + 1;
              case "MM":
                return $(M + 1, 2);
              case "MMM":
                return O2[M];
              case "MMMM":
                return I2[M];
              case "Y":
                return parseInt(String(Q2).slice(-2));
              case "YY":
                return $(String(Q2).slice(-2), 2);
              case "YYY":
                return $(String(Q2).slice(-3), 3);
              case "YYYY":
                return $(Q2, 4);
              case "h":
                return a % 12 || 12;
              case "hh":
                return $(a % 12 || 12, 2);
              case "H":
                return a;
              case "HH":
                return $(a, 2);
              case "m":
                return d;
              case "mm":
                return $(d, 2);
              case "s":
                return b;
              case "ss":
                return $(b, 2);
              case "f":
                return String(c).slice(0, 1);
              case "ff":
                return $(String(c).slice(0, 2), 2);
              case "fff":
                return $(String(c).slice(0, 3), 3);
              case "t":
                return 12 > a ? "a" : "p";
              case "tt":
                return 12 > a ? "am" : "pm";
              case "T":
                return 12 > a ? "A" : "P";
              case "TT":
                return 12 > a ? "AM" : "PM";
              case "K":
                return S2 ? "UTC" : (String(z).match(H) || [""]).pop().replace(F, "");
              case "z":
                return (0 < e ? "-" : "+") + Math.floor(Math.abs(e) / 60);
              case "zz":
                return (0 < e ? "-" : "+") + $(Math.floor(Math.abs(e) / 60), 2);
              case "zzz":
                return (0 < e ? "-" : "+") + $(Math.floor(Math.abs(e) / 60), 2) + $(Math.abs(e) % 60, 2);
              default:
                return g.slice(1, g.length - 1);
            }
          });
        };
      }(), ba = function(h, p, r2) {
        if (null === h)
          return "";
        if (!isFinite(h))
          return h;
        h = Number(h);
        var u2 = 0 > h ? true : false;
        u2 && (h *= -1);
        var v2 = r2 ? r2.decimalSeparator : ".", H = r2 ? r2.digitGroupSeparator : ",", F = "";
        p = String(p);
        var F = 1, z = r2 = "", E2 = -1, L = [], R2 = [], I2 = 0, N2 = 0, S2 = 0, O2 = false, U2 = 0, z = p.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
        p = null;
        for (var Q2 = 0; z && Q2 < z.length; Q2++)
          if (p = z[Q2], "." === p && 0 > E2)
            E2 = Q2;
          else {
            if ("%" === p)
              F *= 100;
            else if ("" === p) {
              F *= 1e3;
              continue;
            } else if ("," === p[0] && "." === p[p.length - 1]) {
              F /= Math.pow(1e3, p.length - 1);
              E2 = Q2 + p.length - 1;
              continue;
            } else
              "E" !== p[0] && "e" !== p[0] || "0" !== p[p.length - 1] || (O2 = true);
            0 > E2 ? (L.push(p), "#" === p || "0" === p ? I2++ : "," === p && S2++) : (R2.push(p), "#" !== p && "0" !== p || N2++);
          }
        O2 && (p = Math.floor(h), z = -Math.floor(Math.log(h) / Math.LN10 + 1), U2 = 0 === h ? 0 : 0 === p ? -(I2 + z) : String(p).length - I2, F /= Math.pow(10, U2));
        0 > E2 && (E2 = Q2);
        F = (h * F).toFixed(N2);
        p = F.split(".");
        F = (p[0] + "").split("");
        h = (p[1] + "").split("");
        F && "0" === F[0] && F.shift();
        for (O2 = z = Q2 = N2 = E2 = 0; 0 < L.length; )
          if (p = L.pop(), "#" === p || "0" === p)
            if (E2++, E2 === I2) {
              var M = F, F = [];
              if ("0" === p)
                for (p = I2 - N2 - (M ? M.length : 0); 0 < p; )
                  M.unshift("0"), p--;
              for (; 0 < M.length; )
                r2 = M.pop() + r2, O2++, 0 === O2 % z && (Q2 === S2 && 0 < M.length) && (r2 = H + r2);
            } else
              0 < F.length ? (r2 = F.pop() + r2, N2++, O2++) : "0" === p && (r2 = "0" + r2, N2++, O2++), 0 === O2 % z && (Q2 === S2 && 0 < F.length) && (r2 = H + r2);
          else
            "E" !== p[0] && "e" !== p[0] || "0" !== p[p.length - 1] || !/[eE][+-]*[0]+/.test(p) ? "," === p ? (Q2++, z = O2, O2 = 0, 0 < F.length && (r2 = H + r2)) : r2 = 1 < p.length && ('"' === p[0] && '"' === p[p.length - 1] || "'" === p[0] && "'" === p[p.length - 1]) ? p.slice(1, p.length - 1) + r2 : p + r2 : (p = 0 > U2 ? p.replace("+", "").replace("-", "") : p.replace("-", ""), r2 += p.replace(/[0]+/, function(h2) {
              return $(U2, h2.length);
            }));
        H = "";
        for (L = false; 0 < R2.length; )
          p = R2.shift(), "#" === p || "0" === p ? 0 < h.length && 0 !== Number(h.join("")) ? (H += h.shift(), L = true) : "0" === p && (H += "0", L = true) : 1 < p.length && ('"' === p[0] && '"' === p[p.length - 1] || "'" === p[0] && "'" === p[p.length - 1]) ? H += p.slice(1, p.length - 1) : "E" !== p[0] && "e" !== p[0] || "0" !== p[p.length - 1] || !/[eE][+-]*[0]+/.test(p) ? H += p : (p = 0 > U2 ? p.replace("+", "").replace("-", "") : p.replace("-", ""), H += p.replace(/[0]+/, function(h2) {
            return $(U2, h2.length);
          }));
        r2 += (L ? v2 : "") + H;
        return u2 ? "-" + r2 : r2;
      }, Ra = function(h) {
        var p = 0, r2 = 0;
        h = h || window.event;
        h.offsetX || 0 === h.offsetX ? (p = h.offsetX, r2 = h.offsetY) : h.layerX || 0 == h.layerX ? (p = h.layerX, r2 = h.layerY) : (p = h.pageX - h.target.offsetLeft, r2 = h.pageY - h.target.offsetTop);
        return { x: p, y: r2 };
      }, bb = true, Ua = window.devicePixelRatio || 1, Pa = 1, W = bb ? Ua / Pa : 1, ea = function(h, p, r2, u2, v2, H, F, z, E2, L, R2, N2, O2) {
        "undefined" === typeof O2 && (O2 = 1);
        F = F || 0;
        z = z || "black";
        var I2 = 15 < u2 - p && 15 < v2 - r2 ? 8 : 0.35 * Math.min(u2 - p, v2 - r2);
        h.beginPath();
        h.moveTo(p, r2);
        h.save();
        h.fillStyle = H;
        h.globalAlpha = O2;
        h.fillRect(p, r2, u2 - p, v2 - r2);
        h.globalAlpha = 1;
        0 < F && (O2 = 0 === F % 2 ? 0 : 0.5, h.beginPath(), h.lineWidth = F, h.strokeStyle = z, h.moveTo(p, r2), h.rect(p - O2, r2 - O2, u2 - p + 2 * O2, v2 - r2 + 2 * O2), h.stroke());
        h.restore();
        true === E2 && (h.save(), h.beginPath(), h.moveTo(p, r2), h.lineTo(p + I2, r2 + I2), h.lineTo(u2 - I2, r2 + I2), h.lineTo(u2, r2), h.closePath(), F = h.createLinearGradient((u2 + p) / 2, r2 + I2, (u2 + p) / 2, r2), F.addColorStop(0, H), F.addColorStop(1, "rgba(255, 255, 255, .4)"), h.fillStyle = F, h.fill(), h.restore());
        true === L && (h.save(), h.beginPath(), h.moveTo(p, v2), h.lineTo(p + I2, v2 - I2), h.lineTo(u2 - I2, v2 - I2), h.lineTo(u2, v2), h.closePath(), F = h.createLinearGradient((u2 + p) / 2, v2 - I2, (u2 + p) / 2, v2), F.addColorStop(0, H), F.addColorStop(1, "rgba(255, 255, 255, .4)"), h.fillStyle = F, h.fill(), h.restore());
        true === R2 && (h.save(), h.beginPath(), h.moveTo(p, r2), h.lineTo(p + I2, r2 + I2), h.lineTo(p + I2, v2 - I2), h.lineTo(p, v2), h.closePath(), F = h.createLinearGradient(p + I2, (v2 + r2) / 2, p, (v2 + r2) / 2), F.addColorStop(0, H), F.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle = F, h.fill(), h.restore());
        true === N2 && (h.save(), h.beginPath(), h.moveTo(u2, r2), h.lineTo(u2 - I2, r2 + I2), h.lineTo(u2 - I2, v2 - I2), h.lineTo(u2, v2), F = h.createLinearGradient(u2 - I2, (v2 + r2) / 2, u2, (v2 + r2) / 2), F.addColorStop(0, H), F.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle = F, F.addColorStop(0, H), F.addColorStop(
          1,
          "rgba(255, 255, 255, 0.1)"
        ), h.fillStyle = F, h.fill(), h.closePath(), h.restore());
      }, ja = function(h) {
        for (var p = "", r2 = 0; r2 < h.length; r2++)
          p += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(r2));
        return p;
      }, db = window && window[ja("mnb`uhno")] && window[ja("mnb`uhno")].href && window[ja("mnb`uhno")].href.indexOf && (-1 !== window[ja("mnb`uhno")].href.indexOf(ja("b`ow`rkr/bnl")) || -1 !== window[ja("mnb`uhno")].href.indexOf(ja("gdonqhy/bnl")) || -1 !== window[ja("mnb`uhno")].href.indexOf(ja("gheemd"))), ib = db && -1 === window[ja("mnb`uhno")].href.indexOf(ja("gheemd")), jb = {
        reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==" },
        pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC" },
        zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=" },
        menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC" },
        handle: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAAzwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7sqSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=" }
      };
      V.prototype.setOptions = function(h, p) {
        if (ra[this._defaultsKey]) {
          var r2 = ra[this._defaultsKey], u2;
          for (u2 in r2)
            "publicProperties" !== u2 && r2.hasOwnProperty(u2) && (this[u2] = h && u2 in h ? h[u2] : p && u2 in p ? p[u2] : r2[u2]);
        } else
          Ja && window.console && console.log("defaults not set");
      };
      V.prototype.get = function(h) {
        var p = ra[this._defaultsKey];
        if ("options" === h)
          return this.options && this.options._isPlaceholder ? null : this.options;
        if (p.hasOwnProperty(h) || p.publicProperties && p.publicProperties.hasOwnProperty(h))
          return this[h];
        window.console && window.console.log('Property "' + h + `" doesn't exist. Please check for typo.`);
      };
      V.prototype.set = function(h, p, r2) {
        r2 = "undefined" === typeof r2 ? true : r2;
        var u2 = ra[this._defaultsKey];
        if ("options" === h)
          this.createUserOptions(p);
        else if (u2.hasOwnProperty(h) || u2.publicProperties && u2.publicProperties.hasOwnProperty(h) && "readWrite" === u2.publicProperties[h])
          this.options._isPlaceholder && this.createUserOptions(), this.options[h] = p;
        else {
          window.console && (u2.publicProperties && u2.publicProperties.hasOwnProperty(h) && "readOnly" === u2.publicProperties[h] ? window.console.log('Property "' + h + '" is read-only.') : window.console.log('Property "' + h + `" doesn't exist. Please check for typo.`));
          return;
        }
        r2 && (this.stockChart || this.chart || this).render();
      };
      V.prototype.addTo = function(h, p, r2, u2) {
        u2 = "undefined" === typeof u2 ? true : u2;
        var v2 = ra[this._defaultsKey];
        v2.hasOwnProperty(h) || v2.publicProperties && v2.publicProperties.hasOwnProperty(h) && "readWrite" === v2.publicProperties[h] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[h] && (this.options[h] = []), h = this.options[h], r2 = "undefined" === typeof r2 || null === r2 ? h.length : r2, h.splice(r2, 0, p), u2 && (this.chart || this).render()) : window.console && (v2.publicProperties && v2.publicProperties.hasOwnProperty(h) && "readOnly" === v2.publicProperties[h] ? window.console.log('Property "' + h + '" is read-only.') : window.console.log('Property "' + h + `" doesn't exist. Please check for typo.`));
      };
      V.prototype.createUserOptions = function(h) {
        if ("undefined" !== typeof h || this.options._isPlaceholder)
          if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {
            this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);
            var p = this.parent.options[this.optionsName], r2 = p.length;
            this.options._isPlaceholder || (Fa(p), r2 = p.indexOf(this.options));
            this.options = "undefined" === typeof h ? {} : h;
            p[r2] = this.options;
          } else
            this.options = "undefined" === typeof h ? {} : h, h = this.parent.options, this.optionsName ? p = this.optionsName : (p = this._defaultsKey) && 0 !== p.length ? (r2 = p.charAt(0).toLowerCase(), 1 < p.length && (r2 = r2.concat(p.slice(1))), p = r2) : p = void 0, h[p] = this.options;
      };
      V.prototype.remove = function(h) {
        h = "undefined" === typeof h ? true : h;
        if (this.isOptionsInArray) {
          var p = this.parent.options[this.optionsName];
          Fa(p);
          var r2 = p.indexOf(this.options);
          0 <= r2 && p.splice(r2, 1);
        } else
          delete this.parent.options[this.optionsName];
        h && (this.chart || this).render();
      };
      V.prototype.updateOption = function(h) {
        !ra[this._defaultsKey] && (Ja && window.console) && console.log("defaults not set");
        var p = ra[this._defaultsKey], r2 = {}, v2 = this[h], E2 = this._themeOptionsKey, H = this._index;
        this.theme && u(E2) && u(H) ? r2 = u(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[E2]) && (null === H ? r2 = this.parent.themeOptions[E2] : 0 < this.parent.themeOptions[E2].length && (r2 = Math.min(this.parent.themeOptions[E2].length - 1, H), r2 = this.parent.themeOptions[E2][r2]));
        this.themeOptions = r2;
        h in p && (v2 = h in this.options ? this.options[h] : r2 && h in r2 ? r2[h] : p[h]);
        if (v2 === this[h])
          return false;
        this[h] = v2;
        return true;
      };
      V.prototype.trackChanges = function(h) {
        if (!this.sessionVariables)
          throw "Session Variable Store not set";
        this.sessionVariables[h] = this.options[h];
      };
      V.prototype.isBeingTracked = function(h) {
        this.options._oldOptions || (this.options._oldOptions = {});
        return this.options._oldOptions[h] ? true : false;
      };
      V.prototype.hasOptionChanged = function(h) {
        if (!this.sessionVariables)
          throw "Session Variable Store not set";
        return this.sessionVariables[h] !== this.options[h];
      };
      V.prototype.addEventListener = function(h, p, r2) {
        h && p && (this._eventListeners[h] = this._eventListeners[h] || [], this._eventListeners[h].push({ context: r2 || this, eventHandler: p }));
      };
      V.prototype.removeEventListener = function(h, p) {
        if (h && p && this._eventListeners[h]) {
          for (var r2 = this._eventListeners[h], u2 = 0; u2 < r2.length; u2++)
            if (r2[u2].eventHandler === p) {
              r2[u2].splice(u2, 1);
              break;
            }
        }
      };
      V.prototype.removeAllEventListeners = function() {
        this._eventListeners = [];
      };
      V.prototype.dispatchEvent = function(h, p, r2) {
        if (h && this._eventListeners[h]) {
          p = p || {};
          for (var u2 = this._eventListeners[h], v2 = 0; v2 < u2.length; v2++)
            u2[v2].eventHandler.call(u2[v2].context, p);
        }
        "function" === typeof this[h] && this[h].call(r2 || this.chart, p);
      };
      Ga.prototype.registerSpace = function(h, p) {
        "top" === h ? this._topOccupied += p.height : "bottom" === h ? this._bottomOccupied += p.height : "left" === h ? this._leftOccupied += p.width : "right" === h && (this._rightOccupied += p.width);
      };
      Ga.prototype.unRegisterSpace = function(h, p) {
        "top" === h ? this._topOccupied -= p.height : "bottom" === h ? this._bottomOccupied -= p.height : "left" === h ? this._leftOccupied -= p.width : "right" === h && (this._rightOccupied -= p.width);
      };
      Ga.prototype.getFreeSpace = function() {
        return {
          x1: this._x1 + this._leftOccupied,
          y1: this._y1 + this._topOccupied,
          x2: this._x2 - this._rightOccupied,
          y2: this._y2 - this._bottomOccupied,
          width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied,
          height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied
        };
      };
      Ga.prototype.reset = function() {
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      };
      qa(ka, V);
      ka.prototype._initialize = function() {
        u(this.padding) || "object" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = u(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = u(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = u(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = u(this.padding.left) ? 0 : Number(this.padding.left) | 0);
      };
      ka.prototype.render = function(h) {
        if (0 !== this.fontSize) {
          h && this.ctx.save();
          var p = this.ctx.font;
          this.ctx.textBaseline = this.textBaseline;
          var r2 = 0;
          this._isDirty && this.measureText(this.ctx);
          this.ctx.translate(this.x, this.y + r2);
          "middle" === this.textBaseline && (r2 = -this._lineHeight / 2);
          this.ctx.font = this._getFontString();
          this.ctx.rotate(Math.PI / 180 * this.angle);
          var u2 = 0, v2 = this.topPadding, H = null;
          this.ctx.roundRect || Ea(this.ctx);
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, r2, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
          this.ctx.fillStyle = this.fontColor;
          for (r2 = 0; r2 < this._wrappedText.lines.length; r2++)
            H = this._wrappedText.lines[r2], "right" === this.horizontalAlign ? u2 = (this.width - (this.leftPadding + this.rightPadding)) / 2 - H.width / 2 + this.leftPadding : "left" === this.horizontalAlign ? u2 = this.leftPadding : "center" === this.horizontalAlign && (u2 = (this.width - (this.leftPadding + this.rightPadding)) / 2 - H.width / 2 + this.leftPadding), this.ctx.fillText(H.text, u2, v2), v2 += H.height;
          this.ctx.font = p;
          h && this.ctx.restore();
        }
      };
      ka.prototype.setText = function(h) {
        this.text = h;
        this._isDirty = true;
        this._wrappedText = null;
      };
      ka.prototype.measureText = function() {
        this._lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);
        if (null === this.maxWidth)
          throw "Please set maxWidth and height for TextBlock";
        this._wrapText(this.ctx);
        this._isDirty = false;
        return { width: this.width, height: this.height };
      };
      ka.prototype._getLineWithWidth = function(h, p, r2) {
        h = String(h);
        if (!h)
          return { text: "", width: 0 };
        var u2 = r2 = 0, v2 = h.length - 1, H = Infinity;
        for (this.ctx.font = this._getFontString(); u2 <= v2; ) {
          var H = Math.floor((u2 + v2) / 2), F = h.substr(0, H + 1);
          r2 = this.ctx.measureText(F).width;
          if (r2 < p)
            u2 = H + 1;
          else if (r2 > p)
            v2 = H - 1;
          else
            break;
        }
        r2 > p && 1 < F.length && (F = F.substr(0, F.length - 1), r2 = this.ctx.measureText(F).width);
        p = true;
        if (F.length === h.length || " " === h[F.length])
          p = false;
        p && (h = F.split(" "), 1 < h.length && h.pop(), F = h.join(" "), r2 = this.ctx.measureText(F).width);
        return { text: F, width: r2 };
      };
      ka.prototype._wrapText = function() {
        var h = new String(Ia(String(this.text))), p = [], r2 = this.ctx.font, u2 = 0, v2 = 0;
        this.ctx.font = this._getFontString();
        if (0 === this.frontSize)
          v2 = u2 = 0;
        else
          for (; 0 < h.length; ) {
            var H = this.maxHeight - (this.topPadding + this.bottomPadding), F = this._getLineWithWidth(h, this.maxWidth - (this.leftPadding + this.rightPadding), false);
            F.height = this._lineHeight;
            p.push(F);
            var z = v2, v2 = Math.max(v2, F.width), u2 = u2 + F.height, h = Ia(h.slice(
              F.text.length,
              h.length
            ));
            H && u2 > H && (F = p.pop(), u2 -= F.height, v2 = z);
          }
        this._wrappedText = { lines: p, width: v2, height: u2 };
        this.width = v2 + (this.leftPadding + this.rightPadding);
        this.height = u2 + (this.topPadding + this.bottomPadding);
        this.ctx.font = r2;
      };
      ka.prototype._getFontString = function() {
        var h;
        h = this.fontStyle ? this.fontStyle + " " : "";
        h += this.fontWeight ? this.fontWeight + " " : "";
        h += this.fontSize ? this.fontSize + "px " : "";
        var p = this.fontFamily ? this.fontFamily + "" : "";
        !r && p && (p = p.split(",")[0], "'" !== p[0] && '"' !== p[0] && (p = "'" + p + "'"));
        return h += p;
      };
      qa(Va, V);
      qa(Aa, V);
      Aa.prototype.setLayout = function() {
        if (this.text) {
          var h = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, p = h.layoutManager.getFreeSpace(), r2 = p.x1, v2 = p.y1, E2 = 0, H = 0, F = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0, z, I2;
          "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = p.width - 4 - F * ("center" === this.horizontalAlign ? 2 : 1)), H = 0.5 * p.height - this.margin - 2, E2 = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = p.height - 4), H = 0.5 * p.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = p.width - 4), H = 0.5 * p.height - 4));
          var L;
          u(this.padding) || "number" !== typeof this.padding ? u(this.padding) || "object" !== typeof this.padding || (L = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, L += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0, L *= 1.25) : L = 2.5 * this.padding;
          this.wrap || (H = Math.min(H, Math.max(1.5 * this.fontSize, this.fontSize + L)));
          H = new ka(this.ctx, { fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor, fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness, backgroundColor: this.backgroundColor, maxWidth: this.maxWidth, maxHeight: H, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: "top" });
          L = H.measureText();
          "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (v2 = p.y1 + 2, I2 = "top") : "bottom" === this.verticalAlign && (v2 = p.y2 - 2 - L.height, I2 = "bottom"), "left" === this.horizontalAlign ? r2 = p.x1 + 2 : "center" === this.horizontalAlign ? r2 = p.x1 + p.width / 2 - L.width / 2 : "right" === this.horizontalAlign && (r2 = p.x2 - 2 - L.width - F), z = this.horizontalAlign, this.width = L.width, this.height = L.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (r2 = p.x1 + 2, v2 = p.y2 - 2 - (this.maxWidth / 2 - L.width / 2), E2 = -90, I2 = "left", this.width = L.height, this.height = L.width) : "right" === this.horizontalAlign ? (r2 = p.x2 - 2, v2 = p.y1 + 2 + (this.maxWidth / 2 - L.width / 2), E2 = 90, I2 = "right", this.width = L.height, this.height = L.width) : "center" === this.horizontalAlign && (v2 = h.y1 + (h.height / 2 - L.height / 2), r2 = h.x1 + (h.width / 2 - L.width / 2), I2 = "center", this.width = L.width, this.height = L.height), z = "center");
          H.x = r2;
          H.y = v2;
          H.angle = E2;
          H.horizontalAlign = z;
          this._textBlock = H;
          h.layoutManager.registerSpace(I2, {
            width: this.width + ("left" === I2 || "right" === I2 ? this.margin + 2 : 0),
            height: this.height + ("top" === I2 || "bottom" === I2 ? this.margin + 2 : 0)
          });
          this.bounds = { x1: r2, y1: v2, x2: r2 + this.width, y2: v2 + this.height };
          this.ctx.textBaseline = "top";
        }
      };
      Aa.prototype.render = function() {
        this._textBlock && this._textBlock.render(true);
      };
      qa(Ka, V);
      Ka.prototype.setLayout = Aa.prototype.setLayout;
      Ka.prototype.render = Aa.prototype.render;
      Wa.prototype.get = function(h, p) {
        var r2 = null;
        0 < this.pool.length ? (r2 = this.pool.pop(), Oa(r2, h, p)) : r2 = ta(h, p);
        return r2;
      };
      Wa.prototype.release = function(h) {
        this.pool.push(h);
      };
      qa(La, V);
      var Na = { addTheme: function(h, p) {
        ya[h] = p;
      }, addColorSet: function(h, p) {
        Ba[h] = p;
      }, addCultureInfo: function(h, p) {
        Ma[h] = p;
      }, formatNumber: function(h, p, r2) {
        r2 = r2 || "en";
        if (Ma[r2])
          return ba(h, p || "#,##0.##", new La(r2));
        throw "Unknown Culture Name";
      }, formatDate: function(h, p, r2) {
        r2 = r2 || "en";
        if (Ma[r2])
          return Ca(h, p || "DD MMM YYYY", new La(r2));
        throw "Unknown Culture Name";
      } };
      "undefined" !== typeof module && "undefined" !== typeof module.exports ? module.exports = Na : "function" === typeof define && define.amd ? define([], function() {
        return Na;
      }) : window.CanvasJS = Na;
      Na.Chart = function() {
        function h(a, d) {
          return a.x - d.x;
        }
        function p(a, d) {
          d = d || {};
          this.theme = u(d.theme) || u(ya[d.theme]) ? "light1" : d.theme;
          p.base.constructor.call(this, "Chart", null, d, null, null);
          var b = this;
          this._containerId = a;
          this._objectsInitialized = false;
          this.overlaidCanvasCtx = this.ctx = null;
          this._indexLabels = [];
          this._panTimerId = 0;
          this._lastTouchEventType = "";
          this._lastTouchData = null;
          this.isAnimating = false;
          this.renderCount = 0;
          this.disableToolTip = this.animatedRender = false;
          this.canvasPool = new Wa();
          this.allDOMEventHandlers = [];
          this.panEnabled = false;
          this._defaultCursor = "default";
          this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };
          this._dataInRenderedOrder = [];
          if (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {
            this.container.innerHTML = "";
            var c = 0, e = 0, c = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, e = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
            this.width = c;
            this.height = e;
            this.x1 = this.y1 = 0;
            this.x2 = this.width;
            this.y2 = this.height;
            this._selectedColorSet = "undefined" !== typeof Ba[this.colorSet] ? Ba[this.colorSet] : Ba.colorSet1;
            this._canvasJSContainer = document.createElement("div");
            this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container");
            this._canvasJSContainer.style.position = "relative";
            this._canvasJSContainer.style.textAlign = "left";
            this._canvasJSContainer.style.cursor = "auto";
            r || (this._canvasJSContainer.style.height = "0px");
            this.container.appendChild(this._canvasJSContainer);
            this.canvas = ta(c, e);
            this._preRenderCanvas = ta(c, e);
            this.canvas.style.position = "absolute";
            this.canvas.style.WebkitUserSelect = "none";
            this.canvas.style.MozUserSelect = "none";
            this.canvas.style.msUserSelect = "none";
            this.canvas.style.userSelect = "none";
            this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Ea(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", Ea(this._preRenderCtx), r ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ta(c, e), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = ta(c, e), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", Ea(this.overlaidCanvasCtx)), this._eventManager = new ha2(this), this.windowResizeHandler = O(window, "resize", function() {
              b._updateSize() && b.render();
            }, this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, O(this.overlaidCanvas, "click", function(a2) {
              b._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, "mousemove", function(a2) {
              b._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, "mouseup", function(a2) {
              b._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, "mousedown", function(a2) {
              b._mouseEventHandler(a2);
              va(b._dropdownMenu);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, "mouseout", function(a2) {
              b._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(a2) {
              b._touchEventHandler(a2);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(a2) {
              b._touchEventHandler(a2);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function(a2) {
              b._touchEventHandler(a2);
            }, this.allDOMEventHandlers), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function(a2) {
              b._touchEventHandler(a2);
            }, this.allDOMEventHandlers), this.toolTip = new $2(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] });
          } else
            window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found');
        }
        function v2(a, d) {
          for (var b = [], c, e = 0; e < a.length; e++)
            if (0 == e)
              b.push(a[0]);
            else {
              var g, k, l;
              l = e - 1;
              g = 0 === l ? 0 : l - 1;
              k = l === a.length - 1 ? l : l + 1;
              c = Math.abs((a[k].x - a[g].x) / (0 === a[k].x - a[l].x ? 0.01 : a[k].x - a[l].x)) * (d - 1) / 2 + 1;
              var w = (a[k].x - a[g].x) / c;
              c = (a[k].y - a[g].y) / c;
              b[b.length] = a[l].x > a[g].x && 0 < w || a[l].x < a[g].x && 0 > w ? { x: a[l].x + w / 3, y: a[l].y + c / 3 } : { x: a[l].x, y: a[l].y + c / 9 };
              l = e;
              g = 0 === l ? 0 : l - 1;
              k = l === a.length - 1 ? l : l + 1;
              c = Math.abs((a[k].x - a[g].x) / (0 === a[l].x - a[g].x ? 0.01 : a[l].x - a[g].x)) * (d - 1) / 2 + 1;
              w = (a[k].x - a[g].x) / c;
              c = (a[k].y - a[g].y) / c;
              b[b.length] = a[l].x > a[g].x && 0 < w || a[l].x < a[g].x && 0 > w ? { x: a[l].x - w / 3, y: a[l].y - c / 3 } : { x: a[l].x, y: a[l].y - c / 9 };
              b[b.length] = a[e];
            }
          return b;
        }
        function E2(a, d, b, c, e, g, k, l, w, m) {
          var s = 0;
          m ? (k.color = g, l.color = g) : m = 1;
          s = w ? Math.abs(e - b) : Math.abs(c - d);
          s = 0 < k.trimLength ? Math.abs(s * k.trimLength / 100) : Math.abs(s - k.length);
          w ? (b += s / 2, e -= s / 2) : (d += s / 2, c -= s / 2);
          var s = 1 === Math.round(k.thickness) % 2 ? 0.5 : 0, q = 1 === Math.round(l.thickness) % 2 ? 0.5 : 0;
          a.save();
          a.globalAlpha = m;
          a.strokeStyle = l.color || g;
          a.lineWidth = l.thickness || 2;
          a.setLineDash && a.setLineDash(R(l.dashType, l.thickness));
          a.beginPath();
          w && 0 < l.thickness ? (a.moveTo(c - k.thickness / 2, Math.round((b + e) / 2) - q), a.lineTo(d + k.thickness / 2, Math.round((b + e) / 2) - q)) : 0 < l.thickness && (a.moveTo(Math.round((d + c) / 2) - q, b + k.thickness / 2), a.lineTo(Math.round((d + c) / 2) - q, e - k.thickness / 2));
          a.stroke();
          a.strokeStyle = k.color || g;
          a.lineWidth = k.thickness || 2;
          a.setLineDash && a.setLineDash(R(k.dashType, k.thickness));
          a.beginPath();
          w && 0 < k.thickness ? (a.moveTo(c - s, b), a.lineTo(c - s, e), a.moveTo(d + s, b), a.lineTo(d + s, e)) : 0 < k.thickness && (a.moveTo(d, b + s), a.lineTo(c, b + s), a.moveTo(d, e - s), a.lineTo(c, e - s));
          a.stroke();
          a.restore();
        }
        function I2(a, d, b, c, e) {
          if (null === a || "undefined" === typeof a)
            return "undefined" === typeof b ? d : b;
          a = parseFloat(a.toString()) * (0 <= a.toString().indexOf("%") ? d / 100 : 1);
          "undefined" !== typeof c && (a = Math.min(c, a), "undefined" !== typeof e && (a = Math.max(e, a)));
          return !isNaN(a) && a <= d && 0 <= a ? a : "undefined" === typeof b ? d : b;
        }
        function H(a, d) {
          H.base.constructor.call(
            this,
            "Legend",
            "legend",
            d,
            null,
            a
          );
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = this.chart.ctx;
          this.ghostCtx = this.chart._eventManager.ghostCtx;
          this.items = [];
          this.optionsName = "legend";
          this.height = this.width = 0;
          this.orientation = null;
          this.dataSeries = [];
          this.bounds = { x1: null, y1: null, x2: null, y2: null };
          "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
          this.lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);
          this.horizontalSpacing = this.fontSize;
        }
        function F(a, d, b, c) {
          F.base.constructor.call(
            this,
            "DataSeries",
            "data",
            d,
            b,
            a
          );
          this.chart = a;
          this.canvas = a.canvas;
          this._ctx = a.canvas.ctx;
          this.index = b;
          this.noDataPointsInPlotArea = 0;
          this.id = c;
          this.chart._eventManager.objectMap[c] = { id: c, objectType: "dataSeries", dataSeriesIndex: b };
          a = d.dataPoints ? d.dataPoints.length : 0;
          this.dataPointEOs = [];
          for (d = 0; d < a; d++)
            this.dataPointEOs[d] = {};
          this.dataPointIds = [];
          this.plotUnit = [];
          this.axisY = this.axisX = null;
          this.optionsName = "data";
          this.isOptionsInArray = true;
          null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);
          this.axisPlacement = this.getDefaultAxisPlacement();
          "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));
        }
        function z(a, d, b, c, e, g) {
          z.base.constructor.call(this, "Axis", d, b, c, a);
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = a.ctx;
          this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;
          this.labels = [];
          this.dataSeries = [];
          this._stripLineLabels = this._ticks = this._labels = null;
          this.dataInfo = {
            min: Infinity,
            max: -Infinity,
            viewPortMin: Infinity,
            viewPortMax: -Infinity,
            minDiff: Infinity
          };
          this.isOptionsInArray = true;
          "axisX" === e ? ("left" === g || "bottom" === g ? (this.optionsName = "axisX", u(this.chart.sessionVariables.axisX[c]) && (this.chart.sessionVariables.axisX[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[c]) : (this.optionsName = "axisX2", u(this.chart.sessionVariables.axisX2[c]) && (this.chart.sessionVariables.axisX2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[c]), this.options.interval || (this.intervalType = null)) : "left" === g || "bottom" === g ? (this.optionsName = "axisY", u(this.chart.sessionVariables.axisY[c]) && (this.chart.sessionVariables.axisY[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[c]) : (this.optionsName = "axisY2", u(this.chart.sessionVariables.axisY2[c]) && (this.chart.sessionVariables.axisY2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[c]);
          "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));
          "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));
          this.type = e;
          "axisX" !== e || b && "undefined" !== typeof b.gridThickness || (this.gridThickness = 0);
          this._position = g;
          this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null };
          this.labelAngle = (this.labelAngle % 360 + 360) % 360;
          90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);
          this.options.scaleBreaks && (this.scaleBreaks = new Q2(
            this.chart,
            this.options.scaleBreaks,
            ++this.chart._eventManager.lastObjectId,
            this
          ));
          this.stripLines = [];
          if (this.options.stripLines && 0 < this.options.stripLines.length)
            for (a = 0; a < this.options.stripLines.length; a++)
              this.stripLines.push(new X2(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));
          this.options.crosshair && (this.crosshair = new fa2(this.chart, this.options.crosshair, this));
          this._titleTextBlock = null;
          this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);
          this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;
          this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);
          this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;
          null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
          null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
          this.trackChanges("viewportMinimum");
          this.trackChanges("viewportMaximum");
        }
        function Q2(a, d, b, c) {
          Q2.base.constructor.call(
            this,
            "ScaleBreaks",
            "scaleBreaks",
            d,
            null,
            c
          );
          this.id = b;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.axis = c;
          this.optionsName = "scaleBreaks";
          this.isOptionsInArray = false;
          this._appliedBreaks = [];
          this.customBreaks = [];
          this.autoBreaks = [];
          "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8);
          this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));
          if (this.options.customBreaks && 0 < this.options.customBreaks.length) {
            for (a = 0; a < this.options.customBreaks.length; a++)
              this.customBreaks.push(new L(this.chart, "customBreaks", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[a].startValue && ("number" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]);
            this._appliedBreaks.sort(function(a2, c2) {
              return a2.startValue - c2.startValue;
            });
            for (a = 0; a < this._appliedBreaks.length - 1; a++)
              this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + a + " and " + (a + 1) + " are overlapping."), this._appliedBreaks.splice(a, 2), a--);
          }
        }
        function L(a, d, b, c, e, g) {
          L.base.constructor.call(this, "Break", d, b, c, g);
          this.id = e;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.scaleBreaks = g;
          this.optionsName = d;
          this.isOptionsInArray = true;
          this.type = b.type ? this.type : g.type;
          this.fillOpacity = u(b.fillOpacity) ? g.fillOpacity : this.fillOpacity;
          this.lineThickness = u(b.lineThickness) ? g.lineThickness : this.lineThickness;
          this.color = b.color ? this.color : g.color;
          this.lineColor = b.lineColor ? this.lineColor : g.lineColor;
          this.lineDashType = b.lineDashType ? this.lineDashType : g.lineDashType;
          !u(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());
          !u(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());
          "number" === typeof this.startValue && ("number" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue, this.startValue = this.endValue, this.endValue = a);
          this.spacing = "undefined" === typeof b.spacing ? g.spacing : b.spacing;
          "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = g.spacing);
          this.size = g.parent.logarithmic ? 1 : 0;
        }
        function X2(a, d, b, c, e) {
          X2.base.constructor.call(this, "StripLine", "stripLines", d, b, e);
          this.id = c;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.label = this.label;
          this.axis = e;
          this.optionsName = "stripLines";
          this.isOptionsInArray = true;
          this._thicknessType = "pixel";
          null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);
        }
        function fa2(a, d, b) {
          fa2.base.constructor.call(this, "Crosshair", "crosshair", d, null, b);
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.axis = b;
          this.optionsName = "crosshair";
          this._thicknessType = "pixel";
        }
        function $2(a, d) {
          $2.base.constructor.call(this, "ToolTip", "toolTip", d, null, a);
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = this.chart.ctx;
          this.currentDataPointIndex = this.currentSeriesIndex = -1;
          this._prevY = this._prevX = NaN;
          this.containerTransitionDuration = 0.1;
          this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);
          this.optionsName = "toolTip";
          this._initialize();
        }
        function ha2(a) {
          this.chart = a;
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.ghostCanvas = ta(this.chart.width, this.chart.height);
          this.ghostCtx = this.ghostCanvas.getContext("2d");
          this.mouseoveredObjectMaps = [];
        }
        function ga2(a) {
          this.chart = a;
          this.ctx = this.chart.plotArea.ctx;
          this.animations = [];
          this.animationRequestId = null;
        }
        qa(p, V);
        p.prototype.destroy = function() {
          var a = this.allDOMEventHandlers;
          this._animator && this._animator.cancelAllAnimations();
          this._panTimerId && clearTimeout(this._panTimerId);
          for (var d = 0; d < a.length; d++) {
            var b = a[d][0], c = a[d][1], e = a[d][2], g = a[d][3], g = g || false;
            b.removeEventListener ? b.removeEventListener(c, e, g) : b.detachEvent && b.detachEvent("on" + c, e);
          }
          this.allDOMEventHandlers = [];
          for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes(); )
            this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
          for (; this.container && this.container.hasChildNodes(); )
            this.container.removeChild(this.container.lastChild);
          for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes(); )
            this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
          this.overlaidCanvas = this.canvas = this.container = this._canvasJSContainer = null;
          this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = this._breaksCanvas = this._preRenderCanvas = this.toolTip.container = null;
        };
        p.prototype._updateOptions = function() {
          var a = this;
          this.updateOption("width");
          this.updateOption("height");
          this.updateOption("dataPointWidth");
          this.updateOption("dataPointMinWidth");
          this.updateOption("dataPointMaxWidth");
          this.updateOption("interactivityEnabled");
          this.updateOption("theme");
          this.updateOption("colorSet") && (this._selectedColorSet = "undefined" !== typeof Ba[this.colorSet] ? Ba[this.colorSet] : Ba.colorSet1);
          this.updateOption("backgroundColor");
          this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)");
          this.updateOption("culture");
          this._cultureInfo = new La(this.options.culture);
          this.updateOption("animationEnabled");
          this.animationEnabled = this.animationEnabled && r;
          this.updateOption("animationDuration");
          this.updateOption("rangeChanging");
          this.updateOption("rangeChanged");
          this.updateOption("exportEnabled");
          this.updateOption("exportFileName");
          this.updateOption("zoomType");
          if (this.options.zoomEnabled) {
            if (!this._zoomButton) {
              var d = false;
              va(this._zoomButton = document.createElement("button"));
              ua(this, this._zoomButton, "pan");
              this._toolBar.appendChild(this._zoomButton);
              this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor;
              O(this._zoomButton, "touchstart", function(a2) {
                d = true;
              }, this.allDOMEventHandlers);
              O(this._zoomButton, "click", function() {
                a.zoomEnabled ? (a.zoomEnabled = false, a.panEnabled = true, ua(a, a._zoomButton, "zoom")) : (a.zoomEnabled = true, a.panEnabled = false, ua(a, a._zoomButton, "pan"));
                a.render();
              }, this.allDOMEventHandlers);
              O(this._zoomButton, "mouseover", function() {
                d ? d = false : (sa(a, a._zoomButton, {
                  backgroundColor: a.toolbar.backgroundColorOnHover,
                  color: a.toolbar.fontColorOnHover,
                  transition: "0.4s",
                  WebkitTransition: "0.4s"
                }), 0 >= navigator.userAgent.search("MSIE") && sa(a, a._zoomButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
              }, this.allDOMEventHandlers);
              O(this._zoomButton, "mouseout", function() {
                d || (sa(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && sa(a, a._zoomButton.childNodes[0], {
                  WebkitFilter: "invert(0%)",
                  filter: "invert(0%)"
                }));
              }, this.allDOMEventHandlers);
            }
            this._resetButton || (d = false, va(this._resetButton = document.createElement("button")), ua(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), O(this._resetButton, "touchstart", function(a2) {
              d = true;
            }, this.allDOMEventHandlers), O(this._resetButton, "click", function() {
              a.toolTip.hide();
              a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = true, a.panEnabled = false, ua(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = false, a.panEnabled = false);
              if (a.sessionVariables.axisX)
                for (var c2 = 0; c2 < a.sessionVariables.axisX.length; c2++)
                  a.sessionVariables.axisX[c2].newViewportMinimum = null, a.sessionVariables.axisX[c2].newViewportMaximum = null;
              if (a.sessionVariables.axisX2)
                for (c2 = 0; c2 < a.sessionVariables.axisX2.length; c2++)
                  a.sessionVariables.axisX2[c2].newViewportMinimum = null, a.sessionVariables.axisX2[c2].newViewportMaximum = null;
              if (a.sessionVariables.axisY)
                for (c2 = 0; c2 < a.sessionVariables.axisY.length; c2++)
                  a.sessionVariables.axisY[c2].newViewportMinimum = null, a.sessionVariables.axisY[c2].newViewportMaximum = null;
              if (a.sessionVariables.axisY2)
                for (c2 = 0; c2 < a.sessionVariables.axisY2.length; c2++)
                  a.sessionVariables.axisY2[c2].newViewportMinimum = null, a.sessionVariables.axisY2[c2].newViewportMaximum = null;
              a.resetOverlayedCanvas();
              va(a._zoomButton, a._resetButton);
              a._dispatchRangeEvent("rangeChanging", "reset");
              a.render();
              a._dispatchRangeEvent(
                "rangeChanged",
                "reset"
              );
              a.syncCharts && a.syncCharts(null, null);
            }, this.allDOMEventHandlers), O(this._resetButton, "mouseover", function() {
              d || (sa(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.hoverFfontColorOnHoverontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && sa(a, a._resetButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
            }, this.allDOMEventHandlers), O(this._resetButton, "mouseout", function() {
              d || (sa(
                a,
                a._resetButton,
                { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }
              ), 0 >= navigator.userAgent.search("MSIE") && sa(a, a._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
            }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor);
            this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = true, this.zoomEnabled = false) : (this.zoomEnabled = true, this.panEnabled = false), Qa(a._zoomButton, a._resetButton)) : (this.zoomEnabled = true, this.panEnabled = false));
          } else
            this.panEnabled = this.zoomEnabled = false;
          this._menuButton ? this.exportEnabled ? Qa(this._menuButton) : va(this._menuButton) : this.exportEnabled && r && (d = false, this._menuButton = document.createElement("button"), ua(this, this._menuButton, "menu"), this._toolBar.appendChild(this._menuButton), O(this._menuButton, "touchstart", function(a2) {
            d = true;
          }, this.allDOMEventHandlers), O(this._menuButton, "click", function() {
            "none" !== a._dropdownMenu.style.display || a._dropDownCloseTime && 500 >= (/* @__PURE__ */ new Date()).getTime() - a._dropDownCloseTime.getTime() || (a._dropdownMenu.style.display = "block", a._menuButton.blur(), a._dropdownMenu.focus());
          }, this.allDOMEventHandlers, true), O(this._menuButton, "mouseover", function() {
            d || (sa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search("MSIE") && sa(a, a._menuButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
          }, this.allDOMEventHandlers, true), O(this._menuButton, "mouseout", function() {
            d || (sa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor }), 0 >= navigator.userAgent.search("MSIE") && sa(a, a._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
          }, this.allDOMEventHandlers, true));
          if (!this._dropdownMenu && this.exportEnabled && r) {
            d = false;
            this._dropdownMenu = document.createElement("div");
            this._dropdownMenu.setAttribute("tabindex", -1);
            var b = -1 !== this.theme.indexOf("dark") ? "black" : "#888888";
            this._dropdownMenu.style.cssText = "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:" + this.toolbar.backgroundColor + ";box-shadow: 2px 2px 10px " + b;
            a._dropdownMenu.style.display = "none";
            this._toolBar.appendChild(this._dropdownMenu);
            O(this._dropdownMenu, "blur", function() {
              va(a._dropdownMenu);
              a._dropDownCloseTime = /* @__PURE__ */ new Date();
            }, this.allDOMEventHandlers, true);
            b = document.createElement("div");
            b.style.cssText = "padding: 12px 8px 12px 8px";
            b.innerHTML = this._cultureInfo.printText;
            b.style.backgroundColor = this.toolbar.backgroundColor;
            b.style.color = this.toolbar.fontColor;
            this._dropdownMenu.appendChild(b);
            O(b, "touchstart", function(a2) {
              d = true;
            }, this.allDOMEventHandlers);
            O(
              b,
              "mouseover",
              function() {
                d || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover);
              },
              this.allDOMEventHandlers,
              true
            );
            O(b, "mouseout", function() {
              d || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor);
            }, this.allDOMEventHandlers, true);
            O(b, "click", function() {
              a.print();
              va(a._dropdownMenu);
            }, this.allDOMEventHandlers, true);
            b = document.createElement("div");
            b.style.cssText = "padding: 12px 8px 12px 8px";
            b.innerHTML = this._cultureInfo.saveJPGText;
            b.style.backgroundColor = this.toolbar.backgroundColor;
            b.style.color = this.toolbar.fontColor;
            this._dropdownMenu.appendChild(b);
            O(b, "touchstart", function(a2) {
              d = true;
            }, this.allDOMEventHandlers);
            O(b, "mouseover", function() {
              d || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover);
            }, this.allDOMEventHandlers, true);
            O(b, "mouseout", function() {
              d || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor);
            }, this.allDOMEventHandlers, true);
            O(b, "click", function() {
              Ta(a.canvas, "jpeg", a.exportFileName);
              va(a._dropdownMenu);
            }, this.allDOMEventHandlers, true);
            b = document.createElement("div");
            b.style.cssText = "padding: 12px 8px 12px 8px";
            b.innerHTML = this._cultureInfo.savePNGText;
            b.style.backgroundColor = this.toolbar.backgroundColor;
            b.style.color = this.toolbar.fontColor;
            this._dropdownMenu.appendChild(b);
            O(b, "touchstart", function(a2) {
              d = true;
            }, this.allDOMEventHandlers);
            O(b, "mouseover", function() {
              d || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover);
            }, this.allDOMEventHandlers, true);
            O(b, "mouseout", function() {
              d || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor);
            }, this.allDOMEventHandlers, true);
            O(b, "click", function() {
              Ta(a.canvas, "png", a.exportFileName);
              va(a._dropdownMenu);
            }, this.allDOMEventHandlers, true);
          }
          "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? ua(a, a._zoomButton, "zoom") : ua(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && ua(a, a._resetButton, "reset"));
          this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);
          for (var c in this.toolTip.options)
            this.toolTip.options.hasOwnProperty(c) && this.toolTip.updateOption(c);
        };
        p.prototype._updateSize = function() {
          var a;
          a = [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas];
          var d = 0, b = 0;
          this.options.width ? d = this.width : this.width = d = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;
          this.options.height ? b = this.height : this.height = b = 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
          if (this.canvas.width !== d * W || this.canvas.height !== b * W) {
            for (var c = 0; c < a.length; c++)
              Oa(a[c], d, b);
            a = true;
          } else
            a = false;
          return a;
        };
        p.prototype._initialize = function() {
          this.isNavigator = u(this.parent) || u(this.parent._defaultsKey) || "Navigator" !== this.parent._defaultsKey ? false : true;
          this.toolbar = new Va(this, this.options.toolbar);
          this._animator ? this._animator.cancelAllAnimations() : this._animator = new ga2(this);
          this.removeAllEventListeners();
          this.disableToolTip = false;
          this._axes = [];
          this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;
          this._updateOptions();
          this.animatedRender = r && this.animationEnabled && 0 === this.renderCount;
          this._updateSize();
          this.clearCanvas();
          this.ctx.beginPath();
          this.axisX = [];
          this.axisX2 = [];
          this.axisY = [];
          this.axisY2 = [];
          this._indexLabels = [];
          this._dataInRenderedOrder = [];
          this._events = [];
          this._eventManager && this._eventManager.reset();
          this.plotInfo = { axisPlacement: null, plotTypes: [] };
          this.layoutManager = new Ga(0, 0, this.width, this.height, this.isNavigator ? 0 : 2);
          this.plotArea.layoutManager && this.plotArea.layoutManager.reset();
          this.data = [];
          var a = 0, d = null;
          if (this.options.data) {
            for (var b = 0; b < this.options.data.length; b++)
              if (a++, !this.options.data[b].type || 0 <= p._supportedChartTypes.indexOf(this.options.data[b].type)) {
                var c = new F(this, this.options.data[b], a - 1, ++this._eventManager.lastObjectId);
                "error" === c.type && (c.linkedDataSeriesIndex = u(this.options.data[b].linkedDataSeriesIndex) ? b - 1 : this.options.data[b].linkedDataSeriesIndex, 0 > c.linkedDataSeriesIndex || c.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof c.linkedDataSeriesIndex || "error" === this.options.data[c.linkedDataSeriesIndex].type) && (c.linkedDataSeriesIndex = null);
                null === c.name && (c.name = "DataSeries " + a);
                null === c.color ? 1 < this.options.data.length ? (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]], c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "candlestick" === c.type || "ohlc" === c.type || "waterfall" === c.type || "boxAndWhisker" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet : c._colorSet = [c.color];
                null === c.markerSize && (("line" === c.type || "stepLine" === c.type || "spline" === c.type || 0 <= c.type.toLowerCase().indexOf("area")) && c.dataPoints && c.dataPoints.length < this.width / 16 || "scatter" === c.type) && (c.markerSize = 8);
                "bubble" !== c.type && "scatter" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function(a2) {
                  return a2.x;
                }) && c.dataPoints.sort(h) : c.dataPoints.sort(h));
                this.data.push(c);
                var e = c.axisPlacement, d = d || e, g;
                "normal" === e ? "xySwapped" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === e ? "normal" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === e ? "normal" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === e && "none" === this.plotInfo.axisPlacement && (g = 'You cannot combine "' + c.type + '" with pie chart');
                if (g && window.console) {
                  window.console.log(g);
                  return;
                }
              }
            for (b = 0; b < this.data.length; b++) {
              if ("none" == d && "error" === this.data[b].type && window.console) {
                window.console.log('You cannot combine "' + c.type + '" with error chart');
                return;
              }
              "error" === this.data[b].type && (this.data[b].axisPlacement = this.plotInfo.axisPlacement = d || "normal", this.data[b]._linkedSeries = null === this.data[b].linkedDataSeriesIndex ? null : this.data[this.data[b].linkedDataSeriesIndex]);
            }
          }
          this._objectsInitialized = true;
          this._plotAreaElements = [];
        };
        p._supportedChartTypes = Fa("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));
        p.prototype.setLayout = function() {
          for (var a = this._plotAreaElements, d = 0; d < this.data.length; d++)
            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
              if (!this.data[d].axisYType || "primary" === this.data[d].axisYType)
                if (this.options.axisY && 0 < this.options.axisY.length) {
                  if (!this.axisY.length)
                    for (var b = 0; b < this.options.axisY.length; b++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[b] = new z(this, "axisY", this.options.axisY[b], b, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[b] = new z(this, "axisY", this.options.axisY[b], b, "axisY", "bottom"));
                  this.data[d].axisY = this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ? this.data[d].axisYIndex : 0];
                  this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d]);
                } else
                  this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new z(
                    this,
                    "axisY",
                    this.options.axisY,
                    0,
                    "axisY",
                    "left"
                  )) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new z(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[d].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[d]);
              if ("secondary" === this.data[d].axisYType)
                if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                  if (!this.axisY2.length)
                    for (b = 0; b < this.options.axisY2.length; b++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[b] = new z(
                        this,
                        "axisY2",
                        this.options.axisY2[b],
                        b,
                        "axisY",
                        "right"
                      )) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[b] = new z(this, "axisY2", this.options.axisY2[b], b, "axisY", "top"));
                  this.data[d].axisY = this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY2.length ? this.data[d].axisYIndex : 0];
                  this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY2.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d]);
                } else
                  this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new z(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new z(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[d].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[d]);
              if (!this.data[d].axisXType || "primary" === this.data[d].axisXType)
                if (this.options.axisX && 0 < this.options.axisX.length) {
                  if (!this.axisX.length)
                    for (b = 0; b < this.options.axisX.length; b++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[b] = new z(this, "axisX", this.options.axisX[b], b, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[b] = new z(this, "axisX", this.options.axisX[b], b, "axisX", "left"));
                  this.data[d].axisX = this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0];
                  this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d]);
                } else
                  this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new z(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new z(this, "axisX", this.options.axisX, 0, "axisX", "left"))), this.data[d].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[d]);
              if ("secondary" === this.data[d].axisXType)
                if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                  if (!this.axisX2.length)
                    for (b = 0; b < this.options.axisX2.length; b++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[b] = new z(this, "axisX2", this.options.axisX2[b], b, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[b] = new z(this, "axisX2", this.options.axisX2[b], b, "axisX", "right"));
                  this.data[d].axisX = this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0];
                  this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d]);
                } else
                  this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new z(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new z(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[d].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[d]);
            }
          if (this.axisY) {
            for (b = 1; b < this.axisY.length; b++)
              "undefined" === typeof this.axisY[b].options.gridThickness && (this.axisY[b].gridThickness = 0);
            for (b = 0; b < this.axisY.length - 1; b++)
              "undefined" === typeof this.axisY[b].options.margin && (this.axisY[b].margin = 10);
          }
          if (this.axisY2) {
            for (b = 1; b < this.axisY2.length; b++)
              "undefined" === typeof this.axisY2[b].options.gridThickness && (this.axisY2[b].gridThickness = 0);
            for (b = 0; b < this.axisY2.length - 1; b++)
              "undefined" === typeof this.axisY2[b].options.margin && (this.axisY2[b].margin = 10);
          }
          this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));
          if (this.axisX)
            for (b = 0; b < this.axisX.length; b++)
              "undefined" === typeof this.axisX[b].options.gridThickness && (this.axisX[b].gridThickness = 0);
          if (this.axisX2)
            for (b = 0; b < this.axisX2.length; b++)
              "undefined" === typeof this.axisX2[b].options.gridThickness && (this.axisX2[b].gridThickness = 0);
          this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness && "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));
          b = false;
          if (0 < this._axes.length && (this.zoomEnabled || this.panEnabled)) {
            for (d = 0; d < this._axes.length; d++)
              if (null !== this._axes[d].viewportMinimum || null !== this._axes[d].viewportMaximum) {
                b = true;
                break;
              }
          }
          b ? (Qa(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor) : (va(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = true, this.panEnabled = false));
          gb(this);
          this._processData();
          this.options.title && (this.title = new Aa(
            this,
            this.options.title
          ), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout());
          this.subtitles = [];
          if (this.options.subtitles)
            for (d = 0; d < this.options.subtitles.length; d++)
              b = new Ka(this, this.options.subtitles[d], d), this.subtitles.push(b), b.dockInsidePlotArea ? a.push(b) : b.setLayout();
          this.legend = new H(this, this.options.legend);
          for (d = 0; d < this.data.length; d++)
            (this.data[d].showInLegend || "pie" === this.data[d].type || "doughnut" === this.data[d].type || "funnel" === this.data[d].type || "pyramid" === this.data[d].type) && this.legend.dataSeries.push(this.data[d]);
          this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout();
          for (d = 0; d < this._axes.length; d++)
            if (this._axes[d].scaleBreaks && this._axes[d].scaleBreaks._appliedBreaks.length) {
              r ? (this._breaksCanvas = ta(this.width, this.height, true), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);
              break;
            }
          this._preRenderCanvas = ta(this.width, this.height);
          this._preRenderCtx = this._preRenderCanvas.getContext("2d");
          "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || z.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
        };
        p.prototype.renderElements = function() {
          var a = this._plotAreaElements;
          this.title && !this.title.dockInsidePlotArea && this.title.render();
          for (var d = 0; d < this.subtitles.length; d++)
            this.subtitles[d].dockInsidePlotArea || this.subtitles[d].render();
          this.legend.dockInsidePlotArea || this.legend.render();
          if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement)
            z.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement);
          else if ("none" === this.plotInfo.axisPlacement)
            this.preparePlotArea();
          else
            return;
          for (d = 0; d < a.length; d++)
            a[d].setLayout(), a[d].render();
          var b = [];
          if (this.animatedRender) {
            var c = ta(this.width, this.height);
            c.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height);
          }
          hb(this);
          var a = this.ctx.miterLimit, e;
          this.ctx.miterLimit = 3;
          r && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));
          for (d = 0; d < this.plotInfo.plotTypes.length; d++)
            for (var g = this.plotInfo.plotTypes[d], k = 0; k < g.plotUnits.length; k++) {
              var l = g.plotUnits[k], w = null;
              l.targetCanvas = null;
              this.animatedRender && (l.targetCanvas = ta(this.width, this.height), l.targetCanvasCtx = l.targetCanvas.getContext("2d"), e = l.targetCanvasCtx.miterLimit, l.targetCanvasCtx.miterLimit = 3);
              "line" === l.type ? w = this.renderLine(l) : "stepLine" === l.type ? w = this.renderStepLine(l) : "spline" === l.type ? w = this.renderSpline(l) : "column" === l.type ? w = this.renderColumn(l) : "bar" === l.type ? w = this.renderBar(l) : "area" === l.type ? w = this.renderArea(l) : "stepArea" === l.type ? w = this.renderStepArea(l) : "splineArea" === l.type ? w = this.renderSplineArea(l) : "stackedColumn" === l.type ? w = this.renderStackedColumn(l) : "stackedColumn100" === l.type ? w = this.renderStackedColumn100(l) : "stackedBar" === l.type ? w = this.renderStackedBar(l) : "stackedBar100" === l.type ? w = this.renderStackedBar100(l) : "stackedArea" === l.type ? w = this.renderStackedArea(l) : "stackedArea100" === l.type ? w = this.renderStackedArea100(l) : "bubble" === l.type ? w = w = this.renderBubble(l) : "scatter" === l.type ? w = this.renderScatter(l) : "pie" === l.type ? this.renderPie(l) : "doughnut" === l.type ? this.renderPie(l) : "funnel" === l.type ? w = this.renderFunnel(l) : "pyramid" === l.type ? w = this.renderFunnel(l) : "candlestick" === l.type ? w = this.renderCandlestick(l) : "ohlc" === l.type ? w = this.renderCandlestick(l) : "rangeColumn" === l.type ? w = this.renderRangeColumn(l) : "error" === l.type ? w = this.renderError(l) : "rangeBar" === l.type ? w = this.renderRangeBar(l) : "rangeArea" === l.type ? w = this.renderRangeArea(l) : "rangeSplineArea" === l.type ? w = this.renderRangeSplineArea(l) : "waterfall" === l.type ? w = this.renderWaterfall(l) : "boxAndWhisker" === l.type && (w = this.renderBoxAndWhisker(l));
              for (var m = 0; m < l.dataSeriesIndexes.length; m++)
                this._dataInRenderedOrder.push(this.data[l.dataSeriesIndexes[m]]);
              this.animatedRender && (l.targetCanvasCtx.miterLimit = e, w && b.push(w));
            }
          this.ctx.miterLimit = a;
          this.animatedRender && this._breaksCanvasCtx && b.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 });
          this.animatedRender && 0 < this._indexLabels.length && (e = ta(this.width, this.height).getContext("2d"), b.push(this.renderIndexLabels(e)));
          var s = this;
          if (0 < b.length)
            s.disableToolTip = true, s._animator.animate(200, s.animationDuration, function(a2) {
              s.ctx.clearRect(0, 0, s.width, s.height);
              s.ctx.drawImage(c, 0, 0, Math.floor(s.width * W), Math.floor(s.height * W), 0, 0, s.width, s.height);
              for (var e2 = 0; e2 < b.length; e2++)
                w = b[e2], 1 > a2 && "undefined" !== typeof w.startTimePercent ? a2 >= w.startTimePercent && w.animationCallback(w.easingFunction(a2 - w.startTimePercent, 0, 1, 1 - w.startTimePercent), w) : w.animationCallback(w.easingFunction(a2, 0, 1, 1), w);
              s.dispatchEvent("dataAnimationIterationEnd", { chart: s });
            }, function() {
              b = [];
              for (var a2 = 0; a2 < s.plotInfo.plotTypes.length; a2++)
                for (var e2 = s.plotInfo.plotTypes[a2], d2 = 0; d2 < e2.plotUnits.length; d2++)
                  e2.plotUnits[d2].targetCanvas = null;
              c = null;
              s.disableToolTip = false;
            });
          else {
            if (s._breaksCanvas)
              if (r)
                s.plotArea.ctx.drawImage(s._breaksCanvas, 0, 0, this.width, this.height);
              else
                for (m = 0; m < s._axes.length; m++)
                  s._axes[m].createMask();
            0 < s._indexLabels.length && s.renderIndexLabels();
            s.dispatchEvent("dataAnimationIterationEnd", { chart: s });
          }
          this.attachPlotAreaEventHandlers();
          this.zoomEnabled || (this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display) || va(this._zoomButton, this._resetButton);
          this.toolTip._updateToolTip();
          this.renderCount++;
          Ja && (s = this, setTimeout(function() {
            var a2 = document.getElementById("ghostCanvasCopy");
            a2 && (Oa(a2, s.width, s.height), a2.getContext("2d").drawImage(s._eventManager.ghostCanvas, 0, 0));
          }, 2e3));
          this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);
          for (m = 0; m < this._axes.length; m++)
            this._axes[m].maskCanvas && (delete this._axes[m].maskCanvas, delete this._axes[m].maskCtx);
        };
        p.prototype.render = function(a) {
          a && (this.options = a);
          this._initialize();
          this.setLayout();
          this.renderElements();
          this._preRenderCanvas = null;
        };
        p.prototype.attachPlotAreaEventHandlers = function() {
          this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown, mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ? "move" : "default", capture: true, bounds: this.plotArea });
        };
        p.prototype.categoriseDataSeries = function() {
          for (var a = "", d = 0; d < this.data.length; d++)
            if (a = this.data[d], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= p._supportedChartTypes.indexOf(a.type)) {
              for (var b = null, c = false, e = null, g = false, k = 0; k < this.plotInfo.plotTypes.length; k++)
                if (this.plotInfo.plotTypes[k].type === a.type) {
                  c = true;
                  b = this.plotInfo.plotTypes[k];
                  break;
                }
              c || (b = { type: a.type, totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(b));
              for (k = 0; k < b.plotUnits.length; k++)
                if (b.plotUnits[k].axisYType === a.axisYType && b.plotUnits[k].axisXType === a.axisXType && b.plotUnits[k].axisYIndex === a.axisYIndex && b.plotUnits[k].axisXIndex === a.axisXIndex) {
                  g = true;
                  e = b.plotUnits[k];
                  break;
                }
              g || (e = { type: a.type, previousDataSeriesCount: 0, index: b.plotUnits.length, plotType: b, axisXType: a.axisXType, axisYType: a.axisYType, axisYIndex: a.axisYIndex, axisXIndex: a.axisXIndex, axisY: "primary" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0], axisX: "primary" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0], dataSeriesIndexes: [], yTotals: [] }, b.plotUnits.push(e));
              b.totalDataSeries++;
              e.dataSeriesIndexes.push(d);
              a.plotUnit = e;
            }
          for (d = 0; d < this.plotInfo.plotTypes.length; d++)
            for (b = this.plotInfo.plotTypes[d], k = a = 0; k < b.plotUnits.length; k++)
              b.plotUnits[k].previousDataSeriesCount = a, a += b.plotUnits[k].dataSeriesIndexes.length;
        };
        p.prototype.assignIdToDataPoints = function() {
          for (var a = 0; a < this.data.length; a++) {
            var d = this.data[a];
            if (d.dataPoints)
              for (var b = d.dataPoints.length, c = 0; c < b; c++)
                d.dataPointIds[c] = ++this._eventManager.lastObjectId;
          }
        };
        p.prototype._processData = function() {
          this.assignIdToDataPoints();
          this.categoriseDataSeries();
          for (var a = 0; a < this.plotInfo.plotTypes.length; a++)
            for (var d = this.plotInfo.plotTypes[a], b = 0; b < d.plotUnits.length; b++) {
              var c = d.plotUnits[b];
              "line" === c.type || "stepLine" === c.type || "spline" === c.type || "column" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "bar" === c.type || "bubble" === c.type || "scatter" === c.type ? this._processMultiseriesPlotUnit(c) : "stackedColumn" === c.type || "stackedBar" === c.type || "stackedArea" === c.type ? this._processStackedPlotUnit(c) : "stackedColumn100" === c.type || "stackedBar100" === c.type || "stackedArea100" === c.type ? this._processStacked100PlotUnit(c) : "candlestick" === c.type || "ohlc" === c.type || "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "error" === c.type || "boxAndWhisker" === c.type ? this._processMultiYPlotUnit(c) : "waterfall" === c.type && this._processSpecificPlotUnit(c);
            }
          this.calculateAutoBreaks();
        };
        p.prototype._processMultiseriesPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = false, k = 0; k < a.dataSeriesIndexes.length; k++) {
              var l = this.data[a.dataSeriesIndexes[k]], w = 0, m = false, s = false, q;
              if ("normal" === l.axisPlacement || "xySwapped" === l.axisPlacement)
                var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, f = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
              if (l.dataPoints[w].x && l.dataPoints[w].x.getTime || "dateTime" === l.xValueType)
                g = true;
              for (w = 0; w < l.dataPoints.length; w++) {
                "undefined" === typeof l.dataPoints[w].x && (l.dataPoints[w].x = w + (a.axisX.logarithmic ? 1 : 0));
                l.dataPoints[w].x.getTime ? (g = true, c = l.dataPoints[w].x.getTime()) : c = l.dataPoints[w].x;
                e = l.dataPoints[w].y;
                c < b.min && (b.min = c);
                c > b.max && (b.max = c);
                e < d.min && "number" === typeof e && (d.min = e);
                e > d.max && "number" === typeof e && (d.max = e);
                if (0 < w) {
                  if (a.axisX.logarithmic) {
                    var B = c / l.dataPoints[w - 1].x;
                    1 > B && (B = 1 / B);
                    b.minDiff > B && 1 !== B && (b.minDiff = B);
                  } else
                    B = c - l.dataPoints[w - 1].x, 0 > B && (B *= -1), b.minDiff > B && 0 !== B && (b.minDiff = B);
                  null !== e && null !== l.dataPoints[w - 1].y && (a.axisY.logarithmic ? (B = e / l.dataPoints[w - 1].y, 1 > B && (B = 1 / B), d.minDiff > B && 1 !== B && (d.minDiff = B)) : (B = e - l.dataPoints[w - 1].y, 0 > B && (B *= -1), d.minDiff > B && 0 !== B && (d.minDiff = B)));
                }
                if (c < n && !m)
                  null !== e && (q = c);
                else {
                  if (!m && (m = true, 0 < w)) {
                    w -= 2;
                    continue;
                  }
                  if (c > f && !s)
                    s = true;
                  else if (c > f && s)
                    continue;
                  l.dataPoints[w].label && (a.axisX.labels[c] = l.dataPoints[w].label);
                  c < b.viewPortMin && (b.viewPortMin = c);
                  c > b.viewPortMax && (b.viewPortMax = c);
                  null === e ? b.viewPortMin === c && q < c && (b.viewPortMin = q) : (e < d.viewPortMin && "number" === typeof e && (d.viewPortMin = e), e > d.viewPortMax && "number" === typeof e && (d.viewPortMax = e));
                }
              }
              l.axisX.valueType = l.xValueType = g ? "dateTime" : "number";
            }
        };
        p.prototype._processStackedPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = false, k = [], l = [], w = Infinity, m = -Infinity, s = 0; s < a.dataSeriesIndexes.length; s++) {
              var q = this.data[a.dataSeriesIndexes[s]], n = 0, f = false, B = false, h2;
              if ("normal" === q.axisPlacement || "xySwapped" === q.axisPlacement)
                var p2 = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
              if (q.dataPoints[n].x && q.dataPoints[n].x.getTime || "dateTime" === q.xValueType)
                g = true;
              for (n = 0; n < q.dataPoints.length; n++) {
                "undefined" === typeof q.dataPoints[n].x && (q.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0));
                q.dataPoints[n].x.getTime ? (g = true, c = q.dataPoints[n].x.getTime()) : c = q.dataPoints[n].x;
                e = u(q.dataPoints[n].y) ? 0 : q.dataPoints[n].y;
                c < b.min && (b.min = c);
                c > b.max && (b.max = c);
                if (0 < n) {
                  if (a.axisX.logarithmic) {
                    var r2 = c / q.dataPoints[n - 1].x;
                    1 > r2 && (r2 = 1 / r2);
                    b.minDiff > r2 && 1 !== r2 && (b.minDiff = r2);
                  } else
                    r2 = c - q.dataPoints[n - 1].x, 0 > r2 && (r2 *= -1), b.minDiff > r2 && 0 !== r2 && (b.minDiff = r2);
                  null !== e && null !== q.dataPoints[n - 1].y && (a.axisY.logarithmic ? 0 < e && (r2 = e / q.dataPoints[n - 1].y, 1 > r2 && (r2 = 1 / r2), d.minDiff > r2 && 1 !== r2 && (d.minDiff = r2)) : (r2 = e - q.dataPoints[n - 1].y, 0 > r2 && (r2 *= -1), d.minDiff > r2 && 0 !== r2 && (d.minDiff = r2)));
                }
                if (c < p2 && !f)
                  null !== q.dataPoints[n].y && (h2 = c);
                else {
                  if (!f && (f = true, 0 < n)) {
                    n -= 2;
                    continue;
                  }
                  if (c > t && !B)
                    B = true;
                  else if (c > t && B)
                    continue;
                  q.dataPoints[n].label && (a.axisX.labels[c] = q.dataPoints[n].label);
                  c < b.viewPortMin && (b.viewPortMin = c);
                  c > b.viewPortMax && (b.viewPortMax = c);
                  null === q.dataPoints[n].y ? b.viewPortMin === c && h2 < c && (b.viewPortMin = h2) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? k[c] ? k[c] += e : (k[c] = e, w = Math.min(e, w)) : l[c] ? l[c] += e : (l[c] = e, m = Math.max(e, m)));
                }
              }
              a.axisY.scaleBreaks && (a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (d.dataPointYPositiveSums ? (d.dataPointYPositiveSums.push.apply(d.dataPointYPositiveSums, k), d.dataPointYNegativeSums.push.apply(d.dataPointYPositiveSums, l)) : (d.dataPointYPositiveSums = k, d.dataPointYNegativeSums = l));
              q.axisX.valueType = q.xValueType = g ? "dateTime" : "number";
            }
            for (n in k)
              k.hasOwnProperty(n) && !isNaN(n) && (a = k[n], a < d.min && (d.min = Math.min(a, w)), a > d.max && (d.max = a), n < b.viewPortMin || n > b.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = Math.min(a, w)), a > d.viewPortMax && (d.viewPortMax = a)));
            for (n in l)
              l.hasOwnProperty(n) && !isNaN(n) && (a = l[n], a < d.min && (d.min = a), a > d.max && (d.max = Math.max(a, m)), n < b.viewPortMin || n > b.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = a), a > d.viewPortMax && (d.viewPortMax = Math.max(a, m))));
          }
        };
        p.prototype._processStacked100PlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = false, k = false, l = false, w = [], m = 0; m < a.dataSeriesIndexes.length; m++) {
              var s = this.data[a.dataSeriesIndexes[m]], q = 0, n = false, f = false, B;
              if ("normal" === s.axisPlacement || "xySwapped" === s.axisPlacement)
                var h2 = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, r2 = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
              if (s.dataPoints[q].x && s.dataPoints[q].x.getTime || "dateTime" === s.xValueType)
                g = true;
              for (q = 0; q < s.dataPoints.length; q++) {
                "undefined" === typeof s.dataPoints[q].x && (s.dataPoints[q].x = q + (a.axisX.logarithmic ? 1 : 0));
                s.dataPoints[q].x.getTime ? (g = true, c = s.dataPoints[q].x.getTime()) : c = s.dataPoints[q].x;
                e = u(s.dataPoints[q].y) ? null : s.dataPoints[q].y;
                c < b.min && (b.min = c);
                c > b.max && (b.max = c);
                if (0 < q) {
                  if (a.axisX.logarithmic) {
                    var t = c / s.dataPoints[q - 1].x;
                    1 > t && (t = 1 / t);
                    b.minDiff > t && 1 !== t && (b.minDiff = t);
                  } else
                    t = c - s.dataPoints[q - 1].x, 0 > t && (t *= -1), b.minDiff > t && 0 !== t && (b.minDiff = t);
                  u(e) || null === s.dataPoints[q - 1].y || (a.axisY.logarithmic ? 0 < e && (t = e / s.dataPoints[q - 1].y, 1 > t && (t = 1 / t), d.minDiff > t && 1 !== t && (d.minDiff = t)) : (t = e - s.dataPoints[q - 1].y, 0 > t && (t *= -1), d.minDiff > t && 0 !== t && (d.minDiff = t)));
                }
                if (c < h2 && !n)
                  null !== e && (B = c);
                else {
                  if (!n && (n = true, 0 < q)) {
                    q -= 2;
                    continue;
                  }
                  if (c > r2 && !f)
                    f = true;
                  else if (c > r2 && f)
                    continue;
                  s.dataPoints[q].label && (a.axisX.labels[c] = s.dataPoints[q].label);
                  c < b.viewPortMin && (b.viewPortMin = c);
                  c > b.viewPortMax && (b.viewPortMax = c);
                  null === e ? b.viewPortMin === c && B < c && (b.viewPortMin = B) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? k = true : 0 > e && (l = true), w[c] = w[c] ? w[c] + Math.abs(e) : Math.abs(e));
                }
              }
              s.axisX.valueType = s.xValueType = g ? "dateTime" : "number";
            }
            a.axisY.logarithmic ? (d.max = u(d.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(d.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), d.min = u(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : k && !l ? (d.max = u(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = u(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : k && l ? (d.max = u(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = u(d.viewPortMin) ? -99 : Math.min(
              d.viewPortMin,
              -99
            )) : !k && l && (d.max = u(d.viewPortMax) ? -1 : Math.max(d.viewPortMax, -1), d.min = u(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99));
            d.viewPortMin = d.min;
            d.viewPortMax = d.max;
            a.dataPointYSums = w;
          }
        };
        p.prototype._processMultiYPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g, k, l = false, w = 0; w < a.dataSeriesIndexes.length; w++) {
              var m = this.data[a.dataSeriesIndexes[w]], s = 0, q = false, n = false, f, B, h2;
              if ("normal" === m.axisPlacement || "xySwapped" === m.axisPlacement)
                var r2 = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
              if (m.dataPoints[s].x && m.dataPoints[s].x.getTime || "dateTime" === m.xValueType)
                l = true;
              for (s = 0; s < m.dataPoints.length; s++) {
                "undefined" === typeof m.dataPoints[s].x && (m.dataPoints[s].x = s + (a.axisX.logarithmic ? 1 : 0));
                m.dataPoints[s].x.getTime ? (l = true, c = m.dataPoints[s].x.getTime()) : c = m.dataPoints[s].x;
                if ((e = m.dataPoints[s].y) && e.length) {
                  g = Math.min.apply(null, e);
                  k = Math.max.apply(null, e);
                  B = true;
                  for (var p2 = 0; p2 < e.length; p2++)
                    null === e.k && (B = false);
                  B && (q || (h2 = f), f = c);
                }
                c < b.min && (b.min = c);
                c > b.max && (b.max = c);
                g < d.min && (d.min = g);
                k > d.max && (d.max = k);
                0 < s && (a.axisX.logarithmic ? (B = c / m.dataPoints[s - 1].x, 1 > B && (B = 1 / B), b.minDiff > B && 1 !== B && (b.minDiff = B)) : (B = c - m.dataPoints[s - 1].x, 0 > B && (B *= -1), b.minDiff > B && 0 !== B && (b.minDiff = B)), e && (null !== e[0] && m.dataPoints[s - 1].y && null !== m.dataPoints[s - 1].y[0]) && (a.axisY.logarithmic ? (B = e[0] / m.dataPoints[s - 1].y[0], 1 > B && (B = 1 / B), d.minDiff > B && 1 !== B && (d.minDiff = B)) : (B = e[0] - m.dataPoints[s - 1].y[0], 0 > B && (B *= -1), d.minDiff > B && 0 !== B && (d.minDiff = B))));
                if (!(c < r2) || q) {
                  if (!q && (q = true, 0 < s)) {
                    s -= 2;
                    f = h2;
                    continue;
                  }
                  if (c > t && !n)
                    n = true;
                  else if (c > t && n)
                    continue;
                  m.dataPoints[s].label && (a.axisX.labels[c] = m.dataPoints[s].label);
                  c < b.viewPortMin && (b.viewPortMin = c);
                  c > b.viewPortMax && (b.viewPortMax = c);
                  if (b.viewPortMin === c && e) {
                    for (p2 = 0; p2 < e.length; p2++)
                      if (null === e[p2] && f < c) {
                        b.viewPortMin = f;
                        break;
                      }
                  }
                  null === e ? b.viewPortMin === c && f < c && (b.viewPortMin = f) : (g < d.viewPortMin && (d.viewPortMin = g), k > d.viewPortMax && (d.viewPortMax = k));
                }
              }
              m.axisX.valueType = m.xValueType = l ? "dateTime" : "number";
            }
        };
        p.prototype._processSpecificPlotUnit = function(a) {
          if ("waterfall" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = false, k = 0; k < a.dataSeriesIndexes.length; k++) {
              var l = this.data[a.dataSeriesIndexes[k]], w = 0, m = false, s = false, q = c = 0;
              if ("normal" === l.axisPlacement || "xySwapped" === l.axisPlacement)
                var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, f = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
              if (l.dataPoints[w].x && l.dataPoints[w].x.getTime || "dateTime" === l.xValueType)
                g = true;
              for (w = 0; w < l.dataPoints.length; w++)
                "undefined" !== typeof l.dataPoints[w].isCumulativeSum && true === l.dataPoints[w].isCumulativeSum ? (l.dataPointEOs[w].cumulativeSumYStartValue = 0, l.dataPointEOs[w].cumulativeSum = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, l.dataPoints[w].y = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum) : "undefined" !== typeof l.dataPoints[w].isIntermediateSum && true === l.dataPoints[w].isIntermediateSum ? (l.dataPointEOs[w].cumulativeSumYStartValue = q, l.dataPointEOs[w].cumulativeSum = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, l.dataPoints[w].y = 0 === w ? 0 : c, q = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, c = 0) : (e = "number" !== typeof l.dataPoints[w].y ? 0 : l.dataPoints[w].y, l.dataPointEOs[w].cumulativeSumYStartValue = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, l.dataPointEOs[w].cumulativeSum = 0 === w ? e : l.dataPointEOs[w - 1].cumulativeSum + e, c += e);
              for (w = 0; w < l.dataPoints.length; w++)
                if ("undefined" === typeof l.dataPoints[w].x && (l.dataPoints[w].x = w + (a.axisX.logarithmic ? 1 : 0)), l.dataPoints[w].x.getTime ? (g = true, c = l.dataPoints[w].x.getTime()) : c = l.dataPoints[w].x, e = l.dataPoints[w].y, c < b.min && (b.min = c), c > b.max && (b.max = c), l.dataPointEOs[w].cumulativeSum < d.min && (d.min = l.dataPointEOs[w].cumulativeSum), l.dataPointEOs[w].cumulativeSum > d.max && (d.max = l.dataPointEOs[w].cumulativeSum), 0 < w && (a.axisX.logarithmic ? (q = c / l.dataPoints[w - 1].x, 1 > q && (q = 1 / q), b.minDiff > q && 1 !== q && (b.minDiff = q)) : (q = c - l.dataPoints[w - 1].x, 0 > q && (q *= -1), b.minDiff > q && 0 !== q && (b.minDiff = q)), null !== e && null !== l.dataPoints[w - 1].y && (a.axisY.logarithmic ? (e = l.dataPointEOs[w].cumulativeSum / l.dataPointEOs[w - 1].cumulativeSum, 1 > e && (e = 1 / e), d.minDiff > e && 1 !== e && (d.minDiff = e)) : (e = l.dataPointEOs[w].cumulativeSum - l.dataPointEOs[w - 1].cumulativeSum, 0 > e && (e *= -1), d.minDiff > e && 0 !== e && (d.minDiff = e)))), !(c < n) || m) {
                  if (!m && (m = true, 0 < w)) {
                    w -= 2;
                    continue;
                  }
                  if (c > f && !s)
                    s = true;
                  else if (c > f && s)
                    continue;
                  l.dataPoints[w].label && (a.axisX.labels[c] = l.dataPoints[w].label);
                  c < b.viewPortMin && (b.viewPortMin = c);
                  c > b.viewPortMax && (b.viewPortMax = c);
                  0 < w && (l.dataPointEOs[w - 1].cumulativeSum < d.viewPortMin && (d.viewPortMin = l.dataPointEOs[w - 1].cumulativeSum), l.dataPointEOs[w - 1].cumulativeSum > d.viewPortMax && (d.viewPortMax = l.dataPointEOs[w - 1].cumulativeSum));
                  l.dataPointEOs[w].cumulativeSum < d.viewPortMin && (d.viewPortMin = l.dataPointEOs[w].cumulativeSum);
                  l.dataPointEOs[w].cumulativeSum > d.viewPortMax && (d.viewPortMax = l.dataPointEOs[w].cumulativeSum);
                }
              l.axisX.valueType = l.xValueType = g ? "dateTime" : "number";
            }
        };
        p.prototype.calculateAutoBreaks = function() {
          function a(a2, c2, b2, e2) {
            if (e2)
              return b2 = Math.pow(Math.min(b2 * a2 / c2, c2 / a2), 0.2), 1 >= b2 && (b2 = Math.pow(1 > a2 ? 1 / a2 : Math.min(c2 / a2, a2), 0.25)), { startValue: a2 * b2, endValue: c2 / b2 };
            b2 = 0.2 * Math.min(b2 - c2 + a2, c2 - a2);
            0 >= b2 && (b2 = 0.25 * Math.min(c2 - a2, Math.abs(a2)));
            return { startValue: a2 + b2, endValue: c2 - b2 };
          }
          function d(a2) {
            if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length)) {
              var c2 = a2.axisX.scaleBreaks && a2.axisX.scaleBreaks.autoCalculate && 1 <= a2.axisX.scaleBreaks.maxNumberOfAutoBreaks, b2 = a2.axisY.scaleBreaks && a2.axisY.scaleBreaks.autoCalculate && 1 <= a2.axisY.scaleBreaks.maxNumberOfAutoBreaks;
              if (c2 || b2)
                for (var d2 = a2.axisY.dataInfo, f2 = a2.axisX.dataInfo, g2, m2 = f2.min, l2 = f2.max, k2 = d2.min, n2 = d2.max, f2 = f2._dataRanges, d2 = d2._dataRanges, q2, w2 = 0, s2 = 0; s2 < a2.dataSeriesIndexes.length; s2++) {
                  var h2 = e.data[a2.dataSeriesIndexes[s2]];
                  if (!(4 > h2.dataPoints.length)) {
                    for (w2 = 0; w2 < h2.dataPoints.length; w2++)
                      if (c2 && (q2 = (l2 + 1 - m2) * Math.max(parseFloat(a2.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, g2 = h2.dataPoints[w2].x.getTime ? h2.dataPoints[w2].x.getTime() : h2.dataPoints[w2].x, q2 = Math.floor((g2 - m2) / q2), g2 < f2[q2].min && (f2[q2].min = g2), g2 > f2[q2].max && (f2[q2].max = g2)), b2) {
                        var r2 = (n2 + 1 - k2) * Math.max(parseFloat(a2.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                        if ((g2 = "waterfall" === a2.type ? h2.dataPointEOs[w2].cumulativeSum : h2.dataPoints[w2].y) && g2.length)
                          for (var p2 = 0; p2 < g2.length; p2++)
                            q2 = Math.floor((g2[p2] - k2) / r2), g2[p2] < d2[q2].min && (d2[q2].min = g2[p2]), g2[p2] > d2[q2].max && (d2[q2].max = g2[p2]);
                        else
                          u(g2) || (q2 = Math.floor((g2 - k2) / r2), g2 < d2[q2].min && (d2[q2].min = g2), g2 > d2[q2].max && (d2[q2].max = g2));
                      }
                  }
                }
            }
          }
          function b(a2) {
            if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length) && a2.axisX.scaleBreaks && a2.axisX.scaleBreaks.autoCalculate && 1 <= a2.axisX.scaleBreaks.maxNumberOfAutoBreaks)
              for (var c2 = a2.axisX.dataInfo, b2 = c2.min, d2 = c2.max, f2 = c2._dataRanges, g2, m2 = 0, l2 = 0; l2 < a2.dataSeriesIndexes.length; l2++) {
                var k2 = e.data[a2.dataSeriesIndexes[l2]];
                if (!(4 > k2.dataPoints.length))
                  for (m2 = 0; m2 < k2.dataPoints.length; m2++)
                    g2 = (d2 + 1 - b2) * Math.max(parseFloat(a2.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, c2 = k2.dataPoints[m2].x.getTime ? k2.dataPoints[m2].x.getTime() : k2.dataPoints[m2].x, g2 = Math.floor((c2 - b2) / g2), c2 < f2[g2].min && (f2[g2].min = c2), c2 > f2[g2].max && (f2[g2].max = c2);
              }
          }
          for (var c, e = this, g = false, k = 0; k < this._axes.length; k++)
            if (this._axes[k].scaleBreaks && this._axes[k].scaleBreaks.autoCalculate && 1 <= this._axes[k].scaleBreaks.maxNumberOfAutoBreaks) {
              g = true;
              this._axes[k].dataInfo._dataRanges = [];
              for (var l = 0; l < 100 / Math.max(parseFloat(this._axes[k].scaleBreaks.collapsibleThreshold) || 10, 10); l++)
                this._axes[k].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity });
            }
          if (g) {
            for (k = 0; k < this.plotInfo.plotTypes.length; k++)
              for (g = this.plotInfo.plotTypes[k], l = 0; l < g.plotUnits.length; l++)
                c = g.plotUnits[l], "line" === c.type || "stepLine" === c.type || "spline" === c.type || "column" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "bar" === c.type || "bubble" === c.type || "scatter" === c.type || "candlestick" === c.type || "ohlc" === c.type || "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "waterfall" === c.type || "error" === c.type || "boxAndWhisker" === c.type ? d(c) : 0 <= c.type.indexOf("stacked") && b(c);
            for (k = 0; k < this._axes.length; k++)
              if (this._axes[k].dataInfo._dataRanges) {
                var w = this._axes[k].dataInfo.min;
                c = (this._axes[k].dataInfo.max + 1 - w) * Math.max(parseFloat(this._axes[k].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                var m = this._axes[k].dataInfo._dataRanges, s, q, g = [];
                if (this._axes[k].dataInfo.dataPointYPositiveSums) {
                  var n = this._axes[k].dataInfo.dataPointYPositiveSums;
                  s = m;
                  for (l in n)
                    if (n.hasOwnProperty(l) && !isNaN(l) && (q = n[l], !u(q))) {
                      var f = Math.floor((q - w) / c);
                      q < s[f].min && (s[f].min = q);
                      q > s[f].max && (s[f].max = q);
                    }
                  delete this._axes[k].dataInfo.dataPointYPositiveSums;
                }
                if (this._axes[k].dataInfo.dataPointYNegativeSums) {
                  n = this._axes[k].dataInfo.dataPointYNegativeSums;
                  s = m;
                  for (l in n)
                    n.hasOwnProperty(l) && !isNaN(l) && (q = -1 * n[l], u(q) || (f = Math.floor((q - w) / c), q < s[f].min && (s[f].min = q), q > s[f].max && (s[f].max = q)));
                  delete this._axes[k].dataInfo.dataPointYNegativeSums;
                }
                for (l = 0; l < m.length - 1; l++)
                  if (s = m[l].max, isFinite(s))
                    for (; l < m.length - 1; )
                      if (w = m[l + 1].min, isFinite(w)) {
                        q = w - s;
                        q > c && g.push({ diff: q, start: s, end: w });
                        break;
                      } else
                        l++;
                if (this._axes[k].scaleBreaks.customBreaks) {
                  for (l = 0; l < this._axes[k].scaleBreaks.customBreaks.length; l++)
                    for (c = 0; c < g.length; c++)
                      if (this._axes[k].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].endValue || this._axes[k].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].endValue || g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].startValue && this._axes[k].scaleBreaks.customBreaks[l].startValue <= g[c].end || g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].endValue && this._axes[k].scaleBreaks.customBreaks[l].endValue <= g[c].end)
                        g.splice(c, 1), c--;
                }
                g.sort(function(a2, c2) {
                  return c2.diff - a2.diff;
                });
                for (l = 0; l < Math.min(g.length, this._axes[k].scaleBreaks.maxNumberOfAutoBreaks); l++)
                  c = a(g[l].start, g[l].end, this._axes[k].logarithmic ? this._axes[k].dataInfo.max / this._axes[k].dataInfo.min : this._axes[k].dataInfo.max - this._axes[k].dataInfo.min, this._axes[k].logarithmic), this._axes[k].scaleBreaks.autoBreaks.push(new L(this, "autoBreaks", c, l, ++this._eventManager.lastObjectId, this._axes[k].scaleBreaks)), this._axes[k].scaleBreaks._appliedBreaks.push(this._axes[k].scaleBreaks.autoBreaks[this._axes[k].scaleBreaks.autoBreaks.length - 1]);
                this._axes[k].scaleBreaks._appliedBreaks.sort(function(a2, c2) {
                  return a2.startValue - c2.startValue;
                });
              }
          }
        };
        p.prototype.getDataPointAtXY = function(a, d, b) {
          b = b || false;
          for (var c = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {
            var g = null;
            (g = this._dataInRenderedOrder[e].getDataPointAtXY(a, d, b)) && c.push(g);
          }
          a = null;
          d = false;
          for (b = 0; b < c.length; b++)
            if ("line" === c[b].dataSeries.type || "stepLine" === c[b].dataSeries.type || "area" === c[b].dataSeries.type || "stepArea" === c[b].dataSeries.type) {
              if (e = na("markerSize", c[b].dataPoint, c[b].dataSeries) || 8, c[b].distance <= e / 2) {
                d = true;
                break;
              }
            }
          for (b = 0; b < c.length; b++)
            d && "line" !== c[b].dataSeries.type && "stepLine" !== c[b].dataSeries.type && "area" !== c[b].dataSeries.type && "stepArea" !== c[b].dataSeries.type || (a ? c[b].distance <= a.distance && (a = c[b]) : a = c[b]);
          return a;
        };
        p.prototype.getObjectAtXY = function(a, d, b) {
          var c = null;
          if (b = this.getDataPointAtXY(a, d, b || false))
            c = b.dataSeries.dataPointIds[b.dataPointIndex];
          else if (r)
            c = ab(a, d, this._eventManager.ghostCtx);
          else
            for (b = 0; b < this.legend.items.length; b++) {
              var e = this.legend.items[b];
              a >= e.x1 && (a <= e.x2 && d >= e.y1 && d <= e.y2) && (c = e.id);
            }
          return c;
        };
        p.prototype.getAutoFontSize = lb;
        p.prototype.resetOverlayedCanvas = function() {
          this.overlaidCanvasCtx.clearRect(
            0,
            0,
            this.width,
            this.height
          );
        };
        p.prototype.clearCanvas = kb;
        p.prototype.attachEvent = function(a) {
          this._events.push(a);
        };
        p.prototype._touchEventHandler = function(a) {
          if (a.changedTouches && this.interactivityEnabled) {
            var d = [], b = a.changedTouches, c = b ? b[0] : a, e = null;
            switch (a.type) {
              case "touchstart":
              case "MSPointerDown":
                d = ["mousemove", "mousedown"];
                this._lastTouchData = Ra(c);
                this._lastTouchData.time = /* @__PURE__ */ new Date();
                break;
              case "touchmove":
              case "MSPointerMove":
                d = ["mousemove"];
                break;
              case "touchend":
              case "MSPointerUp":
                var g = this._lastTouchData && this._lastTouchData.time ? /* @__PURE__ */ new Date() - this._lastTouchData.time : 0, d = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > g ? ["mouseup", "click"] : ["mouseup"];
                break;
              default:
                return;
            }
            if (!(b && 1 < b.length)) {
              e = Ra(c);
              e.time = /* @__PURE__ */ new Date();
              try {
                var k = e.y - this._lastTouchData.y, g = e.time - this._lastTouchData.time;
                if (1 < Math.abs(k) && this._lastTouchData.scroll || 5 < Math.abs(k) && 250 > g)
                  this._lastTouchData.scroll = true;
              } catch (l) {
              }
              this._lastTouchEventType = a.type;
              if (this._lastTouchData.scroll && this.zoomEnabled)
                this.isDrag && this.resetOverlayedCanvas(), this.isDrag = false;
              else
                for (b = 0; b < d.length; b++)
                  if (e = d[b], k = document.createEvent("MouseEvent"), k.initMouseEvent(e, true, true, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, false, false, false, false, 0, null), c.target.dispatchEvent(k), !u(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < g || "click" === e)
                    a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault();
            }
          }
        };
        p.prototype._dispatchRangeEvent = function(a, d) {
          var b = { chart: this };
          b.type = a;
          b.trigger = d;
          var c = [];
          this.axisX && 0 < this.axisX.length && c.push("axisX");
          this.axisX2 && 0 < this.axisX2.length && c.push("axisX2");
          this.axisY && 0 < this.axisY.length && c.push("axisY");
          this.axisY2 && 0 < this.axisY2.length && c.push("axisY2");
          for (var e = 0; e < c.length; e++)
            if (u(b[c[e]]) && (b[c[e]] = []), "axisY" === c[e])
              for (var g = 0; g < this.axisY.length; g++)
                b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });
            else if ("axisY2" === c[e])
              for (g = 0; g < this.axisY2.length; g++)
                b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });
            else if ("axisX" === c[e])
              for (g = 0; g < this.axisX.length; g++)
                b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });
            else if ("axisX2" === c[e])
              for (g = 0; g < this.axisX2.length; g++)
                b[c[e]].push({
                  viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,
                  viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum
                });
          this.dispatchEvent(a, b, this);
        };
        p.prototype._mouseEventHandler = function(a) {
          "undefined" === typeof a.target && a.srcElement && (a.target = a.srcElement);
          var d = Ra(a), b = a.type, c, e;
          a.which ? e = 3 == a.which : a.button && (e = 2 == a.button);
          p.capturedEventParam && (c = p.capturedEventParam, "mouseup" === b && (p.capturedEventParam = null, c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(
            "mouseup",
            c.chart._mouseEventHandler,
            false
          )), c.hasOwnProperty(b) && ("mouseup" !== b || c.chart.overlaidCanvas.releaseCapture ? a.target !== c.chart.overlaidCanvas && r || c[b].call(c.context, d.x, d.y) : a.target !== c.chart.overlaidCanvas && (c.chart.isDrag = false)));
          if (this.interactivityEnabled) {
            if (this._ignoreNextEvent)
              this._ignoreNextEvent = false;
            else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), Ja && window.console && (window.console.log(b + " --> x: " + d.x + "; y:" + d.y), e && window.console.log(a.which), "mouseup" === b && window.console.log("mouseup")), !e) {
              if (!p.capturedEventParam && this._events) {
                for (var g = 0; g < this._events.length; g++)
                  if (this._events[g].hasOwnProperty(b))
                    if (c = this._events[g], e = c.bounds, d.x >= e.x1 && d.x <= e.x2 && d.y >= e.y1 && d.y <= e.y2) {
                      c[b].call(c.context, d.x, d.y);
                      "mousedown" === b && true === c.capture ? (p.capturedEventParam = c, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, false)) : "mouseup" === b && (c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, false));
                      break;
                    } else
                      c = null;
                a.target.style.cursor = c && c.cursor ? c.cursor : this._defaultCursor;
              }
              b = this.plotArea;
              if (d.x < b.x1 || d.x > b.x2 || d.y < b.y1 || d.y > b.y2)
                this.toolTip && this.toolTip.enabled ? this.toolTip.hide() : this.resetOverlayedCanvas();
              this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);
            }
          }
        };
        p.prototype._plotAreaMouseDown = function(a, d) {
          this.isDrag = true;
          this.dragStartPoint = { x: a, y: d };
        };
        p.prototype._plotAreaMouseUp = function(a, d) {
          if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
            var b = d - this.dragStartPoint.y, c = a - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf("x"), g = 0 <= this.zoomType.indexOf("y"), k = false;
            this.resetOverlayedCanvas();
            if ("xySwapped" === this.plotInfo.axisPlacement)
              var l = g, g = e, e = l;
            if (this.panEnabled || this.zoomEnabled) {
              if (this.panEnabled)
                for (e = g = 0; e < this._axes.length; e++)
                  b = this._axes[e], b.logarithmic ? b.viewportMinimum < b.minimum ? (g = b.minimum / b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum * g, b.sessionVariables.newViewportMaximum = b.viewportMaximum * g, k = true) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum / b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum / g, b.sessionVariables.newViewportMaximum = b.viewportMaximum / g, k = true) : b.viewportMinimum < b.minimum ? (g = b.minimum - b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum + g, b.sessionVariables.newViewportMaximum = b.viewportMaximum + g, k = true) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum - b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum - g, b.sessionVariables.newViewportMaximum = b.viewportMaximum - g, k = true);
              else if ((!e || 2 < Math.abs(c)) && (!g || 2 < Math.abs(b)) && this.zoomEnabled) {
                if (!this.dragStartPoint)
                  return;
                b = e ? this.dragStartPoint.x : this.plotArea.x1;
                c = g ? this.dragStartPoint.y : this.plotArea.y1;
                e = e ? a : this.plotArea.x2;
                g = g ? d : this.plotArea.y2;
                2 < Math.abs(b - e) && 2 < Math.abs(c - g) && this._zoomPanToSelectedRegion(b, c, e, g) && (k = true);
              }
              k && (this._ignoreNextEvent = true, this._dispatchRangeEvent("rangeChanging", "zoom"), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), k && (this.zoomEnabled && "none" === this._zoomButton.style.display) && (Qa(this._zoomButton, this._resetButton), ua(this, this._zoomButton, "pan"), ua(this, this._resetButton, "reset")));
            }
          }
          this.isDrag = false;
          if ("none" !== this.plotInfo.axisPlacement) {
            this.resetOverlayedCanvas();
            if (this.axisX && 0 < this.axisX.length)
              for (k = 0; k < this.axisX.length; k++)
                this.axisX[k].crosshair && this.axisX[k].crosshair.enabled && this.axisX[k].renderCrosshair(a, d);
            if (this.axisX2 && 0 < this.axisX2.length)
              for (k = 0; k < this.axisX2.length; k++)
                this.axisX2[k].crosshair && this.axisX2[k].crosshair.enabled && this.axisX2[k].renderCrosshair(a, d);
            if (this.axisY && 0 < this.axisY.length)
              for (k = 0; k < this.axisY.length; k++)
                this.axisY[k].crosshair && this.axisY[k].crosshair.enabled && this.axisY[k].renderCrosshair(a, d);
            if (this.axisY2 && 0 < this.axisY2.length)
              for (k = 0; k < this.axisY2.length; k++)
                this.axisY2[k].crosshair && this.axisY2[k].crosshair.enabled && this.axisY2[k].renderCrosshair(
                  a,
                  d
                );
          }
        };
        p.prototype._plotAreaMouseMove = function(a, d) {
          if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
            var b = 0, c = 0, e = b = null, e = 0 <= this.zoomType.indexOf("x"), g = 0 <= this.zoomType.indexOf("y"), k = this;
            "xySwapped" === this.plotInfo.axisPlacement && (b = g, g = e, e = b);
            b = this.dragStartPoint.x - a;
            c = this.dragStartPoint.y - d;
            2 < Math.abs(b) && 8 > Math.abs(b) && (this.panEnabled || this.zoomEnabled) ? this.toolTip.hide() : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, d);
            if ((!e || 2 < Math.abs(b) || !g || 2 < Math.abs(c)) && (this.panEnabled || this.zoomEnabled)) {
              if (this.panEnabled)
                e = { x1: e ? this.plotArea.x1 + b : this.plotArea.x1, y1: g ? this.plotArea.y1 + c : this.plotArea.y1, x2: e ? this.plotArea.x2 + b : this.plotArea.x2, y2: g ? this.plotArea.y2 + c : this.plotArea.y2 }, clearTimeout(k._panTimerId), k._panTimerId = setTimeout(function(c2, b2, e2, f) {
                  return function() {
                    k._zoomPanToSelectedRegion(c2, b2, e2, f, true) && (k._dispatchRangeEvent("rangeChanging", "pan"), k.render(), k._dispatchRangeEvent("rangeChanged", "pan"), k.dragStartPoint.x = a, k.dragStartPoint.y = d);
                  };
                }(
                  e.x1,
                  e.y1,
                  e.x2,
                  e.y2
                ), 0);
              else if (this.zoomEnabled) {
                this.resetOverlayedCanvas();
                b = this.overlaidCanvasCtx.globalAlpha;
                this.overlaidCanvasCtx.fillStyle = "#A89896";
                var c = e ? this.dragStartPoint.x : this.plotArea.x1, l = g ? this.dragStartPoint.y : this.plotArea.y1, w = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, m = g ? d - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
                this.validateRegion(c, l, e ? a : this.plotArea.x2 - this.plotArea.x1, g ? d : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5");
                this.overlaidCanvasCtx.globalAlpha = 0.7;
                this.overlaidCanvasCtx.fillRect(c, l, w, m);
                this.overlaidCanvasCtx.globalAlpha = b;
              }
            }
          } else if (this.toolTip.mouseMoveHandler(a, d), "none" !== this.plotInfo.axisPlacement) {
            if (this.axisX && 0 < this.axisX.length)
              for (e = 0; e < this.axisX.length; e++)
                this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, d);
            if (this.axisX2 && 0 < this.axisX2.length)
              for (e = 0; e < this.axisX2.length; e++)
                this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a, d);
            if (this.axisY && 0 < this.axisY.length)
              for (e = 0; e < this.axisY.length; e++)
                this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, d);
            if (this.axisY2 && 0 < this.axisY2.length)
              for (e = 0; e < this.axisY2.length; e++)
                this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, d);
          }
        };
        p.prototype._zoomPanToSelectedRegion = function(a, d, b, c, e) {
          a = this.validateRegion(a, d, b, c, e);
          d = a.axesWithValidRange;
          b = a.axesRanges;
          if (a.isValid)
            for (c = 0; c < d.length; c++)
              e = b[c], d[c].setViewPortRange(e.val1, e.val2), this.syncCharts && this.syncCharts(e.val1, e.val2);
          return a.isValid;
        };
        p.prototype.validateRegion = function(a, d, b, c, e) {
          e = e || false;
          for (var g = 0 <= this.zoomType.indexOf("x"), k = 0 <= this.zoomType.indexOf("y"), l = false, w = [], m = [], s = [], q = 0; q < this._axes.length; q++)
            ("axisX" === this._axes[q].type && g || "axisY" === this._axes[q].type && k) && m.push(this._axes[q]);
          for (k = 0; k < m.length; k++) {
            var q = m[k], g = false, n = q.convertPixelToValue({ x: a, y: d }), f = q.convertPixelToValue({ x: b, y: c });
            if (n > f)
              var B = f, f = n, n = B;
            if (q.scaleBreaks)
              for (B = 0; !g && B < q.scaleBreaks._appliedBreaks.length; B++)
                g = q.scaleBreaks._appliedBreaks[B].startValue <= n && q.scaleBreaks._appliedBreaks[B].endValue >= f;
            if (isFinite(q.dataInfo.minDiff)) {
              if (B = q.getApparentDifference(n, f, null, true), !(g || !(this.panEnabled && q.scaleBreaks && q.scaleBreaks._appliedBreaks.length) && (q.logarithmic && B < Math.pow(q.dataInfo.minDiff, 3) || !q.logarithmic && B < 3 * Math.abs(q.dataInfo.minDiff)) || n < q.minimum || f > q.maximum))
                w.push(q), s.push({ val1: n, val2: f }), l = true;
              else if (!e) {
                l = false;
                break;
              }
            }
          }
          return { isValid: l, axesWithValidRange: w, axesRanges: s };
        };
        p.prototype.preparePlotArea = function() {
          var a = this.plotArea;
          !r && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);
          if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
            var d = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;
            if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
              var b = this.axisY[0];
              a.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1;
              a.y1 = d.y1 < b.lineCoordinates.y1 ? d.y1 : b.lineCoordinates.y1;
              a.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2;
              a.y2 = d.y2 > d.y1 ? d.y2 : b.lineCoordinates.y2;
              a.width = a.x2 - a.x1;
              a.height = a.y2 - a.y1;
            }
            this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (b = this.axisY2[0], a.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1, a.y1 = d.y1 < b.lineCoordinates.y1 ? d.y1 : b.lineCoordinates.y1, a.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2, a.y2 = d.y2 > d.y1 ? d.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);
          } else
            d = this.layoutManager.getFreeSpace(), a.x1 = d.x1, a.x2 = d.x2, a.y1 = d.y1, a.y2 = d.y2, a.width = d.width, a.height = d.height;
          r || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));
          a.layoutManager = new Ga(a.x1, a.y1, a.x2, a.y2, 2);
        };
        p.prototype.renderIndexLabels = function(a) {
          var d = a || this.plotArea.ctx, b = this.plotArea, c = 0, e = 0, g = 0, k = 0, l = c = k = e = g = 0, w = 0;
          for (a = 0; a < this._indexLabels.length; a++) {
            var m = this._indexLabels[a], s = m.chartType.toLowerCase(), q, n, l = na(
              "indexLabelFontColor",
              m.dataPoint,
              m.dataSeries
            ), w = na("indexLabelFontSize", m.dataPoint, m.dataSeries);
            q = na("indexLabelFontFamily", m.dataPoint, m.dataSeries);
            n = na("indexLabelFontStyle", m.dataPoint, m.dataSeries);
            var k = na("indexLabelFontWeight", m.dataPoint, m.dataSeries), f = na("indexLabelBackgroundColor", m.dataPoint, m.dataSeries), e = na("indexLabelMaxWidth", m.dataPoint, m.dataSeries), g = na("indexLabelWrap", m.dataPoint, m.dataSeries), B = na("indexLabelLineDashType", m.dataPoint, m.dataSeries), h2 = na("indexLabelLineColor", m.dataPoint, m.dataSeries), p2 = u(m.dataPoint.indexLabelLineThickness) ? u(m.dataSeries.options.indexLabelLineThickness) ? 0 : m.dataSeries.options.indexLabelLineThickness : m.dataPoint.indexLabelLineThickness, c = 0 < p2 ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, t = { percent: null, total: null }, C = null;
            if (0 <= m.dataSeries.type.indexOf("stacked") || "pie" === m.dataSeries.type || "doughnut" === m.dataSeries.type)
              t = this.getPercentAndTotal(m.dataSeries, m.dataPoint);
            if (m.dataSeries.indexLabelFormatter || m.dataPoint.indexLabelFormatter)
              C = { chart: this, dataSeries: m.dataSeries, dataPoint: m.dataPoint, index: m.indexKeyword, total: t.total, percent: t.percent };
            var x = m.dataPoint.indexLabelFormatter ? m.dataPoint.indexLabelFormatter(C) : m.dataPoint.indexLabel ? this.replaceKeywordsWithValue(m.dataPoint.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : m.dataSeries.indexLabelFormatter ? m.dataSeries.indexLabelFormatter(C) : m.dataSeries.indexLabel ? this.replaceKeywordsWithValue(
              m.dataSeries.indexLabel,
              m.dataPoint,
              m.dataSeries,
              null,
              m.indexKeyword
            ) : null;
            if (null !== x && "" !== x) {
              var t = na("indexLabelPlacement", m.dataPoint, m.dataSeries), C = na("indexLabelOrientation", m.dataPoint, m.dataSeries), ma = m.direction, y = m.dataSeries.axisX, A = m.dataSeries.axisY, v3 = false, f = new ka(d, { x: 0, y: 0, maxWidth: e ? e : 0.5 * this.width, maxHeight: g ? 5 * w : 1.5 * w, angle: "horizontal" === C ? 0 : -90, text: x, padding: 0, backgroundColor: f, horizontalAlign: "left", fontSize: w, fontFamily: q, fontWeight: k, fontColor: l, fontStyle: n, textBaseline: "top" });
              f.measureText();
              m.dataSeries.indexLabelMaxWidth = f.maxWidth;
              if ("stackedarea100" === s) {
                if (m.point.x < b.x1 || m.point.x > b.x2 || m.point.y < b.y1 - 1 || m.point.y > b.y2 + 1)
                  continue;
              } else if ("rangearea" === s || "rangesplinearea" === s) {
                if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > A.viewportMaximum)
                  continue;
              } else if (0 <= s.indexOf("line") || 0 <= s.indexOf("area") || 0 <= s.indexOf("bubble") || 0 <= s.indexOf("scatter")) {
                if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || m.dataPoint.y < A.viewportMinimum || m.dataPoint.y > A.viewportMaximum)
                  continue;
              } else if (0 <= s.indexOf("column") || "waterfall" === s || "error" === s && !m.axisSwapped) {
                if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || m.bounds.y1 > b.y2 || m.bounds.y2 < b.y1)
                  continue;
              } else if (0 <= s.indexOf("bar") || "error" === s) {
                if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || m.bounds.x1 > b.x2 || m.bounds.x2 < b.x1)
                  continue;
              } else if ("candlestick" === s || "ohlc" === s) {
                if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > A.viewportMaximum)
                  continue;
              } else if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum)
                continue;
              e = k = 2;
              "horizontal" === C ? (l = f.width, w = f.height) : (w = f.width, l = f.height);
              if ("normal" === this.plotInfo.axisPlacement) {
                if (0 <= s.indexOf("line") || 0 <= s.indexOf("area"))
                  t = "auto", k = 4;
                else if (0 <= s.indexOf("stacked"))
                  "auto" === t && (t = "inside");
                else if ("bubble" === s || "scatter" === s)
                  t = "inside";
                q = m.point.x - l / 2;
                "inside" !== t ? (e = b.y1, g = b.y2, 0 < ma ? (n = m.point.y - w - k - c, n < e && (n = "auto" === t ? Math.max(m.point.y, e) + k + c : e + k + c, v3 = n + w > m.point.y)) : (n = m.point.y + k + c, n > g - w - k - c && (n = "auto" === t ? Math.min(m.point.y, g) - w - k - c : g - w - k - c, v3 = n < m.point.y))) : (e = Math.max(m.bounds.y1, b.y1), g = Math.min(m.bounds.y2, b.y2), c = 0 <= s.indexOf("range") || "error" === s ? 0 < ma ? Math.max(m.bounds.y1, b.y1) + w / 2 + k : Math.min(m.bounds.y2, b.y2) - w / 2 - k : (Math.max(m.bounds.y1, b.y1) + Math.min(m.bounds.y2, b.y2)) / 2, 0 < ma ? (n = Math.max(m.point.y, c) - w / 2, n < e && ("bubble" === s || "scatter" === s) && (n = Math.max(m.point.y - w - k, b.y1 + k))) : (n = Math.min(m.point.y, c) - w / 2, n > g - w - k && ("bubble" === s || "scatter" === s) && (n = Math.min(m.point.y + k, b.y2 - w - k))), n = Math.min(n, g - w));
              } else
                0 <= s.indexOf("line") || 0 <= s.indexOf("area") || 0 <= s.indexOf("scatter") ? (t = "auto", e = 4) : 0 <= s.indexOf("stacked") ? "auto" === t && (t = "inside") : "bubble" === s && (t = "inside"), n = m.point.y - w / 2, "inside" !== t ? (k = b.x1, g = b.x2, 0 > ma ? (q = m.point.x - l - e - c, q < k && (q = "auto" === t ? Math.max(m.point.x, k) + e + c : k + e + c, v3 = q + l > m.point.x)) : (q = m.point.x + e + c, q > g - l - e - c && (q = "auto" === t ? Math.min(m.point.x, g) - l - e - c : g - l - e - c, v3 = q < m.point.x))) : (k = Math.max(m.bounds.x1, b.x1), Math.min(m.bounds.x2, b.x2), c = 0 <= s.indexOf("range") || "error" === s ? 0 > ma ? Math.max(m.bounds.x1, b.x1) + l / 2 + e : Math.min(m.bounds.x2, b.x2) - l / 2 - e : (Math.max(m.bounds.x1, b.x1) + Math.min(m.bounds.x2, b.x2)) / 2, q = 0 > ma ? Math.max(m.point.x, c) - l / 2 : Math.min(m.point.x, c) - l / 2, q = Math.max(q, k));
              "vertical" === C && (n += w);
              f.x = q;
              f.y = n;
              f.render(true);
              p2 && ("inside" !== t && (0 > s.indexOf("bar") && ("error" !== s || !m.axisSwapped) && m.point.x > b.x1 && m.point.x < b.x2 || !v3) && (0 > s.indexOf("column") && ("error" !== s || m.axisSwapped) && m.point.y > b.y1 && m.point.y < b.y2 || !v3)) && (d.lineWidth = p2, d.strokeStyle = h2 ? h2 : "gray", d.setLineDash && d.setLineDash(R(B, p2)), d.beginPath(), d.moveTo(m.point.x, m.point.y), 0 <= s.indexOf("bar") || "error" === s && m.axisSwapped ? d.lineTo(q + (0 < m.direction ? 0 : l), n + ("horizontal" === C ? w : -w) / 2) : 0 <= s.indexOf("column") || "error" === s && !m.axisSwapped ? d.lineTo(q + l / 2, n + ((0 < m.direction ? w : -w) + ("horizontal" === C ? w : -w)) / 2) : d.lineTo(q + l / 2, n + ((n < m.point.y ? w : -w) + ("horizontal" === C ? w : -w)) / 2), d.stroke());
            }
          }
          d = { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 };
          for (a = 0; a < this._indexLabels.length; a++)
            m = this._indexLabels[a], f = na("indexLabelBackgroundColor", m.dataPoint, m.dataSeries), m.dataSeries.indexLabelBackgroundColor = u(f) ? r ? "transparent" : null : f;
          return d;
        };
        p.prototype.renderLine = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = this._eventManager.ghostCtx;
            b.save();
            var e = this.plotArea;
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            for (var g = [], k, l = 0; l < a.dataSeriesIndexes.length; l++) {
              var w = a.dataSeriesIndexes[l], m = this.data[w];
              b.lineWidth = m.lineThickness;
              var s = m.dataPoints, q = "solid";
              if (b.setLineDash) {
                var n = R(m.nullDataLineDashType, m.lineThickness), q = m.lineDashType, f = R(q, m.lineThickness);
                b.setLineDash(f);
              }
              var B = m.id;
              this._eventManager.objectMap[B] = { objectType: "dataSeries", dataSeriesIndex: w };
              B = N(B);
              c.strokeStyle = B;
              c.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;
              var B = m._colorSet, h2 = B = m.lineColor = m.options.lineColor ? m.options.lineColor : B[0];
              b.strokeStyle = B;
              var p2 = true, t = 0, C, x;
              b.beginPath();
              if (0 < s.length) {
                for (var u2 = false, t = 0; t < s.length; t++)
                  if (C = s[t].x.getTime ? s[t].x.getTime() : s[t].x, !(C < a.axisX.dataInfo.viewPortMin || C > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !u2)))
                    if ("number" !== typeof s[t].y)
                      0 < t && !(m.connectNullData || u2 || p2) && (b.stroke(), r && c.stroke()), u2 = true;
                    else {
                      C = a.axisX.convertValueToPixel(C);
                      x = a.axisY.convertValueToPixel(s[t].y);
                      var y = m.dataPointIds[t];
                      this._eventManager.objectMap[y] = { id: y, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: t, x1: C, y1: x };
                      p2 || u2 ? (!p2 && m.connectNullData ? (b.setLineDash && (m.options.nullDataLineDashType || q === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(k.x, k.y), q = m.nullDataLineDashType, b.setLineDash(n)), b.lineTo(C, x), r && c.lineTo(C, x)) : (b.beginPath(), b.moveTo(C, x), r && (c.beginPath(), c.moveTo(C, x))), u2 = p2 = false) : (b.lineTo(
                        C,
                        x
                      ), r && c.lineTo(C, x), 0 == t % 500 && (b.stroke(), b.beginPath(), b.moveTo(C, x), r && (c.stroke(), c.beginPath(), c.moveTo(C, x))));
                      k = { x: C, y: x };
                      t < s.length - 1 && (h2 !== (s[t].lineColor || B) || q !== (s[t].lineDashType || m.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(C, x), h2 = s[t].lineColor || B, b.strokeStyle = h2, b.setLineDash && (s[t].lineDashType ? (q = s[t].lineDashType, b.setLineDash(R(q, m.lineThickness))) : (q = m.lineDashType, b.setLineDash(f))));
                      if (0 < s[t].markerSize || 0 < m.markerSize) {
                        var A = m.getMarkerProperties(t, C, x, b);
                        g.push(A);
                        y = N(y);
                        r && g.push({ x: C, y: x, ctx: c, type: A.type, size: A.size, color: y, borderColor: y, borderThickness: A.borderThickness });
                      }
                      (s[t].indexLabel || m.indexLabel || s[t].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "line", dataPoint: s[t], dataSeries: m, point: { x: C, y: x }, direction: 0 > s[t].y === a.axisY.reversed ? 1 : -1, color: B });
                    }
                b.stroke();
                r && c.stroke();
              }
            }
            ia.drawMarkers(g);
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());
            b.restore();
            b.beginPath();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };
          }
        };
        p.prototype.renderStepLine = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = this._eventManager.ghostCtx;
            b.save();
            var e = this.plotArea;
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            for (var g = [], k, l = 0; l < a.dataSeriesIndexes.length; l++) {
              var w = a.dataSeriesIndexes[l], m = this.data[w];
              b.lineWidth = m.lineThickness;
              var s = m.dataPoints, q = "solid";
              if (b.setLineDash) {
                var n = R(m.nullDataLineDashType, m.lineThickness), q = m.lineDashType, f = R(q, m.lineThickness);
                b.setLineDash(f);
              }
              var B = m.id;
              this._eventManager.objectMap[B] = { objectType: "dataSeries", dataSeriesIndex: w };
              B = N(B);
              c.strokeStyle = B;
              c.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;
              var B = m._colorSet, h2 = B = m.lineColor = m.options.lineColor ? m.options.lineColor : B[0];
              b.strokeStyle = B;
              var p2 = true, t = 0, C, x;
              b.beginPath();
              if (0 < s.length) {
                for (var u2 = false, t = 0; t < s.length; t++)
                  if (C = s[t].getTime ? s[t].x.getTime() : s[t].x, !(C < a.axisX.dataInfo.viewPortMin || C > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !u2)))
                    if ("number" !== typeof s[t].y)
                      0 < t && !(m.connectNullData || u2 || p2) && (b.stroke(), r && c.stroke()), u2 = true;
                    else {
                      var y = x;
                      C = a.axisX.convertValueToPixel(C);
                      x = a.axisY.convertValueToPixel(s[t].y);
                      var A = m.dataPointIds[t];
                      this._eventManager.objectMap[A] = { id: A, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: t, x1: C, y1: x };
                      p2 || u2 ? (!p2 && m.connectNullData ? (b.setLineDash && (m.options.nullDataLineDashType || q === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(k.x, k.y), q = m.nullDataLineDashType, b.setLineDash(n)), b.lineTo(C, y), b.lineTo(C, x), r && (c.lineTo(
                        C,
                        y
                      ), c.lineTo(C, x))) : (b.beginPath(), b.moveTo(C, x), r && (c.beginPath(), c.moveTo(C, x))), u2 = p2 = false) : (b.lineTo(C, y), r && c.lineTo(C, y), b.lineTo(C, x), r && c.lineTo(C, x), 0 == t % 500 && (b.stroke(), b.beginPath(), b.moveTo(C, x), r && (c.stroke(), c.beginPath(), c.moveTo(C, x))));
                      k = { x: C, y: x };
                      t < s.length - 1 && (h2 !== (s[t].lineColor || B) || q !== (s[t].lineDashType || m.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(C, x), h2 = s[t].lineColor || B, b.strokeStyle = h2, b.setLineDash && (s[t].lineDashType ? (q = s[t].lineDashType, b.setLineDash(R(q, m.lineThickness))) : (q = m.lineDashType, b.setLineDash(f))));
                      if (0 < s[t].markerSize || 0 < m.markerSize)
                        y = m.getMarkerProperties(t, C, x, b), g.push(y), A = N(A), r && g.push({ x: C, y: x, ctx: c, type: y.type, size: y.size, color: A, borderColor: A, borderThickness: y.borderThickness });
                      (s[t].indexLabel || m.indexLabel || s[t].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: s[t], dataSeries: m, point: { x: C, y: x }, direction: 0 > s[t].y === a.axisY.reversed ? 1 : -1, color: B });
                    }
                b.stroke();
                r && c.stroke();
              }
            }
            ia.drawMarkers(g);
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());
            b.restore();
            b.beginPath();
            return {
              source: d,
              dest: this.plotArea.ctx,
              animationCallback: M.xClipAnimation,
              easingFunction: M.easing.linear,
              animationBase: 0
            };
          }
        };
        p.prototype.renderSpline = function(a) {
          function d(a2) {
            a2 = v2(a2, 2);
            if (0 < a2.length) {
              c.beginPath();
              r && e.beginPath();
              c.moveTo(a2[0].x, a2[0].y);
              a2[0].newStrokeStyle && (c.strokeStyle = a2[0].newStrokeStyle);
              a2[0].newLineDashArray && c.setLineDash(a2[0].newLineDashArray);
              r && e.moveTo(a2[0].x, a2[0].y);
              for (var b2 = 0; b2 < a2.length - 3; b2 += 3)
                if (c.bezierCurveTo(a2[b2 + 1].x, a2[b2 + 1].y, a2[b2 + 2].x, a2[b2 + 2].y, a2[b2 + 3].x, a2[b2 + 3].y), r && e.bezierCurveTo(a2[b2 + 1].x, a2[b2 + 1].y, a2[b2 + 2].x, a2[b2 + 2].y, a2[b2 + 3].x, a2[b2 + 3].y), 0 < b2 && 0 === b2 % 3e3 || a2[b2 + 3].newStrokeStyle || a2[b2 + 3].newLineDashArray)
                  c.stroke(), c.beginPath(), c.moveTo(a2[b2 + 3].x, a2[b2 + 3].y), a2[b2 + 3].newStrokeStyle && (c.strokeStyle = a2[b2 + 3].newStrokeStyle), a2[b2 + 3].newLineDashArray && c.setLineDash(a2[b2 + 3].newLineDashArray), r && (e.stroke(), e.beginPath(), e.moveTo(a2[b2 + 3].x, a2[b2 + 3].y));
              c.stroke();
              r && e.stroke();
            }
          }
          var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx;
            c.save();
            var g = this.plotArea;
            c.beginPath();
            c.rect(g.x1, g.y1, g.width, g.height);
            c.clip();
            for (var k = [], l = 0; l < a.dataSeriesIndexes.length; l++) {
              var w = a.dataSeriesIndexes[l], m = this.data[w];
              c.lineWidth = m.lineThickness;
              var s = m.dataPoints, q = "solid";
              if (c.setLineDash) {
                var n = R(m.nullDataLineDashType, m.lineThickness), q = m.lineDashType, f = R(q, m.lineThickness);
                c.setLineDash(f);
              }
              var B = m.id;
              this._eventManager.objectMap[B] = { objectType: "dataSeries", dataSeriesIndex: w };
              B = N(B);
              e.strokeStyle = B;
              e.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;
              var B = m._colorSet, h2 = B = m.lineColor = m.options.lineColor ? m.options.lineColor : B[0];
              c.strokeStyle = B;
              var p2 = 0, t, u2, x = [];
              c.beginPath();
              if (0 < s.length) {
                for (u2 = false, p2 = 0; p2 < s.length; p2++)
                  if (t = s[p2].getTime ? s[p2].x.getTime() : s[p2].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !u2)))
                    if ("number" !== typeof s[p2].y)
                      0 < p2 && !u2 && (m.connectNullData ? c.setLineDash && (0 < x.length && (m.options.nullDataLineDashType || !s[p2 - 1].lineDashType)) && (x[x.length - 1].newLineDashArray = n, q = m.nullDataLineDashType) : (d(x), x = [])), u2 = true;
                    else {
                      t = a.axisX.convertValueToPixel(t);
                      u2 = a.axisY.convertValueToPixel(s[p2].y);
                      var ma = m.dataPointIds[p2];
                      this._eventManager.objectMap[ma] = { id: ma, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: p2, x1: t, y1: u2 };
                      x[x.length] = { x: t, y: u2 };
                      p2 < s.length - 1 && (h2 !== (s[p2].lineColor || B) || q !== (s[p2].lineDashType || m.lineDashType)) && (h2 = s[p2].lineColor || B, x[x.length - 1].newStrokeStyle = h2, c.setLineDash && (s[p2].lineDashType ? (q = s[p2].lineDashType, x[x.length - 1].newLineDashArray = R(q, m.lineThickness)) : (q = m.lineDashType, x[x.length - 1].newLineDashArray = f)));
                      if (0 < s[p2].markerSize || 0 < m.markerSize) {
                        var y = m.getMarkerProperties(p2, t, u2, c);
                        k.push(y);
                        ma = N(ma);
                        r && k.push({ x: t, y: u2, ctx: e, type: y.type, size: y.size, color: ma, borderColor: ma, borderThickness: y.borderThickness });
                      }
                      (s[p2].indexLabel || m.indexLabel || s[p2].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "spline", dataPoint: s[p2], dataSeries: m, point: { x: t, y: u2 }, direction: 0 > s[p2].y === a.axisY.reversed ? 1 : -1, color: B });
                      u2 = false;
                    }
              }
              d(x);
            }
            ia.drawMarkers(k);
            r && (b.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), e.beginPath());
            c.restore();
            c.beginPath();
            return {
              source: b,
              dest: this.plotArea.ctx,
              animationCallback: M.xClipAnimation,
              easingFunction: M.easing.linear,
              animationBase: 0
            };
          }
        };
        p.prototype.renderColumn = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = 0, k, l, w, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(
              0.15 * this.width,
              0.9 * (this.plotArea.width / a.plotType.totalDataSeries)
            ) << 0, q = a.axisX.dataInfo.minDiff;
            isFinite(q) || (q = 0.3 * Math.abs(a.axisX.range));
            q = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && g > s && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, s));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && s < g) && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g));
            q < g && (q = g);
            q > s && (q = s);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (s = 0; s < a.dataSeriesIndexes.length; s++) {
              var n = a.dataSeriesIndexes[s], f = this.data[n], B = f.dataPoints;
              if (0 < B.length) {
                for (var p2 = 5 < q && f.bevelEnabled ? true : false, g = 0; g < B.length; g++)
                  if (B[g].getTime ? w = B[g].x.getTime() : w = B[g].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && "number" === typeof B[g].y) {
                    k = a.axisX.convertValueToPixel(w);
                    l = a.axisY.convertValueToPixel(B[g].y);
                    k = a.axisX.reversed ? k + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + s) * q << 0 : k - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + s) * q << 0;
                    var h2 = a.axisX.reversed ? k - q << 0 : k + q << 0, t;
                    0 <= B[g].y ? t = m : (t = l, l = m);
                    l > t && (c = l, l = t, t = c);
                    c = B[g].color ? B[g].color : f._colorSet[g % f._colorSet.length];
                    ea(
                      b,
                      k,
                      l,
                      h2,
                      t,
                      c,
                      0,
                      null,
                      p2 && 0 <= B[g].y,
                      0 > B[g].y && p2,
                      false,
                      false,
                      f.fillOpacity
                    );
                    c = f.dataPointIds[g];
                    this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: g, x1: k, y1: l, x2: h2, y2: t };
                    c = N(c);
                    r && ea(this._eventManager.ghostCtx, k, l, h2, t, c, 0, null, false, false, false, false);
                    (B[g].indexLabel || f.indexLabel || B[g].indexLabelFormatter || f.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: B[g], dataSeries: f, point: { x: k + (h2 - k) / 2, y: 0 > B[g].y === a.axisY.reversed ? l : t }, direction: 0 > B[g].y === a.axisY.reversed ? 1 : -1, bounds: {
                      x1: k,
                      y1: Math.min(l, t),
                      x2: h2,
                      y2: Math.max(l, t)
                    }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.yScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: m < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : m > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : m };
          }
        };
        p.prototype.renderStackedColumn = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;
            var f = a.axisX.dataInfo.minDiff;
            isFinite(f) || (f = 0.3 * Math.abs(a.axisX.range));
            f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > s && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, s));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && s < m) && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            f < m && (f = m);
            f > s && (f = s);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var B = 0; B < a.dataSeriesIndexes.length; B++) {
              var h2 = a.dataSeriesIndexes[B], p2 = this.data[h2], t = p2.dataPoints;
              if (0 < t.length) {
                var u2 = 5 < f && p2.bevelEnabled ? true : false;
                b.strokeStyle = "#4572A7 ";
                for (m = 0; m < t.length; m++)
                  if (c = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    s = a.axisX.convertValueToPixel(c);
                    var x = s - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, v3 = x + f << 0, y;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y)
                      l[c] = t[m].y + (l[c] ? l[c] : 0), 0 < l[c] && (q = a.axisY.convertValueToPixel(l[c]), y = "undefined" !== typeof g[c] ? g[c] : n, g[c] = q);
                    else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      w[c] = t[m].y + (w[c] ? w[c] : 0), y = a.axisY.convertValueToPixel(w[c]), q = "undefined" !== typeof k[c] ? k[c] : n, k[c] = y;
                    else if (q = a.axisY.convertValueToPixel(t[m].y), 0 <= t[m].y) {
                      var A = "undefined" !== typeof g[c] ? g[c] : 0;
                      q -= A;
                      y = n - A;
                      g[c] = A + (y - q);
                    } else
                      A = k[c] ? k[c] : 0, y = q + A, q = n + A, k[c] = A + (y - q);
                    c = t[m].color ? t[m].color : p2._colorSet[m % p2._colorSet.length];
                    ea(
                      b,
                      x,
                      q,
                      v3,
                      y,
                      c,
                      0,
                      null,
                      u2 && 0 <= t[m].y,
                      0 > t[m].y && u2,
                      false,
                      false,
                      p2.fillOpacity
                    );
                    c = p2.dataPointIds[m];
                    this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: h2, dataPointIndex: m, x1: x, y1: q, x2: v3, y2: y };
                    c = N(c);
                    r && ea(this._eventManager.ghostCtx, x, q, v3, y, c, 0, null, false, false, false, false);
                    (t[m].indexLabel || p2.indexLabel || t[m].indexLabelFormatter || p2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: t[m], dataSeries: p2, point: { x: s, y: 0 <= t[m].y ? q : y }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: x, y1: Math.min(q, y), x2: v3, y2: Math.max(
                      q,
                      y
                    ) }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return {
              source: d,
              dest: this.plotArea.ctx,
              animationCallback: M.yScaleAnimation,
              easingFunction: M.easing.easeOutQuart,
              animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n
            };
          }
        };
        p.prototype.renderStackedColumn100 = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;
            var f = a.axisX.dataInfo.minDiff;
            isFinite(f) || (f = 0.3 * Math.abs(a.axisX.range));
            f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > s && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, s));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && s < m) && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            f < m && (f = m);
            f > s && (f = s);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var B = 0; B < a.dataSeriesIndexes.length; B++) {
              var p2 = a.dataSeriesIndexes[B], h2 = this.data[p2], t = h2.dataPoints;
              if (0 < t.length) {
                for (var u2 = 5 < f && h2.bevelEnabled ? true : false, m = 0; m < t.length; m++)
                  if (c = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    s = a.axisX.convertValueToPixel(c);
                    q = 0 !== a.dataPointYSums[c] ? 100 * (t[m].y / a.dataPointYSums[c]) : 0;
                    var x = s - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, v3 = x + f << 0, y;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y) {
                      l[c] = q + ("undefined" !== typeof l[c] ? l[c] : 0);
                      if (0 >= l[c])
                        continue;
                      q = a.axisY.convertValueToPixel(l[c]);
                      y = g[c] ? g[c] : n;
                      g[c] = q;
                    } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      w[c] = q + ("undefined" !== typeof w[c] ? w[c] : 0), y = a.axisY.convertValueToPixel(w[c]), q = k[c] ? k[c] : n, k[c] = y;
                    else if (q = a.axisY.convertValueToPixel(q), 0 <= t[m].y) {
                      var A = "undefined" !== typeof g[c] ? g[c] : 0;
                      q -= A;
                      y = n - A;
                      a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.y1 - q) && (q = e.y1);
                      g[c] = A + (y - q);
                    } else
                      A = "undefined" !== typeof k[c] ? k[c] : 0, y = q + A, q = n + A, a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.y2 - y) && (y = e.y2), k[c] = A + (y - q);
                    c = t[m].color ? t[m].color : h2._colorSet[m % h2._colorSet.length];
                    ea(b, x, q, v3, y, c, 0, null, u2 && 0 <= t[m].y, 0 > t[m].y && u2, false, false, h2.fillOpacity);
                    c = h2.dataPointIds[m];
                    this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: p2, dataPointIndex: m, x1: x, y1: q, x2: v3, y2: y };
                    c = N(c);
                    r && ea(this._eventManager.ghostCtx, x, q, v3, y, c, 0, null, false, false, false, false);
                    (t[m].indexLabel || h2.indexLabel || t[m].indexLabelFormatter || h2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn100", dataPoint: t[m], dataSeries: h2, point: { x: s, y: 0 <= t[m].y ? q : y }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: x, y1: Math.min(q, y), x2: v3, y2: Math.max(q, y) }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.yScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n };
          }
        };
        p.prototype.renderBar = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = 0, k, l, w, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0, q = a.axisX.dataInfo.minDiff;
            isFinite(q) || (q = 0.3 * Math.abs(a.axisX.range));
            q = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && g > s && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, s));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && s < g) && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g));
            q < g && (q = g);
            q > s && (q = s);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (s = 0; s < a.dataSeriesIndexes.length; s++) {
              var n = a.dataSeriesIndexes[s], f = this.data[n], B = f.dataPoints;
              if (0 < B.length) {
                var h2 = 5 < q && f.bevelEnabled ? true : false;
                b.strokeStyle = "#4572A7 ";
                for (g = 0; g < B.length; g++)
                  if (B[g].getTime ? w = B[g].x.getTime() : w = B[g].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && "number" === typeof B[g].y) {
                    l = a.axisX.convertValueToPixel(w);
                    k = a.axisY.convertValueToPixel(B[g].y);
                    l = a.axisX.reversed ? l + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + s) * q << 0 : l - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + s) * q << 0;
                    var p2 = a.axisX.reversed ? l - q << 0 : l + q << 0, t;
                    0 <= B[g].y ? t = m : (t = k, k = m);
                    c = B[g].color ? B[g].color : f._colorSet[g % f._colorSet.length];
                    ea(b, t, l, k, p2, c, 0, null, h2, false, false, false, f.fillOpacity);
                    c = f.dataPointIds[g];
                    this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: g, x1: t, y1: l, x2: k, y2: p2 };
                    c = N(c);
                    r && ea(this._eventManager.ghostCtx, t, l, k, p2, c, 0, null, false, false, false, false);
                    (B[g].indexLabel || f.indexLabel || B[g].indexLabelFormatter || f.indexLabelFormatter) && this._indexLabels.push({ chartType: "bar", dataPoint: B[g], dataSeries: f, point: { x: 0 <= B[g].y ? k : t, y: l + (p2 - l) / 2 }, direction: 0 > B[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(t, k), y1: l, x2: Math.max(t, k), y2: p2 }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.xScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: m < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : m > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : m };
          }
        };
        p.prototype.renderStackedBar = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            q = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;
            var f = a.axisX.dataInfo.minDiff;
            isFinite(f) || (f = 0.3 * Math.abs(a.axisX.range));
            f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > q && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, q));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && q < m) && (q = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            f < m && (f = m);
            f > q && (f = q);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var B = 0; B < a.dataSeriesIndexes.length; B++) {
              var p2 = a.dataSeriesIndexes[B], h2 = this.data[p2], t = h2.dataPoints;
              if (0 < t.length) {
                var u2 = 5 < f && h2.bevelEnabled ? true : false;
                b.strokeStyle = "#4572A7 ";
                for (m = 0; m < t.length; m++)
                  if (c = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    q = a.axisX.convertValueToPixel(c);
                    var x = q - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, v3 = x + f << 0, y;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y)
                      l[c] = t[m].y + (l[c] ? l[c] : 0), 0 < l[c] && (y = g[c] ? g[c] : n, g[c] = s = a.axisY.convertValueToPixel(l[c]));
                    else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      w[c] = t[m].y + (w[c] ? w[c] : 0), s = k[c] ? k[c] : n, k[c] = y = a.axisY.convertValueToPixel(w[c]);
                    else if (s = a.axisY.convertValueToPixel(t[m].y), 0 <= t[m].y) {
                      var A = g[c] ? g[c] : 0;
                      y = n + A;
                      s += A;
                      g[c] = A + (s - y);
                    } else
                      A = k[c] ? k[c] : 0, y = s - A, s = n - A, k[c] = A + (s - y);
                    c = t[m].color ? t[m].color : h2._colorSet[m % h2._colorSet.length];
                    ea(b, y, x, s, v3, c, 0, null, u2, false, false, false, h2.fillOpacity);
                    c = h2.dataPointIds[m];
                    this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: p2, dataPointIndex: m, x1: y, y1: x, x2: s, y2: v3 };
                    c = N(c);
                    r && ea(
                      this._eventManager.ghostCtx,
                      y,
                      x,
                      s,
                      v3,
                      c,
                      0,
                      null,
                      false,
                      false,
                      false,
                      false
                    );
                    (t[m].indexLabel || h2.indexLabel || t[m].indexLabelFormatter || h2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar", dataPoint: t[m], dataSeries: h2, point: { x: 0 <= t[m].y ? s : y, y: q }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(y, s), y1: x, x2: Math.max(y, s), y2: v3 }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.xScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };
          }
        };
        p.prototype.renderStackedBar100 = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            q = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;
            var f = a.axisX.dataInfo.minDiff;
            isFinite(f) || (f = 0.3 * Math.abs(a.axisX.range));
            f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > q && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, q));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && q < m) && (q = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            f < m && (f = m);
            f > q && (f = q);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var B = 0; B < a.dataSeriesIndexes.length; B++) {
              var h2 = a.dataSeriesIndexes[B], p2 = this.data[h2], t = p2.dataPoints;
              if (0 < t.length) {
                var u2 = 5 < f && p2.bevelEnabled ? true : false;
                b.strokeStyle = "#4572A7 ";
                for (m = 0; m < t.length; m++)
                  if (c = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    q = a.axisX.convertValueToPixel(c);
                    var x;
                    x = 0 !== a.dataPointYSums[c] ? 100 * (t[m].y / a.dataPointYSums[c]) : 0;
                    var v3 = q - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, y = v3 + f << 0;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y) {
                      l[c] = x + (l[c] ? l[c] : 0);
                      if (0 >= l[c])
                        continue;
                      x = g[c] ? g[c] : n;
                      g[c] = s = a.axisY.convertValueToPixel(l[c]);
                    } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      w[c] = x + (w[c] ? w[c] : 0), s = k[c] ? k[c] : n, k[c] = x = a.axisY.convertValueToPixel(w[c]);
                    else if (s = a.axisY.convertValueToPixel(x), 0 <= t[m].y) {
                      var A = g[c] ? g[c] : 0;
                      x = n + A;
                      s += A;
                      a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.x2 - s) && (s = e.x2);
                      g[c] = A + (s - x);
                    } else
                      A = k[c] ? k[c] : 0, x = s - A, s = n - A, a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.x1 - x) && (x = e.x1), k[c] = A + (s - x);
                    c = t[m].color ? t[m].color : p2._colorSet[m % p2._colorSet.length];
                    ea(b, x, v3, s, y, c, 0, null, u2, false, false, false, p2.fillOpacity);
                    c = p2.dataPointIds[m];
                    this._eventManager.objectMap[c] = {
                      id: c,
                      objectType: "dataPoint",
                      dataSeriesIndex: h2,
                      dataPointIndex: m,
                      x1: x,
                      y1: v3,
                      x2: s,
                      y2: y
                    };
                    c = N(c);
                    r && ea(this._eventManager.ghostCtx, x, v3, s, y, c, 0, null, false, false, false, false);
                    (t[m].indexLabel || p2.indexLabel || t[m].indexLabelFormatter || p2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar100", dataPoint: t[m], dataSeries: p2, point: { x: 0 <= t[m].y ? s : x, y: q }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(x, s), y1: v3, x2: Math.max(x, s), y2: y }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.xScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };
          }
        };
        p.prototype.renderArea = function(a) {
          var d, b;
          function c() {
            A && (0 < B.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? y = v3 : 0 > a.axisY.viewportMaximum ? y = w.y1 : 0 < a.axisY.viewportMinimum && (y = l.y2), g.lineTo(t, y), g.lineTo(A.x, y), g.closePath(), g.globalAlpha = B.fillOpacity, g.fill(), g.globalAlpha = 1, r && (k.lineTo(t, y), k.lineTo(A.x, y), k.closePath(), k.fill()), g.beginPath(), g.moveTo(t, u2), k.beginPath(), k.moveTo(t, u2), A = { x: t, y: u2 });
          }
          var e = a.targetCanvasCtx || this.plotArea.ctx, g = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var k = this._eventManager.ghostCtx, l = a.axisX.lineCoordinates, w = a.axisY.lineCoordinates, m = [], s = this.plotArea, q;
            g.save();
            r && k.save();
            g.beginPath();
            g.rect(s.x1, s.y1, s.width, s.height);
            g.clip();
            r && (k.beginPath(), k.rect(s.x1, s.y1, s.width, s.height), k.clip());
            for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
              var f = a.dataSeriesIndexes[n], B = this.data[f], p2 = B.dataPoints, m = B.id;
              this._eventManager.objectMap[m] = {
                objectType: "dataSeries",
                dataSeriesIndex: f
              };
              m = N(m);
              k.fillStyle = m;
              m = [];
              d = true;
              var h2 = 0, t, u2, x, v3 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), y, A = null;
              if (0 < p2.length) {
                var z2 = B._colorSet[h2 % B._colorSet.length], aa = B.lineColor = B.options.lineColor || z2, T = aa;
                g.fillStyle = z2;
                g.strokeStyle = aa;
                g.lineWidth = B.lineThickness;
                b = "solid";
                if (g.setLineDash) {
                  var Y = R(B.nullDataLineDashType, B.lineThickness);
                  b = B.lineDashType;
                  var ca = R(b, B.lineThickness);
                  g.setLineDash(ca);
                }
                for (var da = true; h2 < p2.length; h2++)
                  if (x = p2[h2].x.getTime ? p2[h2].x.getTime() : p2[h2].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!B.connectNullData || !da)))
                    if ("number" !== typeof p2[h2].y)
                      B.connectNullData || (da || d) || c(), da = true;
                    else {
                      t = a.axisX.convertValueToPixel(x);
                      u2 = a.axisY.convertValueToPixel(p2[h2].y);
                      d || da ? (!d && B.connectNullData ? (g.setLineDash && (B.options.nullDataLineDashType || b === B.lineDashType && B.lineDashType !== B.nullDataLineDashType) && (d = t, b = u2, t = q.x, u2 = q.y, c(), g.moveTo(q.x, q.y), t = d, u2 = b, A = q, b = B.nullDataLineDashType, g.setLineDash(Y)), g.lineTo(t, u2), r && k.lineTo(
                        t,
                        u2
                      )) : (g.beginPath(), g.moveTo(t, u2), r && (k.beginPath(), k.moveTo(t, u2)), A = { x: t, y: u2 }), da = d = false) : (g.lineTo(t, u2), r && k.lineTo(t, u2), 0 == h2 % 250 && c());
                      q = { x: t, y: u2 };
                      h2 < p2.length - 1 && (T !== (p2[h2].lineColor || aa) || b !== (p2[h2].lineDashType || B.lineDashType)) && (c(), T = p2[h2].lineColor || aa, g.strokeStyle = T, g.setLineDash && (p2[h2].lineDashType ? (b = p2[h2].lineDashType, g.setLineDash(R(b, B.lineThickness))) : (b = B.lineDashType, g.setLineDash(ca))));
                      var Z = B.dataPointIds[h2];
                      this._eventManager.objectMap[Z] = {
                        id: Z,
                        objectType: "dataPoint",
                        dataSeriesIndex: f,
                        dataPointIndex: h2,
                        x1: t,
                        y1: u2
                      };
                      0 !== p2[h2].markerSize && (0 < p2[h2].markerSize || 0 < B.markerSize) && (x = B.getMarkerProperties(h2, t, u2, g), m.push(x), Z = N(Z), r && m.push({ x: t, y: u2, ctx: k, type: x.type, size: x.size, color: Z, borderColor: Z, borderThickness: x.borderThickness }));
                      (p2[h2].indexLabel || B.indexLabel || p2[h2].indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({ chartType: "area", dataPoint: p2[h2], dataSeries: B, point: { x: t, y: u2 }, direction: 0 > p2[h2].y === a.axisY.reversed ? 1 : -1, color: z2 });
                    }
                c();
                ia.drawMarkers(m);
              }
            }
            r && (e.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), g.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.restore());
            g.restore();
            return {
              source: e,
              dest: this.plotArea.ctx,
              animationCallback: M.xClipAnimation,
              easingFunction: M.easing.linear,
              animationBase: 0
            };
          }
        };
        p.prototype.renderSplineArea = function(a) {
          function d() {
            var b2 = v2(x, 2);
            if (0 < b2.length) {
              if (0 < q.lineThickness) {
                c.beginPath();
                c.moveTo(b2[0].x, b2[0].y);
                b2[0].newStrokeStyle && (c.strokeStyle = b2[0].newStrokeStyle);
                b2[0].newLineDashArray && c.setLineDash(b2[0].newLineDashArray);
                for (var d2 = 0; d2 < b2.length - 3; d2 += 3)
                  if (c.bezierCurveTo(b2[d2 + 1].x, b2[d2 + 1].y, b2[d2 + 2].x, b2[d2 + 2].y, b2[d2 + 3].x, b2[d2 + 3].y), r && e.bezierCurveTo(b2[d2 + 1].x, b2[d2 + 1].y, b2[d2 + 2].x, b2[d2 + 2].y, b2[d2 + 3].x, b2[d2 + 3].y), b2[d2 + 3].newStrokeStyle || b2[d2 + 3].newLineDashArray)
                    c.stroke(), c.beginPath(), c.moveTo(b2[d2 + 3].x, b2[d2 + 3].y), b2[d2 + 3].newStrokeStyle && (c.strokeStyle = b2[d2 + 3].newStrokeStyle), b2[d2 + 3].newLineDashArray && c.setLineDash(b2[d2 + 3].newLineDashArray);
                c.stroke();
              }
              c.beginPath();
              c.moveTo(b2[0].x, b2[0].y);
              r && (e.beginPath(), e.moveTo(b2[0].x, b2[0].y));
              for (d2 = 0; d2 < b2.length - 3; d2 += 3)
                c.bezierCurveTo(b2[d2 + 1].x, b2[d2 + 1].y, b2[d2 + 2].x, b2[d2 + 2].y, b2[d2 + 3].x, b2[d2 + 3].y), r && e.bezierCurveTo(b2[d2 + 1].x, b2[d2 + 1].y, b2[d2 + 2].x, b2[d2 + 2].y, b2[d2 + 3].x, b2[d2 + 3].y);
              a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? t = p2 : 0 > a.axisY.viewportMaximum ? t = k.y1 : 0 < a.axisY.viewportMinimum && (t = g.y2);
              u2 = { x: b2[0].x, y: b2[0].y };
              c.lineTo(b2[b2.length - 1].x, t);
              c.lineTo(u2.x, t);
              c.closePath();
              c.globalAlpha = q.fillOpacity;
              c.fill();
              c.globalAlpha = 1;
              r && (e.lineTo(b2[b2.length - 1].x, t), e.lineTo(u2.x, t), e.closePath(), e.fill());
            }
          }
          var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, g = a.axisX.lineCoordinates, k = a.axisY.lineCoordinates, l = [], w = this.plotArea;
            c.save();
            r && e.save();
            c.beginPath();
            c.rect(w.x1, w.y1, w.width, w.height);
            c.clip();
            r && (e.beginPath(), e.rect(w.x1, w.y1, w.width, w.height), e.clip());
            for (var m = 0; m < a.dataSeriesIndexes.length; m++) {
              var s = a.dataSeriesIndexes[m], q = this.data[s], n = q.dataPoints, l = q.id;
              this._eventManager.objectMap[l] = { objectType: "dataSeries", dataSeriesIndex: s };
              l = N(l);
              e.fillStyle = l;
              var l = [], f = 0, B, h2, p2 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), t, u2 = null, x = [];
              if (0 < n.length) {
                var ma = q._colorSet[f % q._colorSet.length], y = q.lineColor = q.options.lineColor || ma, A = y;
                c.fillStyle = ma;
                c.strokeStyle = y;
                c.lineWidth = q.lineThickness;
                var z2 = "solid";
                if (c.setLineDash) {
                  var aa = R(q.nullDataLineDashType, q.lineThickness), z2 = q.lineDashType, T = R(z2, q.lineThickness);
                  c.setLineDash(T);
                }
                for (h2 = false; f < n.length; f++)
                  if (B = n[f].x.getTime ? n[f].x.getTime() : n[f].x, !(B < a.axisX.dataInfo.viewPortMin || B > a.axisX.dataInfo.viewPortMax && (!q.connectNullData || !h2)))
                    if ("number" !== typeof n[f].y)
                      0 < f && !h2 && (q.connectNullData ? c.setLineDash && (0 < x.length && (q.options.nullDataLineDashType || !n[f - 1].lineDashType)) && (x[x.length - 1].newLineDashArray = aa, z2 = q.nullDataLineDashType) : (d(), x = [])), h2 = true;
                    else {
                      B = a.axisX.convertValueToPixel(B);
                      h2 = a.axisY.convertValueToPixel(n[f].y);
                      var Y = q.dataPointIds[f];
                      this._eventManager.objectMap[Y] = { id: Y, objectType: "dataPoint", dataSeriesIndex: s, dataPointIndex: f, x1: B, y1: h2 };
                      x[x.length] = { x: B, y: h2 };
                      f < n.length - 1 && (A !== (n[f].lineColor || y) || z2 !== (n[f].lineDashType || q.lineDashType)) && (A = n[f].lineColor || y, x[x.length - 1].newStrokeStyle = A, c.setLineDash && (n[f].lineDashType ? (z2 = n[f].lineDashType, x[x.length - 1].newLineDashArray = R(z2, q.lineThickness)) : (z2 = q.lineDashType, x[x.length - 1].newLineDashArray = T)));
                      if (0 !== n[f].markerSize && (0 < n[f].markerSize || 0 < q.markerSize)) {
                        var ca = q.getMarkerProperties(f, B, h2, c);
                        l.push(ca);
                        Y = N(Y);
                        r && l.push({ x: B, y: h2, ctx: e, type: ca.type, size: ca.size, color: Y, borderColor: Y, borderThickness: ca.borderThickness });
                      }
                      (n[f].indexLabel || q.indexLabel || n[f].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({
                        chartType: "splineArea",
                        dataPoint: n[f],
                        dataSeries: q,
                        point: { x: B, y: h2 },
                        direction: 0 > n[f].y === a.axisY.reversed ? 1 : -1,
                        color: ma
                      });
                      h2 = false;
                    }
                d();
                ia.drawMarkers(l);
              }
            }
            r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(w.x1, w.y1, w.width, w.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };
          }
        };
        p.prototype.renderStepArea = function(a) {
          var d, b;
          function c() {
            A && (0 < B.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? y = v3 : 0 > a.axisY.viewportMaximum ? y = w.y1 : 0 < a.axisY.viewportMinimum && (y = l.y2), g.lineTo(t, y), g.lineTo(A.x, y), g.closePath(), g.globalAlpha = B.fillOpacity, g.fill(), g.globalAlpha = 1, r && (k.lineTo(t, y), k.lineTo(A.x, y), k.closePath(), k.fill()), g.beginPath(), g.moveTo(t, u2), k.beginPath(), k.moveTo(t, u2), A = { x: t, y: u2 });
          }
          var e = a.targetCanvasCtx || this.plotArea.ctx, g = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var k = this._eventManager.ghostCtx, l = a.axisX.lineCoordinates, w = a.axisY.lineCoordinates, m = [], s = this.plotArea, q;
            g.save();
            r && k.save();
            g.beginPath();
            g.rect(s.x1, s.y1, s.width, s.height);
            g.clip();
            r && (k.beginPath(), k.rect(s.x1, s.y1, s.width, s.height), k.clip());
            for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
              var f = a.dataSeriesIndexes[n], B = this.data[f], h2 = B.dataPoints, m = B.id;
              this._eventManager.objectMap[m] = { objectType: "dataSeries", dataSeriesIndex: f };
              m = N(m);
              k.fillStyle = m;
              m = [];
              d = true;
              var p2 = 0, t, u2, x, v3 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), y, A = null;
              b = false;
              if (0 < h2.length) {
                var z2 = B._colorSet[p2 % B._colorSet.length], aa = B.lineColor = B.options.lineColor || z2, T = aa;
                g.fillStyle = z2;
                g.strokeStyle = aa;
                g.lineWidth = B.lineThickness;
                var Y = "solid";
                if (g.setLineDash) {
                  var ca = R(B.nullDataLineDashType, B.lineThickness), Y = B.lineDashType, da = R(Y, B.lineThickness);
                  g.setLineDash(da);
                }
                for (; p2 < h2.length; p2++)
                  if (x = h2[p2].x.getTime ? h2[p2].x.getTime() : h2[p2].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!B.connectNullData || !b))) {
                    var Z = u2;
                    "number" !== typeof h2[p2].y ? (B.connectNullData || (b || d) || c(), b = true) : (t = a.axisX.convertValueToPixel(x), u2 = a.axisY.convertValueToPixel(h2[p2].y), d || b ? (!d && B.connectNullData ? (g.setLineDash && (B.options.nullDataLineDashType || Y === B.lineDashType && B.lineDashType !== B.nullDataLineDashType) && (d = t, b = u2, t = q.x, u2 = q.y, c(), g.moveTo(q.x, q.y), t = d, u2 = b, A = q, Y = B.nullDataLineDashType, g.setLineDash(ca)), g.lineTo(t, Z), g.lineTo(t, u2), r && (k.lineTo(t, Z), k.lineTo(t, u2))) : (g.beginPath(), g.moveTo(t, u2), r && (k.beginPath(), k.moveTo(t, u2)), A = { x: t, y: u2 }), b = d = false) : (g.lineTo(t, Z), r && k.lineTo(t, Z), g.lineTo(t, u2), r && k.lineTo(t, u2), 0 == p2 % 250 && c()), q = { x: t, y: u2 }, p2 < h2.length - 1 && (T !== (h2[p2].lineColor || aa) || Y !== (h2[p2].lineDashType || B.lineDashType)) && (c(), T = h2[p2].lineColor || aa, g.strokeStyle = T, g.setLineDash && (h2[p2].lineDashType ? (Y = h2[p2].lineDashType, g.setLineDash(R(Y, B.lineThickness))) : (Y = B.lineDashType, g.setLineDash(da)))), x = B.dataPointIds[p2], this._eventManager.objectMap[x] = { id: x, objectType: "dataPoint", dataSeriesIndex: f, dataPointIndex: p2, x1: t, y1: u2 }, 0 !== h2[p2].markerSize && (0 < h2[p2].markerSize || 0 < B.markerSize) && (Z = B.getMarkerProperties(p2, t, u2, g), m.push(Z), x = N(x), r && m.push({ x: t, y: u2, ctx: k, type: Z.type, size: Z.size, color: x, borderColor: x, borderThickness: Z.borderThickness })), (h2[p2].indexLabel || B.indexLabel || h2[p2].indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: h2[p2], dataSeries: B, point: { x: t, y: u2 }, direction: 0 > h2[p2].y === a.axisY.reversed ? 1 : -1, color: z2 }));
                  }
                c();
                ia.drawMarkers(m);
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), g.clearRect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.restore());
            g.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };
          }
        };
        p.prototype.renderStackedArea = function(a) {
          function d() {
            if (!(1 > m.length)) {
              for (0 < A.lineThickness && c.stroke(); 0 < m.length; ) {
                var a2 = m.pop();
                c.lineTo(a2.x, a2.y);
                r && u2.lineTo(a2.x, a2.y);
              }
              c.closePath();
              c.globalAlpha = A.fillOpacity;
              c.fill();
              c.globalAlpha = 1;
              c.beginPath();
              r && (u2.closePath(), u2.fill(), u2.beginPath());
              m = [];
            }
          }
          var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, g = null, k = [], l = this.plotArea, w = [], m = [], s = [], q = [], n = 0, f, h2, p2 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), u2 = this._eventManager.ghostCtx, t, C, x;
            r && u2.beginPath();
            c.save();
            r && u2.save();
            c.beginPath();
            c.rect(l.x1, l.y1, l.width, l.height);
            c.clip();
            r && (u2.beginPath(), u2.rect(l.x1, l.y1, l.width, l.height), u2.clip());
            for (var e = [], v3 = 0; v3 < a.dataSeriesIndexes.length; v3++) {
              var y = a.dataSeriesIndexes[v3], A = this.data[y], z2 = A.dataPoints;
              A.dataPointIndexes = [];
              for (n = 0; n < z2.length; n++)
                y = z2[n].x.getTime ? z2[n].x.getTime() : z2[n].x, A.dataPointIndexes[y] = n, e[y] || (s.push(y), e[y] = true);
              s.sort(Sa);
            }
            for (v3 = 0; v3 < a.dataSeriesIndexes.length; v3++) {
              y = a.dataSeriesIndexes[v3];
              A = this.data[y];
              z2 = A.dataPoints;
              C = true;
              m = [];
              n = A.id;
              this._eventManager.objectMap[n] = { objectType: "dataSeries", dataSeriesIndex: y };
              n = N(n);
              u2.fillStyle = n;
              if (0 < s.length) {
                var e = A._colorSet[0], aa = A.lineColor = A.options.lineColor || e, T = aa;
                c.fillStyle = e;
                c.strokeStyle = aa;
                c.lineWidth = A.lineThickness;
                x = "solid";
                if (c.setLineDash) {
                  var Y = R(A.nullDataLineDashType, A.lineThickness);
                  x = A.lineDashType;
                  var ca = R(x, A.lineThickness);
                  c.setLineDash(ca);
                }
                for (var da = true, n = 0; n < s.length; n++) {
                  var g = s[n], Z = null, Z = 0 <= A.dataPointIndexes[g] ? z2[A.dataPointIndexes[g]] : { x: g, y: null };
                  if (!(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !da)))
                    if ("number" !== typeof Z.y)
                      A.connectNullData || (da || C) || d(), da = true;
                    else {
                      f = a.axisX.convertValueToPixel(g);
                      var oa = w[g] ? w[g] : 0;
                      if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                        q[g] = Z.y + (q[g] ? q[g] : 0);
                        if (0 >= q[g] && a.axisY.logarithmic)
                          continue;
                        h2 = a.axisY.convertValueToPixel(q[g]);
                      } else
                        h2 = a.axisY.convertValueToPixel(Z.y), h2 -= oa;
                      m.push({ x: f, y: p2 - oa });
                      w[g] = p2 - h2;
                      C || da ? (!C && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || x === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (C = m.pop(), x = m[m.length - 1], d(), c.moveTo(t.x, t.y), m.push(x), m.push(C), x = A.nullDataLineDashType, c.setLineDash(Y)), c.lineTo(f, h2), r && u2.lineTo(f, h2)) : (c.beginPath(), c.moveTo(f, h2), r && (u2.beginPath(), u2.moveTo(f, h2))), da = C = false) : (c.lineTo(f, h2), r && u2.lineTo(f, h2), 0 == n % 250 && (d(), c.moveTo(f, h2), r && u2.moveTo(f, h2), m.push({ x: f, y: p2 - oa })));
                      t = { x: f, y: h2 };
                      n < z2.length - 1 && (T !== (z2[n].lineColor || aa) || x !== (z2[n].lineDashType || A.lineDashType)) && (d(), c.beginPath(), c.moveTo(f, h2), m.push({ x: f, y: p2 - oa }), T = z2[n].lineColor || aa, c.strokeStyle = T, c.setLineDash && (z2[n].lineDashType ? (x = z2[n].lineDashType, c.setLineDash(R(x, A.lineThickness))) : (x = A.lineDashType, c.setLineDash(ca))));
                      if (0 <= A.dataPointIndexes[g]) {
                        var la = A.dataPointIds[A.dataPointIndexes[g]];
                        this._eventManager.objectMap[la] = { id: la, objectType: "dataPoint", dataSeriesIndex: y, dataPointIndex: A.dataPointIndexes[g], x1: f, y1: h2 };
                      }
                      0 <= A.dataPointIndexes[g] && 0 !== Z.markerSize && (0 < Z.markerSize || 0 < A.markerSize) && (oa = A.getMarkerProperties(A.dataPointIndexes[g], f, h2, c), k.push(oa), g = N(la), r && k.push({ x: f, y: h2, ctx: u2, type: oa.type, size: oa.size, color: g, borderColor: g, borderThickness: oa.borderThickness }));
                      (Z.indexLabel || A.indexLabel || Z.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: Z, dataSeries: A, point: { x: f, y: h2 }, direction: 0 > z2[n].y === a.axisY.reversed ? 1 : -1, color: e });
                    }
                }
                d();
                c.moveTo(f, h2);
                r && u2.moveTo(f, h2);
              }
              delete A.dataPointIndexes;
            }
            ia.drawMarkers(k);
            r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(l.x1, l.y1, l.width, l.height), u2.restore());
            c.restore();
            return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };
          }
        };
        p.prototype.renderStackedArea100 = function(a) {
          function d() {
            for (0 < A.lineThickness && c.stroke(); 0 < m.length; ) {
              var a2 = m.pop();
              c.lineTo(a2.x, a2.y);
              r && x.lineTo(
                a2.x,
                a2.y
              );
            }
            c.closePath();
            c.globalAlpha = A.fillOpacity;
            c.fill();
            c.globalAlpha = 1;
            c.beginPath();
            r && (x.closePath(), x.fill(), x.beginPath());
            m = [];
          }
          var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, g = null, k = this.plotArea, l = [], w = [], m = [], s = [], q = [], n = 0, f, h2, p2, u2, t, C = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), x = this._eventManager.ghostCtx;
            c.save();
            r && x.save();
            c.beginPath();
            c.rect(k.x1, k.y1, k.width, k.height);
            c.clip();
            r && (x.beginPath(), x.rect(k.x1, k.y1, k.width, k.height), x.clip());
            for (var e = [], v3 = 0; v3 < a.dataSeriesIndexes.length; v3++) {
              var y = a.dataSeriesIndexes[v3], A = this.data[y], z2 = A.dataPoints;
              A.dataPointIndexes = [];
              for (n = 0; n < z2.length; n++)
                y = z2[n].x.getTime ? z2[n].x.getTime() : z2[n].x, A.dataPointIndexes[y] = n, e[y] || (s.push(y), e[y] = true);
              s.sort(Sa);
            }
            for (v3 = 0; v3 < a.dataSeriesIndexes.length; v3++) {
              y = a.dataSeriesIndexes[v3];
              A = this.data[y];
              z2 = A.dataPoints;
              u2 = true;
              e = A.id;
              this._eventManager.objectMap[e] = { objectType: "dataSeries", dataSeriesIndex: y };
              e = N(e);
              x.fillStyle = e;
              m = [];
              if (0 < s.length) {
                var e = A._colorSet[n % A._colorSet.length], aa = A.lineColor = A.options.lineColor || e, T = aa;
                c.fillStyle = e;
                c.strokeStyle = aa;
                c.lineWidth = A.lineThickness;
                t = "solid";
                if (c.setLineDash) {
                  var Y = R(A.nullDataLineDashType, A.lineThickness);
                  t = A.lineDashType;
                  var ca = R(t, A.lineThickness);
                  c.setLineDash(ca);
                }
                for (var da = true, n = 0; n < s.length; n++) {
                  var g = s[n], Z = null, Z = 0 <= A.dataPointIndexes[g] ? z2[A.dataPointIndexes[g]] : { x: g, y: null };
                  if (!(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !da)))
                    if ("number" !== typeof Z.y)
                      A.connectNullData || (da || u2) || d(), da = true;
                    else {
                      var oa;
                      oa = 0 !== a.dataPointYSums[g] ? 100 * (Z.y / a.dataPointYSums[g]) : 0;
                      f = a.axisX.convertValueToPixel(g);
                      var la = w[g] ? w[g] : 0;
                      if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                        q[g] = oa + (q[g] ? q[g] : 0);
                        if (0 >= q[g] && a.axisY.logarithmic)
                          continue;
                        h2 = a.axisY.convertValueToPixel(q[g]);
                      } else
                        h2 = a.axisY.convertValueToPixel(oa), h2 -= la;
                      m.push({ x: f, y: C - la });
                      w[g] = C - h2;
                      u2 || da ? (!u2 && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || t === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (u2 = m.pop(), t = m[m.length - 1], d(), c.moveTo(p2.x, p2.y), m.push(t), m.push(u2), t = A.nullDataLineDashType, c.setLineDash(Y)), c.lineTo(f, h2), r && x.lineTo(f, h2)) : (c.beginPath(), c.moveTo(f, h2), r && (x.beginPath(), x.moveTo(f, h2))), da = u2 = false) : (c.lineTo(f, h2), r && x.lineTo(f, h2), 0 == n % 250 && (d(), c.moveTo(f, h2), r && x.moveTo(f, h2), m.push({ x: f, y: C - la })));
                      p2 = { x: f, y: h2 };
                      n < z2.length - 1 && (T !== (z2[n].lineColor || aa) || t !== (z2[n].lineDashType || A.lineDashType)) && (d(), c.beginPath(), c.moveTo(f, h2), m.push({ x: f, y: C - la }), T = z2[n].lineColor || aa, c.strokeStyle = T, c.setLineDash && (z2[n].lineDashType ? (t = z2[n].lineDashType, c.setLineDash(R(t, A.lineThickness))) : (t = A.lineDashType, c.setLineDash(ca))));
                      if (0 <= A.dataPointIndexes[g]) {
                        var G = A.dataPointIds[A.dataPointIndexes[g]];
                        this._eventManager.objectMap[G] = { id: G, objectType: "dataPoint", dataSeriesIndex: y, dataPointIndex: A.dataPointIndexes[g], x1: f, y1: h2 };
                      }
                      0 <= A.dataPointIndexes[g] && 0 !== Z.markerSize && (0 < Z.markerSize || 0 < A.markerSize) && (la = A.getMarkerProperties(n, f, h2, c), l.push(la), g = N(G), r && l.push({ x: f, y: h2, ctx: x, type: la.type, size: la.size, color: g, borderColor: g, borderThickness: la.borderThickness }));
                      (Z.indexLabel || A.indexLabel || Z.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea100", dataPoint: Z, dataSeries: A, point: { x: f, y: h2 }, direction: 0 > z2[n].y === a.axisY.reversed ? 1 : -1, color: e });
                    }
                }
                d();
                c.moveTo(f, h2);
                r && x.moveTo(f, h2);
              }
              delete A.dataPointIndexes;
            }
            ia.drawMarkers(l);
            r && (b.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(k.x1, k.y1, k.width, k.height), x.restore());
            c.restore();
            return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };
          }
        };
        p.prototype.renderBubble = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = this.plotArea, e = 0, g, k;
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(c.x1, c.y1, c.width, c.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());
            for (var l = -Infinity, w = Infinity, m = 0; m < a.dataSeriesIndexes.length; m++)
              for (var s = a.dataSeriesIndexes[m], q = this.data[s], n = q.dataPoints, f = 0, e = 0; e < n.length; e++)
                g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax || "undefined" === typeof n[e].z || (f = n[e].z, f > l && (l = f), f < w && (w = f));
            for (var h2 = 25 * Math.PI, p2 = Math.max(Math.pow(0.25 * Math.min(c.height, c.width) / 2, 2) * Math.PI, h2), m = 0; m < a.dataSeriesIndexes.length; m++)
              if (s = a.dataSeriesIndexes[m], q = this.data[s], n = q.dataPoints, 0 < n.length) {
                for (b.strokeStyle = "#4572A7 ", e = 0; e < n.length; e++)
                  if (g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && "number" === typeof n[e].y) {
                    g = a.axisX.convertValueToPixel(g);
                    k = a.axisY.convertValueToPixel(n[e].y);
                    var f = n[e].z, u2 = 2 * Math.max(Math.sqrt((l === w ? p2 / 2 : h2 + (p2 - h2) / (l - w) * (f - w)) / Math.PI) << 0, 1), f = q.getMarkerProperties(e, b);
                    f.size = u2;
                    b.globalAlpha = q.fillOpacity;
                    ia.drawMarker(g, k, b, f.type, f.size, f.color, f.borderColor, f.borderThickness);
                    b.globalAlpha = 1;
                    var t = q.dataPointIds[e];
                    this._eventManager.objectMap[t] = {
                      id: t,
                      objectType: "dataPoint",
                      dataSeriesIndex: s,
                      dataPointIndex: e,
                      x1: g,
                      y1: k,
                      size: u2
                    };
                    u2 = N(t);
                    r && ia.drawMarker(g, k, this._eventManager.ghostCtx, f.type, f.size, u2, u2, f.borderThickness);
                    (n[e].indexLabel || q.indexLabel || n[e].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({ chartType: "bubble", dataPoint: n[e], dataSeries: q, point: { x: g, y: k }, direction: 1, bounds: { x1: g - f.size / 2, y1: k - f.size / 2, x2: g + f.size / 2, y2: k + f.size / 2 }, color: null });
                  }
              }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        p.prototype.renderScatter = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = this.plotArea, e = 0, g, k;
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(c.x1, c.y1, c.width, c.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());
            for (var l = 0; l < a.dataSeriesIndexes.length; l++) {
              var w = a.dataSeriesIndexes[l], m = this.data[w], s = m.dataPoints;
              if (0 < s.length) {
                b.strokeStyle = "#4572A7 ";
                Math.pow(0.3 * Math.min(c.height, c.width) / 2, 2);
                for (var q = 0, n = 0, e = 0; e < s.length; e++)
                  if (g = s[e].getTime ? g = s[e].x.getTime() : g = s[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[e].y) {
                    g = a.axisX.convertValueToPixel(g);
                    k = a.axisY.convertValueToPixel(s[e].y);
                    var f = m.getMarkerProperties(e, g, k, b);
                    b.globalAlpha = m.fillOpacity;
                    ia.drawMarker(f.x, f.y, f.ctx, f.type, f.size, f.color, f.borderColor, f.borderThickness);
                    b.globalAlpha = 1;
                    Math.sqrt((q - g) * (q - g) + (n - k) * (n - k)) < Math.min(
                      f.size,
                      5
                    ) && s.length > Math.min(this.plotArea.width, this.plotArea.height) || (q = m.dataPointIds[e], this._eventManager.objectMap[q] = { id: q, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: e, x1: g, y1: k }, q = N(q), r && ia.drawMarker(f.x, f.y, this._eventManager.ghostCtx, f.type, f.size, q, q, f.borderThickness), (s[e].indexLabel || m.indexLabel || s[e].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "scatter", dataPoint: s[e], dataSeries: m, point: { x: g, y: k }, direction: 1, bounds: { x1: g - f.size / 2, y1: k - f.size / 2, x2: g + f.size / 2, y2: k + f.size / 2 }, color: null }), q = g, n = k);
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        p.prototype.renderCandlestick = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d, c = this._eventManager.ghostCtx;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, g = null, k = this.plotArea, l = 0, w, m, s, q, n, f, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, h2 = a.axisX.dataInfo.minDiff;
            isFinite(h2) || (h2 = 0.3 * Math.abs(a.axisX.range));
            h2 = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * k.width * (a.axisX.logarithmic ? Math.log(h2) / Math.log(a.axisX.range) : Math.abs(h2) / Math.abs(a.axisX.range)) << 0;
            this.dataPointMaxWidth && e > g && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < e) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
            h2 < e && (h2 = e);
            h2 > g && (h2 = g);
            b.save();
            r && c.save();
            b.beginPath();
            b.rect(k.x1, k.y1, k.width, k.height);
            b.clip();
            r && (c.beginPath(), c.rect(k.x1, k.y1, k.width, k.height), c.clip());
            for (var p2 = 0; p2 < a.dataSeriesIndexes.length; p2++) {
              var v3 = a.dataSeriesIndexes[p2], t = this.data[v3], C = t.dataPoints;
              if (0 < C.length) {
                for (var x = 5 < h2 && t.bevelEnabled ? true : false, l = 0; l < C.length; l++)
                  if (C[l].getTime ? f = C[l].x.getTime() : f = C[l].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && !u(C[l].y) && C[l].y.length && "number" === typeof C[l].y[0] && "number" === typeof C[l].y[1] && "number" === typeof C[l].y[2] && "number" === typeof C[l].y[3]) {
                    w = a.axisX.convertValueToPixel(f);
                    m = a.axisY.convertValueToPixel(C[l].y[0]);
                    s = a.axisY.convertValueToPixel(C[l].y[1]);
                    q = a.axisY.convertValueToPixel(C[l].y[2]);
                    n = a.axisY.convertValueToPixel(C[l].y[3]);
                    var z2 = w - h2 / 2 << 0, y = z2 + h2 << 0, g = t.options.fallingColor ? t.fallingColor : t._colorSet[0], e = C[l].color ? C[l].color : t._colorSet[0], A = Math.round(Math.max(1, 0.15 * h2)), D = 0 === A % 2 ? 0 : 0.5, aa = t.dataPointIds[l];
                    this._eventManager.objectMap[aa] = { id: aa, objectType: "dataPoint", dataSeriesIndex: v3, dataPointIndex: l, x1: z2, y1: m, x2: y, y2: s, x3: w, y3: q, x4: w, y4: n, borderThickness: A, color: e };
                    b.strokeStyle = e;
                    b.beginPath();
                    b.lineWidth = A;
                    c.lineWidth = Math.max(A, 4);
                    "candlestick" === t.type ? (b.moveTo(w - D, s), b.lineTo(w - D, Math.min(m, n)), b.stroke(), b.moveTo(w - D, Math.max(m, n)), b.lineTo(w - D, q), b.stroke(), ea(b, z2, Math.min(m, n), y, Math.max(m, n), C[l].y[0] <= C[l].y[3] ? t.risingColor : g, A, e, x, x, false, false, t.fillOpacity), r && (e = N(aa), c.strokeStyle = e, c.moveTo(w - D, s), c.lineTo(w - D, Math.min(m, n)), c.stroke(), c.moveTo(w - D, Math.max(m, n)), c.lineTo(w - D, q), c.stroke(), ea(c, z2, Math.min(m, n), y, Math.max(m, n), e, 0, null, false, false, false, false))) : "ohlc" === t.type && (b.moveTo(w - D, s), b.lineTo(w - D, q), b.stroke(), b.beginPath(), b.moveTo(w, m), b.lineTo(z2, m), b.stroke(), b.beginPath(), b.moveTo(w, n), b.lineTo(y, n), b.stroke(), r && (e = N(aa), c.strokeStyle = e, c.moveTo(w - D, s), c.lineTo(w - D, q), c.stroke(), c.beginPath(), c.moveTo(w, m), c.lineTo(z2, m), c.stroke(), c.beginPath(), c.moveTo(w, n), c.lineTo(y, n), c.stroke()));
                    (C[l].indexLabel || t.indexLabel || C[l].indexLabelFormatter || t.indexLabelFormatter) && this._indexLabels.push({ chartType: t.type, dataPoint: C[l], dataSeries: t, point: { x: z2 + (y - z2) / 2, y: a.axisY.reversed ? q : s }, direction: 1, bounds: { x1: z2, y1: Math.min(s, q), x2: y, y2: Math.max(s, q) }, color: e });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(
              a.axisY.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(k.x1, k.y1, k.width, k.height), c.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        p.prototype.renderBoxAndWhisker = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d, c = this._eventManager.ghostCtx;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, g = this.plotArea, k = 0, l, w, m, s, q, n, f, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, k = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, h2 = a.axisX.dataInfo.minDiff;
            isFinite(h2) || (h2 = 0.3 * Math.abs(a.axisX.range));
            h2 = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * g.width * (a.axisX.logarithmic ? Math.log(h2) / Math.log(a.axisX.range) : Math.abs(h2) / Math.abs(a.axisX.range)) << 0;
            this.dataPointMaxWidth && e > k && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && k < e) && (k = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
            h2 < e && (h2 = e);
            h2 > k && (h2 = k);
            b.save();
            r && c.save();
            b.beginPath();
            b.rect(g.x1, g.y1, g.width, g.height);
            b.clip();
            r && (c.beginPath(), c.rect(g.x1, g.y1, g.width, g.height), c.clip());
            for (var p2 = false, p2 = !!a.axisY.reversed, v3 = 0; v3 < a.dataSeriesIndexes.length; v3++) {
              var t = a.dataSeriesIndexes[v3], C = this.data[t], x = C.dataPoints;
              if (0 < x.length) {
                for (var z2 = 5 < h2 && C.bevelEnabled ? true : false, k = 0; k < x.length; k++)
                  if (x[k].getTime ? f = x[k].x.getTime() : f = x[k].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && !u(x[k].y) && x[k].y.length && "number" === typeof x[k].y[0] && "number" === typeof x[k].y[1] && "number" === typeof x[k].y[2] && "number" === typeof x[k].y[3] && "number" === typeof x[k].y[4] && 5 === x[k].y.length) {
                    l = a.axisX.convertValueToPixel(f);
                    w = a.axisY.convertValueToPixel(x[k].y[0]);
                    m = a.axisY.convertValueToPixel(x[k].y[1]);
                    s = a.axisY.convertValueToPixel(x[k].y[2]);
                    q = a.axisY.convertValueToPixel(x[k].y[3]);
                    n = a.axisY.convertValueToPixel(x[k].y[4]);
                    var y = l - h2 / 2 << 0, A = l + h2 / 2 << 0, e = x[k].color ? x[k].color : C._colorSet[0], D = Math.round(Math.max(1, 0.15 * h2)), aa = 0 === D % 2 ? 0 : 0.5, T = x[k].whiskerColor ? x[k].whiskerColor : x[k].color ? C.whiskerColor ? C.whiskerColor : x[k].color : C.whiskerColor ? C.whiskerColor : e, Y = "number" === typeof x[k].whiskerThickness ? x[k].whiskerThickness : "number" === typeof C.options.whiskerThickness ? C.whiskerThickness : D, ca = x[k].whiskerDashType ? x[k].whiskerDashType : C.whiskerDashType, da = u(x[k].whiskerLength) ? u(C.options.whiskerLength) ? h2 : C.whiskerLength : x[k].whiskerLength, da = "number" === typeof da ? 0 >= da ? 0 : da >= h2 ? h2 : da : "string" === typeof da ? parseInt(da) * h2 / 100 > h2 ? h2 : parseInt(da) * h2 / 100 : h2, Z = 1 === Math.round(Y) % 2 ? 0.5 : 0, oa = x[k].stemColor ? x[k].stemColor : x[k].color ? C.stemColor ? C.stemColor : x[k].color : C.stemColor ? C.stemColor : e, la = "number" === typeof x[k].stemThickness ? x[k].stemThickness : "number" === typeof C.options.stemThickness ? C.stemThickness : D, G = 1 === Math.round(la) % 2 ? 0.5 : 0, F2 = x[k].stemDashType ? x[k].stemDashType : C.stemDashType, E3 = x[k].lineColor ? x[k].lineColor : x[k].color ? C.lineColor ? C.lineColor : x[k].color : C.lineColor ? C.lineColor : e, H2 = "number" === typeof x[k].lineThickness ? x[k].lineThickness : "number" === typeof C.options.lineThickness ? C.lineThickness : D, I3 = x[k].lineDashType ? x[k].lineDashType : C.lineDashType, K = 1 === Math.round(H2) % 2 ? 0.5 : 0, L2 = C.upperBoxColor, O2 = C.lowerBoxColor, Q3 = u(C.options.fillOpacity) ? 1 : C.fillOpacity, P = C.dataPointIds[k];
                    this._eventManager.objectMap[P] = {
                      id: P,
                      objectType: "dataPoint",
                      dataSeriesIndex: t,
                      dataPointIndex: k,
                      x1: y,
                      y1: w,
                      x2: A,
                      y2: m,
                      x3: l,
                      y3: s,
                      x4: l,
                      y4: q,
                      y5: n,
                      borderThickness: D,
                      color: e,
                      stemThickness: la,
                      stemColor: oa,
                      whiskerThickness: Y,
                      whiskerLength: da,
                      whiskerColor: T,
                      lineThickness: H2,
                      lineColor: E3
                    };
                    b.save();
                    0 < la && (b.beginPath(), b.strokeStyle = oa, b.lineWidth = la, b.setLineDash && b.setLineDash(R(F2, la)), b.moveTo(l - G, m), b.lineTo(l - G, w), b.stroke(), b.moveTo(l - G, q), b.lineTo(l - G, s), b.stroke());
                    b.restore();
                    c.lineWidth = Math.max(D, 4);
                    b.beginPath();
                    ea(b, y, Math.min(n, m), A, Math.max(m, n), O2, 0, e, p2 ? z2 : false, p2 ? false : z2, false, false, Q3);
                    b.beginPath();
                    ea(
                      b,
                      y,
                      Math.min(s, n),
                      A,
                      Math.max(n, s),
                      L2,
                      0,
                      e,
                      p2 ? false : z2,
                      p2 ? z2 : false,
                      false,
                      false,
                      Q3
                    );
                    b.beginPath();
                    b.lineWidth = D;
                    b.strokeStyle = e;
                    b.rect(y - aa, Math.min(m, s) - aa, A - y + 2 * aa, Math.max(m, s) - Math.min(m, s) + 2 * aa);
                    b.stroke();
                    b.save();
                    0 < H2 && (b.beginPath(), b.globalAlpha = 1, b.setLineDash && b.setLineDash(R(I3, H2)), b.strokeStyle = E3, b.lineWidth = H2, b.moveTo(y, n - K), b.lineTo(A, n - K), b.stroke());
                    b.restore();
                    b.save();
                    0 < Y && (b.beginPath(), b.setLineDash && b.setLineDash(R(ca, Y)), b.strokeStyle = T, b.lineWidth = Y, b.moveTo(l - da / 2 << 0, q - Z), b.lineTo(l + da / 2 << 0, q - Z), b.stroke(), b.moveTo(l - da / 2 << 0, w + Z), b.lineTo(l + da / 2 << 0, w + Z), b.stroke());
                    b.restore();
                    r && (e = N(P), c.strokeStyle = e, c.lineWidth = la, 0 < la && (c.moveTo(l - aa - G, m), c.lineTo(l - aa - G, Math.max(w, q)), c.stroke(), c.moveTo(l - aa - G, Math.min(w, q)), c.lineTo(l - aa - G, s), c.stroke()), ea(c, y, Math.max(m, s), A, Math.min(m, s), e, 0, null, false, false, false, false), 0 < Y && (c.beginPath(), c.lineWidth = Y, c.moveTo(l + da / 2, q - Z), c.lineTo(l - da / 2, q - Z), c.stroke(), c.moveTo(l + da / 2, w + Z), c.lineTo(l - da / 2, w + Z), c.stroke()));
                    (x[k].indexLabel || C.indexLabel || x[k].indexLabelFormatter || C.indexLabelFormatter) && this._indexLabels.push({ chartType: C.type, dataPoint: x[k], dataSeries: C, point: { x: y + (A - y) / 2, y: a.axisY.reversed ? w : q }, direction: 1, bounds: { x1: y, y1: Math.min(w, q), x2: A, y2: Math.max(w, q) }, color: e });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), b.clearRect(g.x1, g.y1, g.width, g.height), c.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        p.prototype.renderRangeColumn = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = 0, k, l, w, g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            k = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;
            var m = a.axisX.dataInfo.minDiff;
            isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));
            m = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && g > k && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && k < g) && (k = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g));
            m < g && (m = g);
            m > k && (m = k);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var s = 0; s < a.dataSeriesIndexes.length; s++) {
              var q = a.dataSeriesIndexes[s], n = this.data[q], f = n.dataPoints;
              if (0 < f.length) {
                for (var h2 = 5 < m && n.bevelEnabled ? true : false, g = 0; g < f.length; g++)
                  if (f[g].getTime ? w = f[g].x.getTime() : w = f[g].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && !u(f[g].y) && f[g].y.length && "number" === typeof f[g].y[0] && "number" === typeof f[g].y[1]) {
                    c = a.axisX.convertValueToPixel(w);
                    k = a.axisY.convertValueToPixel(f[g].y[0]);
                    l = a.axisY.convertValueToPixel(f[g].y[1]);
                    var p2 = a.axisX.reversed ? c + a.plotType.totalDataSeries * m / 2 - (a.previousDataSeriesCount + s) * m << 0 : c - a.plotType.totalDataSeries * m / 2 + (a.previousDataSeriesCount + s) * m << 0, v3 = a.axisX.reversed ? p2 - m << 0 : p2 + m << 0, c = f[g].color ? f[g].color : n._colorSet[g % n._colorSet.length];
                    if (k > l) {
                      var t = k;
                      k = l;
                      l = t;
                    }
                    t = n.dataPointIds[g];
                    this._eventManager.objectMap[t] = { id: t, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: g, x1: p2, y1: k, x2: v3, y2: l };
                    ea(b, p2, k, v3, l, c, 0, c, h2, h2, false, false, n.fillOpacity);
                    c = N(t);
                    r && ea(this._eventManager.ghostCtx, p2, k, v3, l, c, 0, null, false, false, false, false);
                    if (f[g].indexLabel || n.indexLabel || f[g].indexLabelFormatter || n.indexLabelFormatter)
                      this._indexLabels.push({
                        chartType: "rangeColumn",
                        dataPoint: f[g],
                        dataSeries: n,
                        indexKeyword: 0,
                        point: { x: p2 + (v3 - p2) / 2, y: f[g].y[1] >= f[g].y[0] ? l : k },
                        direction: f[g].y[1] >= f[g].y[0] ? -1 : 1,
                        bounds: { x1: p2, y1: Math.min(k, l), x2: v3, y2: Math.max(k, l) },
                        color: c
                      }), this._indexLabels.push({ chartType: "rangeColumn", dataPoint: f[g], dataSeries: n, indexKeyword: 1, point: { x: p2 + (v3 - p2) / 2, y: f[g].y[1] >= f[g].y[0] ? k : l }, direction: f[g].y[1] >= f[g].y[0] ? 1 : -1, bounds: { x1: p2, y1: Math.min(k, l), x2: v3, y2: Math.max(k, l) }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        p.prototype.renderError = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d, c = a.axisY._position ? "left" === a.axisY._position || "right" === a.axisY._position ? false : true : false;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, g = false, k = this.plotArea, l = 0, w, m, s, q, n, f, h2, p2 = a.axisX.dataInfo.minDiff;
            isFinite(p2) || (p2 = 0.3 * Math.abs(a.axisX.range));
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(k.x1, k.y1, k.width, k.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(
              k.x1,
              k.y1,
              k.width,
              k.height
            ), this._eventManager.ghostCtx.clip());
            for (var v3 = 0, t = 0; t < this.data.length; t++)
              !this.data[t].type.match(/(bar|column)/ig) || !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && v3 || v3++;
            for (var C = 0; C < a.dataSeriesIndexes.length; C++) {
              var x = a.dataSeriesIndexes[C], z2 = this.data[x], y = z2.dataPoints, A = u(z2._linkedSeries) ? false : z2._linkedSeries.type.match(/(bar|column)/ig) && z2._linkedSeries.visible ? true : false, D = 0;
              if (A)
                for (e = z2._linkedSeries.id, t = 0; t < e; t++)
                  !this.data[t].type.match(/(bar|column)/ig) || !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && D || (this.data[t].type.match(/(range)/ig) && (g = true), D++);
              e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
              l = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? v3 : 1))) << 0 : 0.3 * this.width;
              g && (l = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? v3 : 1))) << 0 : 0.03 * this.width);
              t = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((c ? k.height : k.width) * (a.axisX.logarithmic ? Math.log(p2) / Math.log(a.axisX.range) : Math.abs(p2) / Math.abs(a.axisX.range)) / (A ? v3 : 1)) << 0;
              this.dataPointMaxWidth && e > l && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l));
              !this.dataPointMaxWidth && (this.dataPointMinWidth && l < e) && (l = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
              t < e && (t = e);
              t > l && (t = l);
              if (0 < y.length)
                for (var aa = z2._colorSet, l = 0; l < y.length; l++) {
                  var e = z2.lineColor = z2.options.color ? z2.options.color : aa[0], T = {
                    color: y[l].whiskerColor ? y[l].whiskerColor : y[l].color ? z2.whiskerColor ? z2.whiskerColor : y[l].color : z2.whiskerColor ? z2.whiskerColor : e,
                    thickness: u(y[l].whiskerThickness) ? z2.whiskerThickness : y[l].whiskerThickness,
                    dashType: y[l].whiskerDashType ? y[l].whiskerDashType : z2.whiskerDashType,
                    length: u(y[l].whiskerLength) ? u(z2.options.whiskerLength) ? t : z2.options.whiskerLength : y[l].whiskerLength,
                    trimLength: u(y[l].whiskerLength) ? u(z2.options.whiskerLength) ? 50 : 0 : 0
                  };
                  T.length = "number" === typeof T.length ? 0 >= T.length ? 0 : T.length >= t ? t : T.length : "string" === typeof T.length ? parseInt(T.length) * t / 100 > t ? t : parseInt(T.length) * t / 100 > t : t;
                  T.thickness = "number" === typeof T.thickness ? 0 > T.thickness ? 0 : Math.round(T.thickness) : 2;
                  var Y = { color: y[l].stemColor ? y[l].stemColor : y[l].color ? z2.stemColor ? z2.stemColor : y[l].color : z2.stemColor ? z2.stemColor : e, thickness: y[l].stemThickness ? y[l].stemThickness : z2.stemThickness, dashType: y[l].stemDashType ? y[l].stemDashType : z2.stemDashType };
                  Y.thickness = "number" === typeof Y.thickness ? 0 > Y.thickness ? 0 : Math.round(Y.thickness) : 2;
                  y[l].getTime ? h2 = y[l].x.getTime() : h2 = y[l].x;
                  if (!(h2 < a.axisX.dataInfo.viewPortMin || h2 > a.axisX.dataInfo.viewPortMax) && !u(y[l].y) && y[l].y.length && "number" === typeof y[l].y[0] && "number" === typeof y[l].y[1]) {
                    var ca = a.axisX.convertValueToPixel(h2);
                    c ? m = ca : w = ca;
                    ca = a.axisY.convertValueToPixel(y[l].y[0]);
                    c ? s = ca : n = ca;
                    ca = a.axisY.convertValueToPixel(y[l].y[1]);
                    c ? q = ca : f = ca;
                    c ? (n = a.axisX.reversed ? m + (A ? v3 : 1) * t / 2 - (A ? D - 1 : 0) * t << 0 : m - (A ? v3 : 1) * t / 2 + (A ? D - 1 : 0) * t << 0, f = a.axisX.reversed ? n - t << 0 : n + t << 0) : (s = a.axisX.reversed ? w + (A ? v3 : 1) * t / 2 - (A ? D - 1 : 0) * t << 0 : w - (A ? v3 : 1) * t / 2 + (A ? D - 1 : 0) * t << 0, q = a.axisX.reversed ? s - t << 0 : s + t << 0);
                    !c && n > f && (ca = n, n = f, f = ca);
                    c && s > q && (ca = s, s = q, q = ca);
                    ca = z2.dataPointIds[l];
                    this._eventManager.objectMap[ca] = { id: ca, objectType: "dataPoint", dataSeriesIndex: x, dataPointIndex: l, x1: Math.min(s, q), y1: Math.min(n, f), x2: Math.max(q, s), y2: Math.max(f, n), isXYSwapped: c, stemProperties: Y, whiskerProperties: T };
                    E2(
                      b,
                      Math.min(s, q),
                      Math.min(n, f),
                      Math.max(q, s),
                      Math.max(f, n),
                      e,
                      T,
                      Y,
                      c
                    );
                    r && E2(this._eventManager.ghostCtx, s, n, q, f, e, T, Y, c);
                    if (y[l].indexLabel || z2.indexLabel || y[l].indexLabelFormatter || z2.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "error", dataPoint: y[l], dataSeries: z2, indexKeyword: 0, point: { x: c ? y[l].y[1] >= y[l].y[0] ? s : q : s + (q - s) / 2, y: c ? n + (f - n) / 2 : y[l].y[1] >= y[l].y[0] ? f : n }, direction: y[l].y[1] >= y[l].y[0] ? -1 : 1, bounds: { x1: c ? Math.min(s, q) : s, y1: c ? n : Math.min(n, f), x2: c ? Math.max(s, q) : q, y2: c ? f : Math.max(n, f) }, color: e, axisSwapped: c }), this._indexLabels.push({ chartType: "error", dataPoint: y[l], dataSeries: z2, indexKeyword: 1, point: { x: c ? y[l].y[1] >= y[l].y[0] ? q : s : s + (q - s) / 2, y: c ? n + (f - n) / 2 : y[l].y[1] >= y[l].y[0] ? n : f }, direction: y[l].y[1] >= y[l].y[0] ? 1 : -1, bounds: { x1: c ? Math.min(s, q) : s, y1: c ? n : Math.min(n, f), x2: c ? Math.max(s, q) : q, y2: c ? f : Math.max(n, f) }, color: e, axisSwapped: c });
                  }
                }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        p.prototype.renderRangeBar = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = null, e = this.plotArea, g = 0, k, l, w, m, g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            k = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;
            var s = a.axisX.dataInfo.minDiff;
            isFinite(s) || (s = 0.3 * Math.abs(a.axisX.range));
            s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(s) / Math.log(a.axisX.range) : Math.abs(s) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && g > k && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && k < g) && (k = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g));
            s < g && (s = g);
            s > k && (s = k);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(e.x1, e.y1, e.width, e.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var q = 0; q < a.dataSeriesIndexes.length; q++) {
              var n = a.dataSeriesIndexes[q], f = this.data[n], h2 = f.dataPoints;
              if (0 < h2.length) {
                var p2 = 5 < s && f.bevelEnabled ? true : false;
                b.strokeStyle = "#4572A7 ";
                for (g = 0; g < h2.length; g++)
                  if (h2[g].getTime ? m = h2[g].x.getTime() : m = h2[g].x, !(m < a.axisX.dataInfo.viewPortMin || m > a.axisX.dataInfo.viewPortMax) && !u(h2[g].y) && h2[g].y.length && "number" === typeof h2[g].y[0] && "number" === typeof h2[g].y[1]) {
                    k = a.axisY.convertValueToPixel(h2[g].y[0]);
                    l = a.axisY.convertValueToPixel(h2[g].y[1]);
                    w = a.axisX.convertValueToPixel(m);
                    w = a.axisX.reversed ? w + a.plotType.totalDataSeries * s / 2 - (a.previousDataSeriesCount + q) * s << 0 : w - a.plotType.totalDataSeries * s / 2 + (a.previousDataSeriesCount + q) * s << 0;
                    var v3 = a.axisX.reversed ? w - s << 0 : w + s << 0;
                    k > l && (c = k, k = l, l = c);
                    c = h2[g].color ? h2[g].color : f._colorSet[g % f._colorSet.length];
                    ea(b, k, w, l, v3, c, 0, null, p2, false, false, false, f.fillOpacity);
                    c = f.dataPointIds[g];
                    this._eventManager.objectMap[c] = {
                      id: c,
                      objectType: "dataPoint",
                      dataSeriesIndex: n,
                      dataPointIndex: g,
                      x1: k,
                      y1: w,
                      x2: l,
                      y2: v3
                    };
                    c = N(c);
                    r && ea(this._eventManager.ghostCtx, k, w, l, v3, c, 0, null, false, false, false, false);
                    if (h2[g].indexLabel || f.indexLabel || h2[g].indexLabelFormatter || f.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "rangeBar", dataPoint: h2[g], dataSeries: f, indexKeyword: 0, point: { x: h2[g].y[1] >= h2[g].y[0] ? k : l, y: w + (v3 - w) / 2 }, direction: h2[g].y[1] >= h2[g].y[0] ? -1 : 1, bounds: { x1: Math.min(k, l), y1: w, x2: Math.max(k, l), y2: v3 }, color: c }), this._indexLabels.push({ chartType: "rangeBar", dataPoint: h2[g], dataSeries: f, indexKeyword: 1, point: { x: h2[g].y[1] >= h2[g].y[0] ? l : k, y: w + (v3 - w) / 2 }, direction: h2[g].y[1] >= h2[g].y[0] ? 1 : -1, bounds: { x1: Math.min(k, l), y1: w, x2: Math.max(k, l), y2: v3 }, color: c });
                  }
              }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(
              e.x1,
              e.y1,
              e.width,
              e.height
            ), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        p.prototype.renderRangeArea = function(a) {
          function d() {
            if (C) {
              var a2 = null;
              0 < s.lineThickness && c.stroke();
              for (var b2 = w.length - 1; 0 <= b2; b2--)
                a2 = w[b2], c.lineTo(a2.x, a2.y), e.lineTo(a2.x, a2.y);
              c.closePath();
              c.globalAlpha = s.fillOpacity;
              c.fill();
              c.globalAlpha = 1;
              e.fill();
              if (0 < s.lineThickness) {
                c.beginPath();
                c.moveTo(
                  a2.x,
                  a2.y
                );
                for (b2 = 0; b2 < w.length; b2++)
                  a2 = w[b2], c.lineTo(a2.x, a2.y);
                c.stroke();
              }
              c.beginPath();
              c.moveTo(h2, p2);
              e.beginPath();
              e.moveTo(h2, p2);
              C = { x: h2, y: p2 };
              w = [];
              w.push({ x: h2, y: u2 });
            }
          }
          var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, g = [], k = this.plotArea;
            c.save();
            r && e.save();
            c.beginPath();
            c.rect(k.x1, k.y1, k.width, k.height);
            c.clip();
            r && (e.beginPath(), e.rect(k.x1, k.y1, k.width, k.height), e.clip());
            for (var l = 0; l < a.dataSeriesIndexes.length; l++) {
              var w = [], m = a.dataSeriesIndexes[l], s = this.data[m], q = s.dataPoints, g = s.id;
              this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: m };
              g = N(g);
              e.fillStyle = g;
              var g = [], n = true, f = 0, h2, p2, u2, t, C = null;
              if (0 < q.length) {
                var x = s._colorSet[f % s._colorSet.length], v3 = s.lineColor = s.options.lineColor || x, y = v3;
                c.fillStyle = x;
                c.strokeStyle = v3;
                c.lineWidth = s.lineThickness;
                var A = "solid";
                if (c.setLineDash) {
                  var z2 = R(s.nullDataLineDashType, s.lineThickness), A = s.lineDashType, D = R(A, s.lineThickness);
                  c.setLineDash(D);
                }
                for (var T = true; f < q.length; f++)
                  if (t = q[f].x.getTime ? q[f].x.getTime() : q[f].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!s.connectNullData || !T)))
                    if (null !== q[f].y && q[f].y.length && "number" === typeof q[f].y[0] && "number" === typeof q[f].y[1]) {
                      h2 = a.axisX.convertValueToPixel(t);
                      p2 = a.axisY.convertValueToPixel(q[f].y[0]);
                      u2 = a.axisY.convertValueToPixel(q[f].y[1]);
                      n || T ? (s.connectNullData && !n ? (c.setLineDash && (s.options.nullDataLineDashType || A === s.lineDashType && s.lineDashType !== s.nullDataLineDashType) && (w[w.length - 1].newLineDashArray = D, A = s.nullDataLineDashType, c.setLineDash(z2)), c.lineTo(h2, p2), r && e.lineTo(h2, p2), w.push({ x: h2, y: u2 })) : (c.beginPath(), c.moveTo(h2, p2), C = { x: h2, y: p2 }, w = [], w.push({ x: h2, y: u2 }), r && (e.beginPath(), e.moveTo(h2, p2))), T = n = false) : (c.lineTo(h2, p2), w.push({ x: h2, y: u2 }), r && e.lineTo(h2, p2), 0 == f % 250 && d());
                      t = s.dataPointIds[f];
                      this._eventManager.objectMap[t] = { id: t, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: f, x1: h2, y1: p2, y2: u2 };
                      f < q.length - 1 && (y !== (q[f].lineColor || v3) || A !== (q[f].lineDashType || s.lineDashType)) && (d(), y = q[f].lineColor || v3, w[w.length - 1].newStrokeStyle = y, c.strokeStyle = y, c.setLineDash && (q[f].lineDashType ? (A = q[f].lineDashType, w[w.length - 1].newLineDashArray = R(A, s.lineThickness), c.setLineDash(w[w.length - 1].newLineDashArray)) : (A = s.lineDashType, w[w.length - 1].newLineDashArray = D, c.setLineDash(D))));
                      if (0 !== q[f].markerSize && (0 < q[f].markerSize || 0 < s.markerSize)) {
                        var Y = s.getMarkerProperties(f, h2, u2, c);
                        g.push(Y);
                        var ca = N(t);
                        r && g.push({ x: h2, y: u2, ctx: e, type: Y.type, size: Y.size, color: ca, borderColor: ca, borderThickness: Y.borderThickness });
                        Y = s.getMarkerProperties(f, h2, p2, c);
                        g.push(Y);
                        ca = N(t);
                        r && g.push({ x: h2, y: p2, ctx: e, type: Y.type, size: Y.size, color: ca, borderColor: ca, borderThickness: Y.borderThickness });
                      }
                      if (q[f].indexLabel || s.indexLabel || q[f].indexLabelFormatter || s.indexLabelFormatter)
                        this._indexLabels.push({ chartType: "rangeArea", dataPoint: q[f], dataSeries: s, indexKeyword: 0, point: { x: h2, y: p2 }, direction: q[f].y[0] > q[f].y[1] === a.axisY.reversed ? -1 : 1, color: x }), this._indexLabels.push({ chartType: "rangeArea", dataPoint: q[f], dataSeries: s, indexKeyword: 1, point: {
                          x: h2,
                          y: u2
                        }, direction: q[f].y[0] > q[f].y[1] === a.axisY.reversed ? 1 : -1, color: x });
                    } else
                      T || n || d(), T = true;
                d();
                ia.drawMarkers(g);
              }
            }
            r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(
              k.x1,
              k.y1,
              k.width,
              k.height
            ), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };
          }
        };
        p.prototype.renderRangeSplineArea = function(a) {
          function d(a2, b2) {
            var d2 = v2(u2, 2);
            if (0 < d2.length) {
              if (0 < m.lineThickness) {
                c.strokeStyle = b2;
                c.setLineDash && c.setLineDash(a2);
                c.beginPath();
                c.moveTo(d2[0].x, d2[0].y);
                for (var f2 = 0; f2 < d2.length - 3; f2 += 3) {
                  if (d2[f2].newStrokeStyle || d2[f2].newLineDashArray)
                    c.stroke(), c.beginPath(), c.moveTo(
                      d2[f2].x,
                      d2[f2].y
                    ), d2[f2].newStrokeStyle && (c.strokeStyle = d2[f2].newStrokeStyle), d2[f2].newLineDashArray && c.setLineDash(d2[f2].newLineDashArray);
                  c.bezierCurveTo(d2[f2 + 1].x, d2[f2 + 1].y, d2[f2 + 2].x, d2[f2 + 2].y, d2[f2 + 3].x, d2[f2 + 3].y);
                }
                c.stroke();
              }
              c.beginPath();
              c.moveTo(d2[0].x, d2[0].y);
              r && (e.beginPath(), e.moveTo(d2[0].x, d2[0].y));
              for (f2 = 0; f2 < d2.length - 3; f2 += 3)
                c.bezierCurveTo(d2[f2 + 1].x, d2[f2 + 1].y, d2[f2 + 2].x, d2[f2 + 2].y, d2[f2 + 3].x, d2[f2 + 3].y), r && e.bezierCurveTo(d2[f2 + 1].x, d2[f2 + 1].y, d2[f2 + 2].x, d2[f2 + 2].y, d2[f2 + 3].x, d2[f2 + 3].y);
              d2 = v2(z2, 2);
              c.lineTo(z2[z2.length - 1].x, z2[z2.length - 1].y);
              for (f2 = d2.length - 1; 2 < f2; f2 -= 3)
                c.bezierCurveTo(d2[f2 - 1].x, d2[f2 - 1].y, d2[f2 - 2].x, d2[f2 - 2].y, d2[f2 - 3].x, d2[f2 - 3].y), r && e.bezierCurveTo(d2[f2 - 1].x, d2[f2 - 1].y, d2[f2 - 2].x, d2[f2 - 2].y, d2[f2 - 3].x, d2[f2 - 3].y);
              c.closePath();
              c.globalAlpha = m.fillOpacity;
              c.fill();
              r && (e.closePath(), e.fill());
              c.globalAlpha = 1;
              if (0 < m.lineThickness) {
                c.strokeStyle = b2;
                c.setLineDash && c.setLineDash(a2);
                c.beginPath();
                c.moveTo(d2[0].x, d2[0].y);
                for (var g2 = f2 = 0; f2 < d2.length - 3; f2 += 3, g2++) {
                  if (u2[g2].newStrokeStyle || u2[g2].newLineDashArray)
                    c.stroke(), c.beginPath(), c.moveTo(
                      d2[f2].x,
                      d2[f2].y
                    ), u2[g2].newStrokeStyle && (c.strokeStyle = u2[g2].newStrokeStyle), u2[g2].newLineDashArray && c.setLineDash(u2[g2].newLineDashArray);
                  c.bezierCurveTo(d2[f2 + 1].x, d2[f2 + 1].y, d2[f2 + 2].x, d2[f2 + 2].y, d2[f2 + 3].x, d2[f2 + 3].y);
                }
                c.stroke();
              }
              c.beginPath();
            }
          }
          var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, g = [], k = this.plotArea;
            c.save();
            r && e.save();
            c.beginPath();
            c.rect(k.x1, k.y1, k.width, k.height);
            c.clip();
            r && (e.beginPath(), e.rect(
              k.x1,
              k.y1,
              k.width,
              k.height
            ), e.clip());
            for (var l = 0; l < a.dataSeriesIndexes.length; l++) {
              var w = a.dataSeriesIndexes[l], m = this.data[w], h2 = m.dataPoints, g = m.id;
              this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: w };
              g = N(g);
              e.fillStyle = g;
              var g = [], q = 0, n, f, p2, u2 = [], z2 = [];
              if (0 < h2.length) {
                var t = m._colorSet[q % m._colorSet.length], C = m.lineColor = m.options.lineColor || t, x = C;
                c.fillStyle = t;
                c.lineWidth = m.lineThickness;
                var F2 = "solid", y;
                if (c.setLineDash) {
                  var A = R(m.nullDataLineDashType, m.lineThickness), F2 = m.lineDashType;
                  y = R(
                    F2,
                    m.lineThickness
                  );
                }
                for (f = false; q < h2.length; q++)
                  if (n = h2[q].x.getTime ? h2[q].x.getTime() : h2[q].x, !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !f)))
                    if (null !== h2[q].y && h2[q].y.length && "number" === typeof h2[q].y[0] && "number" === typeof h2[q].y[1]) {
                      n = a.axisX.convertValueToPixel(n);
                      f = a.axisY.convertValueToPixel(h2[q].y[0]);
                      p2 = a.axisY.convertValueToPixel(h2[q].y[1]);
                      var E3 = m.dataPointIds[q];
                      this._eventManager.objectMap[E3] = {
                        id: E3,
                        objectType: "dataPoint",
                        dataSeriesIndex: w,
                        dataPointIndex: q,
                        x1: n,
                        y1: f,
                        y2: p2
                      };
                      u2[u2.length] = { x: n, y: f };
                      z2[z2.length] = { x: n, y: p2 };
                      q < h2.length - 1 && (x !== (h2[q].lineColor || C) || F2 !== (h2[q].lineDashType || m.lineDashType)) && (x = h2[q].lineColor || C, u2[u2.length - 1].newStrokeStyle = x, c.setLineDash && (h2[q].lineDashType ? (F2 = h2[q].lineDashType, u2[u2.length - 1].newLineDashArray = R(F2, m.lineThickness)) : (F2 = m.lineDashType, u2[u2.length - 1].newLineDashArray = y)));
                      if (0 !== h2[q].markerSize && (0 < h2[q].markerSize || 0 < m.markerSize)) {
                        var aa = m.getMarkerProperties(q, n, f, c);
                        g.push(aa);
                        var T = N(E3);
                        r && g.push({
                          x: n,
                          y: f,
                          ctx: e,
                          type: aa.type,
                          size: aa.size,
                          color: T,
                          borderColor: T,
                          borderThickness: aa.borderThickness
                        });
                        aa = m.getMarkerProperties(q, n, p2, c);
                        g.push(aa);
                        T = N(E3);
                        r && g.push({ x: n, y: p2, ctx: e, type: aa.type, size: aa.size, color: T, borderColor: T, borderThickness: aa.borderThickness });
                      }
                      if (h2[q].indexLabel || m.indexLabel || h2[q].indexLabelFormatter || m.indexLabelFormatter)
                        this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: h2[q], dataSeries: m, indexKeyword: 0, point: { x: n, y: f }, direction: h2[q].y[0] <= h2[q].y[1] ? -1 : 1, color: t }), this._indexLabels.push({
                          chartType: "rangeSplineArea",
                          dataPoint: h2[q],
                          dataSeries: m,
                          indexKeyword: 1,
                          point: { x: n, y: p2 },
                          direction: h2[q].y[0] <= h2[q].y[1] ? 1 : -1,
                          color: t
                        });
                      f = false;
                    } else
                      0 < q && !f && (m.connectNullData ? c.setLineDash && (0 < u2.length && (m.options.nullDataLineDashType || !h2[q - 1].lineDashType)) && (u2[u2.length - 1].newLineDashArray = A, F2 = m.nullDataLineDashType) : (d(y, C), u2 = [], z2 = [])), f = true;
                d(y, C);
                ia.drawMarkers(g);
              }
            }
            r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());
            c.restore();
            return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };
          }
        };
        p.prototype.renderWaterfall = function(a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = this._eventManager.ghostCtx, e = null, g = this.plotArea, k = 0, l, h2, m, s, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            h2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;
            var n = a.axisX.dataInfo.minDiff;
            isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));
            n = this.options.dataPointWidth ? this.dataPointWidth : 0.6 * (g.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && k > h2 && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, h2));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && h2 < k) && (h2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            n < k && (n = k);
            n > h2 && (n = h2);
            b.save();
            r && this._eventManager.ghostCtx.save();
            b.beginPath();
            b.rect(g.x1, g.y1, g.width, g.height);
            b.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip());
            for (var f = 0; f < a.dataSeriesIndexes.length; f++) {
              var p2 = a.dataSeriesIndexes[f], u2 = this.data[p2], v3 = u2.dataPoints, e = u2._colorSet[0];
              u2.risingColor = u2.options.risingColor ? u2.options.risingColor : e;
              u2.fallingColor = u2.options.fallingColor ? u2.options.fallingColor : "#e40a0a";
              var t = "number" === typeof u2.options.lineThickness ? Math.round(u2.lineThickness) : 1, C = 1 === Math.round(t) % 2 ? -0.5 : 0;
              if (0 < v3.length)
                for (var x = 5 < n && u2.bevelEnabled ? true : false, z2 = false, y = null, A = null, k = 0; k < v3.length; k++)
                  if (v3[k].getTime ? s = v3[k].x.getTime() : s = v3[k].x, "number" !== typeof v3[k].y) {
                    if (0 < k && !z2 && u2.connectNullData)
                      var D = u2.options.nullDataLineDashType || !v3[k - 1].lineDashType ? u2.nullDataLineDashType : v3[k - 1].lineDashType;
                    z2 = true;
                  } else {
                    l = a.axisX.convertValueToPixel(s);
                    h2 = 0 === u2.dataPointEOs[k].cumulativeSum ? q : a.axisY.convertValueToPixel(u2.dataPointEOs[k].cumulativeSum);
                    m = 0 === u2.dataPointEOs[k].cumulativeSumYStartValue ? q : a.axisY.convertValueToPixel(u2.dataPointEOs[k].cumulativeSumYStartValue);
                    l = a.axisX.reversed ? l + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + f) * n << 0 : l - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + f) * n << 0;
                    var F2 = a.axisX.reversed ? l - n << 0 : l + n << 0;
                    h2 > m && (e = h2, h2 = m, m = e);
                    a.axisY.reversed && (e = h2, h2 = m, m = e);
                    e = u2.dataPointIds[k];
                    this._eventManager.objectMap[e] = { id: e, objectType: "dataPoint", dataSeriesIndex: p2, dataPointIndex: k, x1: l, y1: h2, x2: F2, y2: m };
                    var T = v3[k].color ? v3[k].color : 0 < v3[k].y ? u2.risingColor : u2.fallingColor;
                    ea(b, l, h2, F2, m, T, 0, T, x, x, false, false, u2.fillOpacity);
                    e = N(e);
                    r && ea(this._eventManager.ghostCtx, l, h2, F2, m, e, 0, null, false, false, false, false);
                    var Y, T = l;
                    Y = "undefined" !== typeof v3[k].isIntermediateSum && true === v3[k].isIntermediateSum || "undefined" !== typeof v3[k].isCumulativeSum && true === v3[k].isCumulativeSum ? 0 < v3[k].y ? h2 : m : 0 < v3[k].y ? m : h2;
                    0 < k && y && (!z2 || u2.connectNullData) && (z2 && b.setLineDash && b.setLineDash(R(D, t)), b.beginPath(), b.moveTo(y, A - C), b.lineTo(T, Y - C), 0 < t && b.stroke(), r && (c.beginPath(), c.moveTo(y, A - C), c.lineTo(T, Y - C), 0 < t && c.stroke()));
                    z2 = false;
                    y = F2;
                    A = 0 < v3[k].y ? h2 : m;
                    T = v3[k].lineDashType ? v3[k].lineDashType : u2.options.lineDashType ? u2.options.lineDashType : "shortDash";
                    b.strokeStyle = v3[k].lineColor ? v3[k].lineColor : u2.options.lineColor ? u2.options.lineColor : "#9e9e9e";
                    b.lineWidth = t;
                    b.setLineDash && (T = R(T, t), b.setLineDash(T));
                    (v3[k].indexLabel || u2.indexLabel || v3[k].indexLabelFormatter || u2.indexLabelFormatter) && this._indexLabels.push({ chartType: "waterfall", dataPoint: v3[k], dataSeries: u2, point: { x: l + (F2 - l) / 2, y: 0 <= v3[k].y ? h2 : m }, direction: 0 > v3[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: l, y1: Math.min(h2, m), x2: F2, y2: Math.max(h2, m) }, color: e });
                  }
            }
            r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };
          }
        };
        var ja2 = function(a, d, b, c, e, g, k, l, h2) {
          if (!(0 > b)) {
            "undefined" === typeof l && (l = 1);
            if (!r) {
              var m = Number((k % (2 * Math.PI)).toFixed(8));
              Number((g % (2 * Math.PI)).toFixed(8)) === m && (k -= 1e-4);
            }
            a.save();
            a.globalAlpha = l;
            "pie" === e ? (a.beginPath(), a.moveTo(d.x, d.y), a.arc(d.x, d.y, b, g, k, false), a.fillStyle = c, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === e && (a.beginPath(), a.arc(d.x, d.y, b, g, k, false), 0 <= h2 && a.arc(d.x, d.y, h2 * b, k, g, true), a.closePath(), a.fillStyle = c, a.strokeStyle = "white", a.lineWidth = 2, a.fill());
            a.globalAlpha = 1;
            a.restore();
          }
        };
        p.prototype.renderPie = function(a) {
          function d() {
            if (m && s) {
              for (var a2 = 0, b2 = 0, c2 = 0, e2 = 0, d2 = 0; d2 < s.length; d2++) {
                var g2 = s[d2], l2 = m.dataPointIds[d2];
                f[d2].id = l2;
                f[d2].objectType = "dataPoint";
                f[d2].dataPointIndex = d2;
                f[d2].dataSeriesIndex = 0;
                var k2 = f[d2], q2 = { percent: null, total: null }, p3 = null, q2 = h2.getPercentAndTotal(
                  m,
                  g2
                );
                if (m.indexLabelFormatter || g2.indexLabelFormatter)
                  p3 = { chart: h2.options, dataSeries: m, dataPoint: g2, total: q2.total, percent: q2.percent };
                q2 = g2.indexLabelFormatter ? g2.indexLabelFormatter(p3) : g2.indexLabel ? h2.replaceKeywordsWithValue(g2.indexLabel, g2, m, d2) : m.indexLabelFormatter ? m.indexLabelFormatter(p3) : m.indexLabel ? h2.replaceKeywordsWithValue(m.indexLabel, g2, m, d2) : g2.label ? g2.label : "";
                h2._eventManager.objectMap[l2] = k2;
                k2.center = { x: x.x, y: x.y };
                k2.y = g2.y;
                k2.radius = A;
                k2.percentInnerRadius = F2;
                k2.indexLabelText = q2;
                k2.indexLabelPlacement = m.indexLabelPlacement;
                k2.indexLabelLineColor = g2.indexLabelLineColor ? g2.indexLabelLineColor : m.options.indexLabelLineColor ? m.options.indexLabelLineColor : g2.color ? g2.color : m._colorSet[d2 % m._colorSet.length];
                k2.indexLabelLineThickness = u(g2.indexLabelLineThickness) ? m.indexLabelLineThickness : g2.indexLabelLineThickness;
                k2.indexLabelLineDashType = g2.indexLabelLineDashType ? g2.indexLabelLineDashType : m.indexLabelLineDashType;
                k2.indexLabelFontColor = g2.indexLabelFontColor ? g2.indexLabelFontColor : m.indexLabelFontColor;
                k2.indexLabelFontStyle = g2.indexLabelFontStyle ? g2.indexLabelFontStyle : m.indexLabelFontStyle;
                k2.indexLabelFontWeight = g2.indexLabelFontWeight ? g2.indexLabelFontWeight : m.indexLabelFontWeight;
                k2.indexLabelFontSize = u(g2.indexLabelFontSize) ? m.indexLabelFontSize : g2.indexLabelFontSize;
                k2.indexLabelFontFamily = g2.indexLabelFontFamily ? g2.indexLabelFontFamily : m.indexLabelFontFamily;
                k2.indexLabelBackgroundColor = g2.indexLabelBackgroundColor ? g2.indexLabelBackgroundColor : m.options.indexLabelBackgroundColor ? m.options.indexLabelBackgroundColor : m.indexLabelBackgroundColor;
                k2.indexLabelMaxWidth = g2.indexLabelMaxWidth ? g2.indexLabelMaxWidth : m.indexLabelMaxWidth ? m.indexLabelMaxWidth : 0.33 * n.width;
                k2.indexLabelWrap = "undefined" !== typeof g2.indexLabelWrap ? g2.indexLabelWrap : m.indexLabelWrap;
                k2.startAngle = 0 === d2 ? m.startAngle ? m.startAngle / 180 * Math.PI : 0 : f[d2 - 1].endAngle;
                k2.startAngle = (k2.startAngle + 2 * Math.PI) % (2 * Math.PI);
                k2.endAngle = k2.startAngle + 2 * Math.PI / z2 * Math.abs(g2.y);
                g2 = (k2.endAngle + k2.startAngle) / 2;
                g2 = (g2 + 2 * Math.PI) % (2 * Math.PI);
                k2.midAngle = g2;
                if (k2.midAngle > Math.PI / 2 - t && k2.midAngle < Math.PI / 2 + t) {
                  if (0 === a2 || f[c2].midAngle > k2.midAngle)
                    c2 = d2;
                  a2++;
                } else if (k2.midAngle > 3 * Math.PI / 2 - t && k2.midAngle < 3 * Math.PI / 2 + t) {
                  if (0 === b2 || f[e2].midAngle > k2.midAngle)
                    e2 = d2;
                  b2++;
                }
                k2.hemisphere = g2 > Math.PI / 2 && g2 <= 3 * Math.PI / 2 ? "left" : "right";
                k2.indexLabelTextBlock = new ka(h2.plotArea.ctx, { fontSize: k2.indexLabelFontSize, fontFamily: k2.indexLabelFontFamily, fontColor: k2.indexLabelFontColor, fontStyle: k2.indexLabelFontStyle, fontWeight: k2.indexLabelFontWeight, horizontalAlign: "left", backgroundColor: k2.indexLabelBackgroundColor, maxWidth: k2.indexLabelMaxWidth, maxHeight: k2.indexLabelWrap ? 5 * k2.indexLabelFontSize : 1.5 * k2.indexLabelFontSize, text: k2.indexLabelText, padding: 0, textBaseline: "top" });
                k2.indexLabelTextBlock.measureText();
              }
              l2 = g2 = 0;
              q2 = false;
              for (d2 = 0; d2 < s.length; d2++)
                k2 = f[(c2 + d2) % s.length], 1 < a2 && (k2.midAngle > Math.PI / 2 - t && k2.midAngle < Math.PI / 2 + t) && (g2 <= a2 / 2 && !q2 ? (k2.hemisphere = "right", g2++) : (k2.hemisphere = "left", q2 = true));
              q2 = false;
              for (d2 = 0; d2 < s.length; d2++)
                k2 = f[(e2 + d2) % s.length], 1 < b2 && (k2.midAngle > 3 * Math.PI / 2 - t && k2.midAngle < 3 * Math.PI / 2 + t) && (l2 <= b2 / 2 && !q2 ? (k2.hemisphere = "left", l2++) : (k2.hemisphere = "right", q2 = true));
            }
          }
          function b(a2) {
            var b2 = h2.plotArea.ctx;
            b2.clearRect(n.x1, n.y1, n.width, n.height);
            b2.fillStyle = h2.backgroundColor;
            b2.fillRect(n.x1, n.y1, n.width, n.height);
            for (b2 = 0; b2 < s.length; b2++) {
              var c2 = f[b2].startAngle, e2 = f[b2].endAngle;
              if (e2 > c2) {
                var d2 = 0.07 * A * Math.cos(f[b2].midAngle), g2 = 0.07 * A * Math.sin(f[b2].midAngle), k2 = false;
                if (s[b2].exploded) {
                  if (1e-9 < Math.abs(f[b2].center.x - (x.x + d2)) || 1e-9 < Math.abs(f[b2].center.y - (x.y + g2)))
                    f[b2].center.x = x.x + d2 * a2, f[b2].center.y = x.y + g2 * a2, k2 = true;
                } else if (0 < Math.abs(f[b2].center.x - x.x) || 0 < Math.abs(f[b2].center.y - x.y))
                  f[b2].center.x = x.x + d2 * (1 - a2), f[b2].center.y = x.y + g2 * (1 - a2), k2 = true;
                k2 && (d2 = {}, d2.dataSeries = m, d2.dataPoint = m.dataPoints[b2], d2.index = b2, h2.toolTip.highlightObjects([d2]));
                ja2(h2.plotArea.ctx, f[b2].center, f[b2].radius, s[b2].color ? s[b2].color : m._colorSet[b2 % m._colorSet.length], m.type, c2, e2, m.fillOpacity, f[b2].percentInnerRadius);
              }
            }
            a2 = h2.plotArea.ctx;
            a2.save();
            a2.fillStyle = "black";
            a2.strokeStyle = "grey";
            a2.textBaseline = "middle";
            a2.lineJoin = "round";
            for (b2 = b2 = 0; b2 < s.length; b2++)
              c2 = f[b2], c2.indexLabelText && (c2.indexLabelTextBlock.y -= c2.indexLabelTextBlock.height / 2, e2 = 0, e2 = "left" === c2.hemisphere ? "inside" !== m.indexLabelPlacement ? -(c2.indexLabelTextBlock.width + q) : -c2.indexLabelTextBlock.width / 2 : "inside" !== m.indexLabelPlacement ? q : -c2.indexLabelTextBlock.width / 2, c2.indexLabelTextBlock.x += e2, c2.indexLabelTextBlock.render(true), c2.indexLabelTextBlock.x -= e2, c2.indexLabelTextBlock.y += c2.indexLabelTextBlock.height / 2, "inside" !== c2.indexLabelPlacement && 0 < c2.indexLabelLineThickness && (e2 = c2.center.x + A * Math.cos(c2.midAngle), d2 = c2.center.y + A * Math.sin(c2.midAngle), a2.strokeStyle = c2.indexLabelLineColor, a2.lineWidth = c2.indexLabelLineThickness, a2.setLineDash && a2.setLineDash(R(c2.indexLabelLineDashType, c2.indexLabelLineThickness)), a2.beginPath(), a2.moveTo(e2, d2), a2.lineTo(c2.indexLabelTextBlock.x, c2.indexLabelTextBlock.y), a2.lineTo(c2.indexLabelTextBlock.x + ("left" === c2.hemisphere ? -q : q), c2.indexLabelTextBlock.y), a2.stroke()), a2.lineJoin = "miter");
            a2.save();
          }
          function c(a2, b2) {
            var c2 = 0, c2 = a2.indexLabelTextBlock.y - a2.indexLabelTextBlock.height / 2, e2 = a2.indexLabelTextBlock.y + a2.indexLabelTextBlock.height / 2, d2 = b2.indexLabelTextBlock.y - b2.indexLabelTextBlock.height / 2, f2 = b2.indexLabelTextBlock.y + b2.indexLabelTextBlock.height / 2;
            return c2 = b2.indexLabelTextBlock.y > a2.indexLabelTextBlock.y ? d2 - e2 : c2 - f2;
          }
          function e(a2) {
            for (var b2 = null, e2 = 1; e2 < s.length; e2++)
              if (b2 = (a2 + e2 + f.length) % f.length, f[b2].hemisphere !== f[a2].hemisphere) {
                b2 = null;
                break;
              } else if (f[b2].indexLabelText && b2 !== a2 && (0 > c(f[b2], f[a2]) || ("right" === f[a2].hemisphere ? f[b2].indexLabelTextBlock.y >= f[a2].indexLabelTextBlock.y : f[b2].indexLabelTextBlock.y <= f[a2].indexLabelTextBlock.y)))
                break;
              else
                b2 = null;
            return b2;
          }
          function g(a2, b2, d2) {
            d2 = (d2 || 0) + 1;
            if (1e3 < d2)
              return 0;
            b2 = b2 || 0;
            var k2 = 0, m2 = x.y - 1 * r2, l2 = x.y + 1 * r2;
            if (0 <= a2 && a2 < s.length) {
              var n2 = f[a2];
              if (0 > b2 && n2.indexLabelTextBlock.y < m2 || 0 < b2 && n2.indexLabelTextBlock.y > l2)
                return 0;
              var h3 = 0, q2 = 0, q2 = h3 = h3 = 0;
              0 > b2 ? n2.indexLabelTextBlock.y - n2.indexLabelTextBlock.height / 2 > m2 && n2.indexLabelTextBlock.y - n2.indexLabelTextBlock.height / 2 + b2 < m2 && (b2 = -(m2 - (n2.indexLabelTextBlock.y - n2.indexLabelTextBlock.height / 2 + b2))) : n2.indexLabelTextBlock.y + n2.indexLabelTextBlock.height / 2 < m2 && n2.indexLabelTextBlock.y + n2.indexLabelTextBlock.height / 2 + b2 > l2 && (b2 = n2.indexLabelTextBlock.y + n2.indexLabelTextBlock.height / 2 + b2 - l2);
              b2 = n2.indexLabelTextBlock.y + b2;
              m2 = 0;
              m2 = "right" === n2.hemisphere ? x.x + Math.sqrt(Math.pow(r2, 2) - Math.pow(b2 - x.y, 2)) : x.x - Math.sqrt(Math.pow(r2, 2) - Math.pow(b2 - x.y, 2));
              q2 = x.x + A * Math.cos(n2.midAngle);
              h3 = x.y + A * Math.sin(n2.midAngle);
              h3 = Math.sqrt(Math.pow(m2 - q2, 2) + Math.pow(b2 - h3, 2));
              q2 = Math.acos(A / r2);
              h3 = Math.acos((r2 * r2 + A * A - h3 * h3) / (2 * A * r2));
              b2 = h3 < q2 ? b2 - n2.indexLabelTextBlock.y : 0;
              m2 = null;
              for (l2 = 1; l2 < s.length; l2++)
                if (m2 = (a2 - l2 + f.length) % f.length, f[m2].hemisphere !== f[a2].hemisphere) {
                  m2 = null;
                  break;
                } else if (f[m2].indexLabelText && f[m2].hemisphere === f[a2].hemisphere && m2 !== a2 && (0 > c(f[m2], f[a2]) || ("right" === f[a2].hemisphere ? f[m2].indexLabelTextBlock.y <= f[a2].indexLabelTextBlock.y : f[m2].indexLabelTextBlock.y >= f[a2].indexLabelTextBlock.y)))
                  break;
                else
                  m2 = null;
              q2 = m2;
              h3 = e(a2);
              l2 = m2 = 0;
              0 > b2 ? (l2 = "right" === n2.hemisphere ? q2 : h3, k2 = b2, null !== l2 && (q2 = -b2, b2 = n2.indexLabelTextBlock.y - n2.indexLabelTextBlock.height / 2 - (f[l2].indexLabelTextBlock.y + f[l2].indexLabelTextBlock.height / 2), b2 - q2 < p2 && (m2 = -q2, l2 = g(l2, m2, d2 + 1), +l2.toFixed(C) > +m2.toFixed(C) && (k2 = b2 > p2 ? -(b2 - p2) : -(q2 - (l2 - m2)))))) : 0 < b2 && (l2 = "right" === n2.hemisphere ? h3 : q2, k2 = b2, null !== l2 && (q2 = b2, b2 = f[l2].indexLabelTextBlock.y - f[l2].indexLabelTextBlock.height / 2 - (n2.indexLabelTextBlock.y + n2.indexLabelTextBlock.height / 2), b2 - q2 < p2 && (m2 = q2, l2 = g(l2, m2, d2 + 1), +l2.toFixed(C) < +m2.toFixed(C) && (k2 = b2 > p2 ? b2 - p2 : q2 - (m2 - l2)))));
              k2 && (d2 = n2.indexLabelTextBlock.y + k2, b2 = 0, b2 = "right" === n2.hemisphere ? x.x + Math.sqrt(Math.pow(r2, 2) - Math.pow(d2 - x.y, 2)) : x.x - Math.sqrt(Math.pow(r2, 2) - Math.pow(d2 - x.y, 2)), n2.midAngle > Math.PI / 2 - t && n2.midAngle < Math.PI / 2 + t ? (m2 = (a2 - 1 + f.length) % f.length, m2 = f[m2], a2 = f[(a2 + 1 + f.length) % f.length], "left" === n2.hemisphere && "right" === m2.hemisphere && b2 > m2.indexLabelTextBlock.x ? b2 = m2.indexLabelTextBlock.x - 15 : "right" === n2.hemisphere && ("left" === a2.hemisphere && b2 < a2.indexLabelTextBlock.x) && (b2 = a2.indexLabelTextBlock.x + 15)) : n2.midAngle > 3 * Math.PI / 2 - t && n2.midAngle < 3 * Math.PI / 2 + t && (m2 = (a2 - 1 + f.length) % f.length, m2 = f[m2], a2 = f[(a2 + 1 + f.length) % f.length], "right" === n2.hemisphere && "left" === m2.hemisphere && b2 < m2.indexLabelTextBlock.x ? b2 = m2.indexLabelTextBlock.x + 15 : "left" === n2.hemisphere && ("right" === a2.hemisphere && b2 > a2.indexLabelTextBlock.x) && (b2 = a2.indexLabelTextBlock.x - 15)), n2.indexLabelTextBlock.y = d2, n2.indexLabelTextBlock.x = b2, n2.indexLabelAngle = Math.atan2(n2.indexLabelTextBlock.y - x.y, n2.indexLabelTextBlock.x - x.x));
            }
            return k2;
          }
          function k() {
            var a2 = h2.plotArea.ctx;
            a2.fillStyle = "grey";
            a2.strokeStyle = "grey";
            a2.font = "16px Arial";
            a2.textBaseline = "middle";
            for (var b2 = a2 = 0, d2 = 0, k2 = true, b2 = 0; 10 > b2 && (1 > b2 || 0 < d2); b2++) {
              if (m.radius || !m.radius && "undefined" !== typeof m.innerRadius && null !== m.innerRadius && A - d2 <= D)
                k2 = false;
              k2 && (A -= d2);
              d2 = 0;
              if ("inside" !== m.indexLabelPlacement) {
                r2 = A * v3;
                for (a2 = 0; a2 < s.length; a2++) {
                  var l2 = f[a2];
                  l2.indexLabelTextBlock.x = x.x + r2 * Math.cos(l2.midAngle);
                  l2.indexLabelTextBlock.y = x.y + r2 * Math.sin(l2.midAngle);
                  l2.indexLabelAngle = l2.midAngle;
                  l2.radius = A;
                  l2.percentInnerRadius = F2;
                }
                for (var t2, u2, a2 = 0; a2 < s.length; a2++) {
                  var l2 = f[a2], y2 = e(a2);
                  if (null !== y2) {
                    t2 = f[a2];
                    u2 = f[y2];
                    var z3 = 0, z3 = c(t2, u2) - p2;
                    if (0 > z3) {
                      for (var E3 = u2 = 0, H2 = 0; H2 < s.length; H2++)
                        H2 !== a2 && f[H2].hemisphere === l2.hemisphere && (f[H2].indexLabelTextBlock.y < l2.indexLabelTextBlock.y ? u2++ : E3++);
                      u2 = z3 / (u2 + E3 || 1) * E3;
                      var E3 = -1 * (z3 - u2), I3 = H2 = 0;
                      "right" === l2.hemisphere ? (H2 = g(a2, u2), E3 = -1 * (z3 - H2), I3 = g(y2, E3), +I3.toFixed(C) < +E3.toFixed(C) && +H2.toFixed(C) <= +u2.toFixed(C) && g(a2, -(E3 - I3))) : (H2 = g(y2, u2), E3 = -1 * (z3 - H2), I3 = g(a2, E3), +I3.toFixed(C) < +E3.toFixed(C) && +H2.toFixed(C) <= +u2.toFixed(C) && g(y2, -(E3 - I3)));
                    }
                  }
                }
              } else
                for (a2 = 0; a2 < s.length; a2++)
                  l2 = f[a2], r2 = "pie" === m.type ? 0.7 * A : 0.8 * A, y2 = x.x + r2 * Math.cos(l2.midAngle), u2 = x.y + r2 * Math.sin(l2.midAngle), l2.indexLabelTextBlock.x = y2, l2.indexLabelTextBlock.y = u2;
              for (a2 = 0; a2 < s.length; a2++)
                if (l2 = f[a2], y2 = l2.indexLabelTextBlock.measureText(), 0 !== y2.height && 0 !== y2.width)
                  y2 = y2 = 0, "right" === l2.hemisphere ? (y2 = n.x2 - (l2.indexLabelTextBlock.x + l2.indexLabelTextBlock.width + q), y2 *= -1) : y2 = n.x1 - (l2.indexLabelTextBlock.x - l2.indexLabelTextBlock.width - q), 0 < y2 && (!k2 && l2.indexLabelText && (u2 = "right" === l2.hemisphere ? n.x2 - l2.indexLabelTextBlock.x : l2.indexLabelTextBlock.x - n.x1, 0.3 * l2.indexLabelTextBlock.maxWidth > u2 ? l2.indexLabelText = "" : l2.indexLabelTextBlock.maxWidth = 0.85 * u2, 0.3 * l2.indexLabelTextBlock.maxWidth < u2 && (l2.indexLabelTextBlock.x -= "right" === l2.hemisphere ? 2 : -2)), Math.abs(l2.indexLabelTextBlock.y - l2.indexLabelTextBlock.height / 2 - x.y) < A || Math.abs(l2.indexLabelTextBlock.y + l2.indexLabelTextBlock.height / 2 - x.y) < A) && (y2 /= Math.abs(Math.cos(l2.indexLabelAngle)), 9 < y2 && (y2 *= 0.3), y2 > d2 && (d2 = y2)), y2 = y2 = 0, 0 < l2.indexLabelAngle && l2.indexLabelAngle < Math.PI ? (y2 = n.y2 - (l2.indexLabelTextBlock.y + l2.indexLabelTextBlock.height / 2 + 5), y2 *= -1) : y2 = n.y1 - (l2.indexLabelTextBlock.y - l2.indexLabelTextBlock.height / 2 - 5), 0 < y2 && (!k2 && l2.indexLabelText && (u2 = 0 < l2.indexLabelAngle && l2.indexLabelAngle < Math.PI ? -1 : 1, 0 === g(a2, y2 * u2) && g(a2, 2 * u2)), Math.abs(l2.indexLabelTextBlock.x - x.x) < A && (y2 /= Math.abs(Math.sin(l2.indexLabelAngle)), 9 < y2 && (y2 *= 0.3), y2 > d2 && (d2 = y2)));
              var K = function(a3, b3, c2) {
                for (var e2 = [], d3 = 0; e2.push(f[b3]), b3 !== c2; b3 = (b3 + 1 + s.length) % s.length)
                  ;
                e2.sort(function(a4, b4) {
                  return a4.y - b4.y;
                });
                for (b3 = 0; b3 < e2.length; b3++)
                  if (c2 = e2[b3], d3 < 0.7 * a3)
                    d3 += c2.indexLabelTextBlock.height, c2.indexLabelTextBlock.text = "", c2.indexLabelText = "", c2.indexLabelTextBlock.measureText();
                  else
                    break;
              };
              (function() {
                for (var a3 = -1, b3 = -1, d3 = 0, g2 = false, l3 = 0; l3 < s.length; l3++)
                  if (g2 = false, t2 = f[l3], t2.indexLabelText) {
                    var k3 = e(l3);
                    if (null !== k3) {
                      var m2 = f[k3];
                      z3 = 0;
                      z3 = c(t2, m2);
                      var n2;
                      if (n2 = 0 > z3) {
                        n2 = t2.indexLabelTextBlock.x;
                        var h3 = t2.indexLabelTextBlock.y - t2.indexLabelTextBlock.height / 2, w = t2.indexLabelTextBlock.y + t2.indexLabelTextBlock.height / 2, p3 = m2.indexLabelTextBlock.y - m2.indexLabelTextBlock.height / 2, u3 = m2.indexLabelTextBlock.x + m2.indexLabelTextBlock.width, r3 = m2.indexLabelTextBlock.y + m2.indexLabelTextBlock.height / 2;
                        n2 = t2.indexLabelTextBlock.x + t2.indexLabelTextBlock.width < m2.indexLabelTextBlock.x - q || n2 > u3 + q || h3 > r3 + q || w < p3 - q ? false : true;
                      }
                      n2 ? (0 > a3 && (a3 = l3), k3 !== a3 && (b3 = k3, d3 += -z3), 0 === l3 % Math.max(s.length / 10, 3) && (g2 = true)) : g2 = true;
                      g2 && (0 < d3 && 0 <= a3 && 0 <= b3) && (K(d3, a3, b3), b3 = a3 = -1, d3 = 0);
                    }
                  }
                0 < d3 && K(d3, a3, b3);
              })();
            }
          }
          function l() {
            h2.plotArea.layoutManager.reset();
            h2.title && (h2.title.dockInsidePlotArea || "center" === h2.title.horizontalAlign && "center" === h2.title.verticalAlign) && h2.title.render();
            if (h2.subtitles)
              for (var a2 = 0; a2 < h2.subtitles.length; a2++) {
                var b2 = h2.subtitles[a2];
                (b2.dockInsidePlotArea || "center" === b2.horizontalAlign && "center" === b2.verticalAlign) && b2.render();
              }
            h2.legend && (h2.legend.dockInsidePlotArea || "center" === h2.legend.horizontalAlign && "center" === h2.legend.verticalAlign) && (h2.legend.setLayout(), h2.legend.render());
          }
          var h2 = this;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var m = this.data[a.dataSeriesIndexes[0]], s = m.dataPoints, q = 10, n = this.plotArea, f = m.dataPointEOs, p2 = 2, r2, v3 = 1.3, t = 20 / 180 * Math.PI, C = 6, x = { x: (n.x2 + n.x1) / 2, y: (n.y2 + n.y1) / 2 }, z2 = 0;
            a = false;
            for (var y = 0; y < s.length; y++)
              z2 += Math.abs(s[y].y), !a && ("undefined" !== typeof s[y].indexLabel && null !== s[y].indexLabel && 0 < s[y].indexLabel.toString().length) && (a = true), !a && ("undefined" !== typeof s[y].label && null !== s[y].label && 0 < s[y].label.toString().length) && (a = true);
            if (0 !== z2) {
              a = a || "undefined" !== typeof m.indexLabel && null !== m.indexLabel && 0 < m.indexLabel.toString().length;
              var A = "inside" !== m.indexLabelPlacement && a ? 0.75 * Math.min(n.width, n.height) / 2 : 0.92 * Math.min(n.width, n.height) / 2;
              m.radius && (A = I2(m.radius, A));
              var D = "undefined" !== typeof m.innerRadius && null !== m.innerRadius ? I2(m.innerRadius, A) : 0.7 * A;
              m.radius = A;
              "doughnut" === m.type && (m.innerRadius = D);
              var F2 = Math.min(D / A, (A - 1) / A);
              this.pieDoughnutClickHandler = function(a2) {
                h2.isAnimating || !u(a2.dataSeries.explodeOnClick) && !a2.dataSeries.explodeOnClick || (a2 = a2.dataPoint, a2.exploded = a2.exploded ? false : true, 1 < this.dataPoints.length && h2._animator.animate(
                  0,
                  500,
                  function(a3) {
                    b(a3);
                    l();
                  }
                ));
              };
              d();
              k();
              k();
              k();
              k();
              this.disableToolTip = true;
              this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function(a2) {
                var b2 = h2.plotArea.ctx;
                b2.clearRect(n.x1, n.y1, n.width, n.height);
                b2.fillStyle = h2.backgroundColor;
                b2.fillRect(n.x1, n.y1, n.width, n.height);
                a2 = f[0].startAngle + 2 * Math.PI * a2;
                for (b2 = 0; b2 < s.length; b2++) {
                  var c2 = 0 === b2 ? f[b2].startAngle : e2, e2 = c2 + (f[b2].endAngle - f[b2].startAngle), d2 = false;
                  e2 > a2 && (e2 = a2, d2 = true);
                  var g2 = s[b2].color ? s[b2].color : m._colorSet[b2 % m._colorSet.length];
                  e2 > c2 && ja2(
                    h2.plotArea.ctx,
                    f[b2].center,
                    f[b2].radius,
                    g2,
                    m.type,
                    c2,
                    e2,
                    m.fillOpacity,
                    f[b2].percentInnerRadius
                  );
                  if (d2)
                    break;
                }
                l();
              }, function() {
                h2.disableToolTip = false;
                h2._animator.animate(0, h2.animatedRender ? 500 : 0, function(a2) {
                  b(a2);
                  l();
                });
              });
            }
          }
        };
        var ra2 = function(a, d, b, c) {
          "undefined" === typeof b && (b = 1);
          0 >= Math.round(d.y4 - d.y1) || (a.save(), a.globalAlpha = b, a.beginPath(), a.moveTo(Math.round(d.x1), Math.round(d.y1)), a.lineTo(Math.round(d.x2), Math.round(d.y2)), a.lineTo(Math.round(d.x3), Math.round(d.y3)), a.lineTo(Math.round(d.x4), Math.round(d.y4)), "undefined" !== d.x5 && (a.lineTo(Math.round(d.x5), Math.round(d.y5)), a.lineTo(Math.round(d.x6), Math.round(d.y6))), a.closePath(), a.fillStyle = c ? c : d.color, a.fill(), a.globalAplha = 1, a.restore());
        };
        p.prototype.renderFunnel = function(a) {
          function d() {
            for (var a2 = 0, b2 = [], c2 = 0; c2 < C.length; c2++) {
              if ("undefined" === typeof C[c2].y)
                return -1;
              C[c2].y = "number" === typeof C[c2].y ? C[c2].y : 0;
              a2 += Math.abs(C[c2].y);
            }
            if (0 === a2)
              return -1;
            for (c2 = b2[0] = 0; c2 < C.length; c2++)
              b2.push(Math.abs(C[c2].y) * F2 / a2);
            return b2;
          }
          function b() {
            var a2 = $3, b2 = V2, c2 = K, e2 = ea2, d2, f2;
            d2 = O2;
            f2 = Z - N2;
            e2 = Math.abs((f2 - d2) * (b2 - a2 + (e2 - c2)) / 2);
            c2 = ea2 - K;
            d2 = f2 - d2;
            f2 = c2 * (f2 - Z);
            f2 = Math.abs(f2);
            f2 = e2 + f2;
            for (var e2 = [], g2 = 0, l2 = 0; l2 < C.length; l2++) {
              if ("undefined" === typeof C[l2].y)
                return -1;
              C[l2].y = "number" === typeof C[l2].y ? C[l2].y : 0;
              g2 += Math.abs(C[l2].y);
            }
            if (0 === g2)
              return -1;
            for (var m2 = e2[0] = 0, k2 = 0, n2, h3, b2 = b2 - a2, m2 = false, l2 = 0; l2 < C.length; l2++)
              a2 = Math.abs(C[l2].y) * f2 / g2, m2 ? n2 = 0 == Number(c2.toFixed(3)) ? 0 : a2 / c2 : (h3 = ba2 * ba2 * b2 * b2 - 4 * Math.abs(ba2) * a2, 0 > h3 ? (h3 = c2, m2 = (b2 + h3) * (d2 - k2) / 2, a2 -= m2, n2 = d2 - k2, k2 += d2 - k2, n2 += 0 == h3 ? 0 : a2 / h3, k2 += a2 / h3, m2 = true) : (n2 = (Math.abs(ba2) * b2 - Math.sqrt(h3)) / 2, h3 = b2 - 2 * n2 / Math.abs(ba2), k2 += n2, k2 > d2 && (k2 -= n2, h3 = c2, m2 = (b2 + h3) * (d2 - k2) / 2, a2 -= m2, n2 = d2 - k2, k2 += d2 - k2, n2 += a2 / h3, k2 += a2 / h3, m2 = true), b2 = h3)), e2.push(n2);
            return e2;
          }
          function c() {
            if (t && C) {
              for (var a2, b2, c2, e2, d2, g2, l2, k2, m2, n2, h3, q2, s2, w, p3 = [], B = [], x2 = { percent: null, total: null }, v4 = null, y2 = 0; y2 < C.length; y2++)
                w = P[y2], w = "undefined" !== typeof w.x5 ? (w.y2 + w.y4) / 2 : (w.y2 + w.y3) / 2, w = f(w).x2 + 1, p3[y2] = L2 - w - S2;
              w = 0.5 * S2;
              for (var y2 = 0, A2 = C.length - 1; y2 < C.length || 0 <= A2; y2++, A2--) {
                b2 = t.reversed ? C[A2] : C[y2];
                a2 = b2.color ? b2.color : t.reversed ? t._colorSet[(C.length - 1 - y2) % t._colorSet.length] : t._colorSet[y2 % t._colorSet.length];
                c2 = b2.indexLabelPlacement || t.indexLabelPlacement || "outside";
                e2 = b2.indexLabelBackgroundColor || t.indexLabelBackgroundColor || (r ? "transparent" : null);
                d2 = b2.indexLabelFontColor || t.indexLabelFontColor || "#979797";
                g2 = u(b2.indexLabelFontSize) ? t.indexLabelFontSize : b2.indexLabelFontSize;
                l2 = b2.indexLabelFontStyle || t.indexLabelFontStyle || "normal";
                k2 = b2.indexLabelFontFamily || t.indexLabelFontFamily || "arial";
                m2 = b2.indexLabelFontWeight || t.indexLabelFontWeight || "normal";
                a2 = b2.indexLabelLineColor || t.options.indexLabelLineColor || a2;
                n2 = "number" === typeof b2.indexLabelLineThickness ? b2.indexLabelLineThickness : "number" === typeof t.indexLabelLineThickness ? t.indexLabelLineThickness : 2;
                h3 = b2.indexLabelLineDashType || t.indexLabelLineDashType || "solid";
                q2 = "undefined" !== typeof b2.indexLabelWrap ? b2.indexLabelWrap : "undefined" !== typeof t.indexLabelWrap ? t.indexLabelWrap : true;
                s2 = t.dataPointIds[y2];
                z2._eventManager.objectMap[s2] = { id: s2, objectType: "dataPoint", dataPointIndex: y2, dataSeriesIndex: 0, funnelSection: P[t.reversed ? C.length - 1 - y2 : y2] };
                "inside" === t.indexLabelPlacement && (p3[y2] = y2 !== fa3 ? t.reversed ? P[y2].x2 - P[y2].x1 : P[y2].x3 - P[y2].x4 : P[y2].x3 - P[y2].x6, 20 > p3[y2] && (p3[y2] = y2 !== fa3 ? t.reversed ? P[y2].x3 - P[y2].x4 : P[y2].x2 - P[y2].x1 : P[y2].x2 - P[y2].x1, p3[y2] /= 2));
                s2 = b2.indexLabelMaxWidth ? b2.indexLabelMaxWidth : t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth : p3[y2];
                if (s2 > p3[y2] || 0 > s2)
                  s2 = p3[y2];
                B[y2] = "inside" === t.indexLabelPlacement ? P[y2].height : false;
                x2 = z2.getPercentAndTotal(t, b2);
                if (t.indexLabelFormatter || b2.indexLabelFormatter)
                  v4 = { chart: z2.options, dataSeries: t, dataPoint: b2, total: x2.total, percent: x2.percent };
                b2 = b2.indexLabelFormatter ? b2.indexLabelFormatter(v4) : b2.indexLabel ? z2.replaceKeywordsWithValue(b2.indexLabel, b2, t, y2) : t.indexLabelFormatter ? t.indexLabelFormatter(v4) : t.indexLabel ? z2.replaceKeywordsWithValue(t.indexLabel, b2, t, y2) : b2.label ? b2.label : "";
                0 >= n2 && (n2 = 0);
                1e3 > s2 && 1e3 - s2 < w && (s2 += 1e3 - s2);
                Q3.roundRect || Ea(Q3);
                c2 = new ka(Q3, { fontSize: g2, fontFamily: k2, fontColor: d2, fontStyle: l2, fontWeight: m2, horizontalAlign: c2, backgroundColor: e2, maxWidth: s2, maxHeight: false === B[y2] ? q2 ? 4.28571429 * g2 : 1.5 * g2 : B[y2], text: b2, padding: ga3 });
                c2.measureText();
                J.push({
                  textBlock: c2,
                  id: t.reversed ? A2 : y2,
                  isDirty: false,
                  lineColor: a2,
                  lineThickness: n2,
                  lineDashType: h3,
                  height: c2.height < c2.maxHeight ? c2.height : c2.maxHeight,
                  width: c2.width < c2.maxWidth ? c2.width : c2.maxWidth
                });
              }
            }
          }
          function e() {
            var a2, b2, c2, e2, d2, f2 = [];
            d2 = false;
            c2 = 0;
            for (var g2, l2 = L2 - V2 - S2 / 2, l2 = t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth > l2 ? l2 : t.indexLabelMaxWidth : l2, k2 = J.length - 1; 0 <= k2; k2--) {
              g2 = C[J[k2].id];
              c2 = J[k2];
              e2 = c2.textBlock;
              b2 = (a2 = n(k2) < P.length ? J[n(k2)] : null) ? a2.textBlock : null;
              c2 = c2.height;
              a2 && e2.y + c2 + ga3 > b2.y && (d2 = true);
              c2 = g2.indexLabelMaxWidth || l2;
              if (c2 > l2 || 0 > c2)
                c2 = l2;
              f2.push(c2);
            }
            if (d2)
              for (k2 = J.length - 1; 0 <= k2; k2--)
                a2 = P[k2], J[k2].textBlock.maxWidth = f2[f2.length - (k2 + 1)], J[k2].textBlock.measureText(), J[k2].textBlock.x = L2 - l2, c2 = J[k2].textBlock.height < J[k2].textBlock.maxHeight ? J[k2].textBlock.height : J[k2].textBlock.maxHeight, d2 = J[k2].textBlock.width < J[k2].textBlock.maxWidth ? J[k2].textBlock.width : J[k2].textBlock.maxWidth, J[k2].height = c2, J[k2].width = d2, c2 = "undefined" !== typeof a2.x5 ? (a2.y2 + a2.y4) / 2 : (a2.y2 + a2.y3) / 2, J[k2].textBlock.y = c2 - J[k2].height / 2, t.reversed ? (J[k2].textBlock.y + J[k2].height > pa + D && (J[k2].textBlock.y = pa + D - J[k2].height), J[k2].textBlock.y < wa - D && (J[k2].textBlock.y = wa - D)) : (J[k2].textBlock.y < pa - D && (J[k2].textBlock.y = pa - D), J[k2].textBlock.y + J[k2].height > wa + D && (J[k2].textBlock.y = wa + D - J[k2].height));
          }
          function g() {
            var a2, b2, c2, e2;
            if ("inside" !== t.indexLabelPlacement)
              for (var d2 = 0; d2 < P.length; d2++)
                0 == J[d2].textBlock.text.length ? J[d2].isDirty = true : (a2 = P[d2], c2 = "undefined" !== typeof a2.x5 ? (a2.y2 + a2.y4) / 2 : (a2.y2 + a2.y3) / 2, b2 = t.reversed ? "undefined" !== typeof a2.x5 ? c2 > Da ? f(c2).x2 + 1 : (a2.x2 + a2.x3) / 2 + 1 : (a2.x2 + a2.x3) / 2 + 1 : "undefined" !== typeof a2.x5 ? c2 < Da ? f(c2).x2 + 1 : (a2.x4 + a2.x3) / 2 + 1 : (a2.x2 + a2.x3) / 2 + 1, J[d2].textBlock.x = b2 + S2, J[d2].textBlock.y = c2 - J[d2].height / 2, t.reversed ? (J[d2].textBlock.y + J[d2].height > pa + D && (J[d2].textBlock.y = pa + D - J[d2].height), J[d2].textBlock.y < wa - D && (J[d2].textBlock.y = wa - D)) : (J[d2].textBlock.y < pa - D && (J[d2].textBlock.y = pa - D), J[d2].textBlock.y + J[d2].height > wa + D && (J[d2].textBlock.y = wa + D - J[d2].height)));
            else
              for (d2 = 0; d2 < P.length; d2++)
                0 == J[d2].textBlock.text.length ? J[d2].isDirty = true : (a2 = P[d2], b2 = a2.height, c2 = J[d2].height, e2 = J[d2].width, b2 >= c2 ? (b2 = d2 != fa3 ? (a2.x4 + a2.x3) / 2 - e2 / 2 : (a2.x5 + a2.x4) / 2 - e2 / 2, c2 = d2 != fa3 ? (a2.y1 + a2.y3) / 2 - c2 / 2 : (a2.y1 + a2.y4) / 2 - c2 / 2, J[d2].textBlock.x = b2, J[d2].textBlock.y = c2) : J[d2].isDirty = true);
          }
          function k() {
            function a2(b3, c3) {
              var d3;
              if (0 > b3 || b3 >= J.length)
                return 0;
              var e3, f3 = J[b3].textBlock;
              if (0 > c3) {
                c3 *= -1;
                e3 = q(b3);
                d3 = l(e3, b3);
                if (d3 >= c3)
                  return f3.y -= c3, c3;
                if (0 == b3)
                  return 0 < d3 && (f3.y -= d3), d3;
                d3 += a2(e3, -(c3 - d3));
                0 < d3 && (f3.y -= d3);
                return d3;
              }
              e3 = n(b3);
              d3 = l(b3, e3);
              if (d3 >= c3)
                return f3.y += c3, c3;
              if (b3 == P.length - 1)
                return 0 < d3 && (f3.y += d3), d3;
              d3 += a2(e3, c3 - d3);
              0 < d3 && (f3.y += d3);
              return d3;
            }
            function b2() {
              var a3, d3, e3, f3, g3 = 0, k3;
              f3 = (Z - O2 + 2 * D) / h3;
              k3 = h3;
              for (var l2, m3 = 1; m3 < k3; m3++) {
                e3 = m3 * f3;
                for (var s3 = J.length - 1; 0 <= s3; s3--)
                  !J[s3].isDirty && (J[s3].textBlock.y < e3 && J[s3].textBlock.y + J[s3].height > e3) && (l2 = n(s3), !(l2 >= J.length - 1) && J[s3].textBlock.y + J[s3].height + ga3 > J[l2].textBlock.y && (J[s3].textBlock.y = J[s3].textBlock.y + J[s3].height - e3 > e3 - J[s3].textBlock.y ? e3 + 1 : e3 - J[s3].height - 1));
              }
              for (l2 = P.length - 1; 0 < l2; l2--)
                if (!J[l2].isDirty) {
                  e3 = q(l2);
                  if (0 > e3 && (e3 = 0, J[e3].isDirty))
                    break;
                  if (J[l2].textBlock.y < J[e3].textBlock.y + J[e3].height) {
                    d3 = d3 || l2;
                    f3 = l2;
                    for (k3 = 0; J[f3].textBlock.y < J[e3].textBlock.y + J[e3].height + ga3; ) {
                      a3 = a3 || J[f3].textBlock.y + J[f3].height;
                      k3 += J[f3].height;
                      k3 += ga3;
                      f3 = e3;
                      if (0 >= f3) {
                        f3 = 0;
                        k3 += J[f3].height;
                        break;
                      }
                      e3 = q(f3);
                      if (0 > e3) {
                        f3 = 0;
                        k3 += J[f3].height;
                        break;
                      }
                    }
                    if (f3 != l2) {
                      g3 = J[f3].textBlock.y;
                      a3 -= g3;
                      a3 = k3 - a3;
                      g3 = c2(a3, d3, f3);
                      break;
                    }
                  }
                }
              return g3;
            }
            function c2(a3, b3, d3) {
              var e3 = [], f3 = 0, g3 = 0;
              for (a3 = Math.abs(a3); d3 <= b3; d3++)
                e3.push(P[d3]);
              e3.sort(function(a4, b4) {
                return a4.height - b4.height;
              });
              for (d3 = 0; d3 < e3.length; d3++)
                if (b3 = e3[d3], f3 < a3)
                  g3++, f3 += J[b3.id].height + ga3, J[b3.id].textBlock.text = "", J[b3.id].indexLabelText = "", J[b3.id].isDirty = true, J[b3.id].textBlock.measureText();
                else
                  break;
              return g3;
            }
            for (var d2, e2, f2, g2, k2, m2, h3 = 1, s2 = 0; s2 < 2 * h3; s2++) {
              for (var w = J.length - 1; 0 <= w && !(0 <= q(w) && q(w), f2 = J[w], g2 = f2.textBlock, m2 = (k2 = n(w) < P.length ? J[n(w)] : null) ? k2.textBlock : null, d2 = +f2.height.toFixed(6), e2 = +g2.y.toFixed(6), !f2.isDirty && (k2 && e2 + d2 + ga3 > +m2.y.toFixed(6)) && (d2 = g2.y + d2 + ga3 - m2.y, e2 = a2(w, -d2), e2 < d2 && (0 < e2 && (d2 -= e2), e2 = a2(n(w), d2), e2 != d2))); w--)
                ;
              b2();
            }
          }
          function l(a2, b2) {
            return (b2 < P.length ? J[b2].textBlock.y : t.reversed ? pa + D : wa + D) - (0 > a2 ? t.reversed ? wa - D : pa - D : J[a2].textBlock.y + J[a2].height + ga3);
          }
          function h2(a2, b2, c2) {
            var d2, e2, f2, k2 = [], l2 = D, n2 = [];
            -1 !== b2 && (0 <= W2.indexOf(b2) ? (e2 = W2.indexOf(b2), W2.splice(e2, 1)) : (W2.push(b2), W2 = W2.sort(function(a3, b3) {
              return a3 - b3;
            })));
            if (0 === W2.length)
              k2 = ia2;
            else {
              e2 = D * (1 != W2.length || 0 != W2[0] && W2[0] != P.length - 1 ? 2 : 1) / m();
              for (var q2 = 0; q2 < P.length; q2++) {
                if (1 == W2.length && 0 == W2[0]) {
                  if (0 === q2) {
                    k2.push(ia2[q2]);
                    d2 = l2;
                    continue;
                  }
                } else
                  0 === q2 && (d2 = -1 * l2);
                k2.push(ia2[q2] + d2);
                if (0 <= W2.indexOf(q2) || q2 < P.length && 0 <= W2.indexOf(q2 + 1))
                  d2 += e2;
              }
            }
            f2 = function() {
              for (var a3 = [], b3 = 0; b3 < P.length; b3++)
                a3.push(k2[b3] - P[b3].y1);
              return a3;
            }();
            var w = { startTime: (/* @__PURE__ */ new Date()).getTime(), duration: c2 || 500, easingFunction: function(a3, b3, c3, d3) {
              return M.easing.easeOutQuart(a3, b3, c3, d3);
            }, changeSection: function(a3) {
              for (var b3, c3, d3 = 0; d3 < P.length; d3++)
                b3 = f2[d3], c3 = P[d3], b3 *= a3, "undefined" === typeof n2[d3] && (n2[d3] = 0), 0 > n2 && (n2 *= -1), c3.y1 += b3 - n2[d3], c3.y2 += b3 - n2[d3], c3.y3 += b3 - n2[d3], c3.y4 += b3 - n2[d3], c3.y5 && (c3.y5 += b3 - n2[d3], c3.y6 += b3 - n2[d3]), n2[d3] = b3;
            } };
            a2._animator.animate(0, c2, function(c3) {
              var d3 = a2.plotArea.ctx || a2.ctx;
              ja3 = true;
              d3.clearRect(x.x1, x.y1, x.x2 - x.x1, x.y2 - x.y1);
              d3.fillStyle = a2.backgroundColor;
              d3.fillRect(x.x1, x.y1, x.width, x.height);
              w.changeSection(c3, b2);
              var e3 = {};
              e3.dataSeries = t;
              e3.dataPoint = t.reversed ? t.dataPoints[C.length - 1 - b2] : t.dataPoints[b2];
              e3.index = t.reversed ? C.length - 1 - b2 : b2;
              a2.toolTip.highlightObjects([e3]);
              for (e3 = 0; e3 < P.length; e3++)
                ra2(d3, P[e3], t.fillOpacity);
              v3(d3);
              H2 && ("inside" !== t.indexLabelPlacement ? s(d3) : g(), p2(d3));
              1 <= c3 && (ja3 = false);
            }, null, M.easing.easeOutQuart);
          }
          function m() {
            for (var a2 = 0, b2 = 0; b2 < P.length - 1; b2++)
              (0 <= W2.indexOf(b2) || 0 <= W2.indexOf(b2 + 1)) && a2++;
            return a2;
          }
          function s(a2) {
            for (var b2, c2, d2, e2, g2 = 0; g2 < P.length; g2++)
              e2 = 1 === J[g2].lineThickness % 2 ? 0.5 : 0, c2 = ((P[g2].y2 + P[g2].y4) / 2 << 0) + e2, b2 = f(c2).x2 - 1, d2 = J[g2].textBlock.x, e2 = (J[g2].textBlock.y + J[g2].height / 2 << 0) + e2, J[g2].isDirty || 0 == J[g2].lineThickness || (a2.strokeStyle = J[g2].lineColor, a2.lineWidth = J[g2].lineThickness, a2.setLineDash && a2.setLineDash(R(J[g2].lineDashType, J[g2].lineThickness)), a2.beginPath(), a2.moveTo(b2, c2), a2.lineTo(d2, e2), a2.stroke());
          }
          function q(a2) {
            for (a2 -= 1; -1 <= a2 && -1 != a2 && J[a2].isDirty; a2--)
              ;
            return a2;
          }
          function n(a2) {
            for (a2 += 1; a2 <= P.length && a2 != P.length && J[a2].isDirty; a2++)
              ;
            return a2;
          }
          function f(a2) {
            for (var b2, c2 = 0; c2 < C.length; c2++)
              if (P[c2].y1 < a2 && P[c2].y4 > a2) {
                b2 = P[c2];
                break;
              }
            return b2 ? (a2 = b2.y6 ? a2 > b2.y6 ? b2.x3 + (b2.x4 - b2.x3) / (b2.y4 - b2.y3) * (a2 - b2.y3) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a2 - b2.y2) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a2 - b2.y2), { x1: a2, x2: a2 }) : -1;
          }
          function p2(a2) {
            for (var b2 = 0; b2 < P.length; b2++)
              J[b2].isDirty || (a2 && (J[b2].textBlock.ctx = a2), J[b2].textBlock.render(true));
          }
          function v3(a2) {
            z2.plotArea.layoutManager.reset();
            a2.roundRect || Ea(a2);
            z2.title && (z2.title.dockInsidePlotArea || "center" === z2.title.horizontalAlign && "center" === z2.title.verticalAlign) && (z2.title.ctx = a2, z2.title.render());
            if (z2.subtitles)
              for (var b2 = 0; b2 < z2.subtitles.length; b2++) {
                var c2 = z2.subtitles[b2];
                if (c2.dockInsidePlotArea || "center" === c2.horizontalAlign && "center" === c2.verticalAlign)
                  z2.subtitles.ctx = a2, c2.render();
              }
            z2.legend && (z2.legend.dockInsidePlotArea || "center" === z2.legend.horizontalAlign && "center" === z2.legend.verticalAlign) && (z2.legend.ctx = a2, z2.legend.setLayout(), z2.legend.render());
            U.fNg && U.fNg(z2);
          }
          var z2 = this;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            for (var t = this.data[a.dataSeriesIndexes[0]], C = t.dataPoints, x = this.plotArea, D = 0.025 * x.width, y = 0.01 * x.width, A = 0, F2 = x.height - 2 * D, E3 = Math.min(x.width - 2 * y, 2.8 * x.height), H2 = false, I3 = 0; I3 < C.length; I3++)
              if (!H2 && ("undefined" !== typeof C[I3].indexLabel && null !== C[I3].indexLabel && 0 < C[I3].indexLabel.toString().length) && (H2 = true), !H2 && ("undefined" !== typeof C[I3].label && null !== C[I3].label && 0 < C[I3].label.toString().length) && (H2 = true), !H2 && "function" === typeof t.indexLabelFormatter || "function" === typeof C[I3].indexLabelFormatter)
                H2 = true;
            H2 = H2 || "undefined" !== typeof t.indexLabel && null !== t.indexLabel && 0 < t.indexLabel.toString().length;
            "inside" !== t.indexLabelPlacement && H2 || (y = (x.width - 0.75 * E3) / 2);
            var I3 = x.x1 + y, L2 = x.x2 - y, O2 = x.y1 + D, Z = x.y2 - D, Q3 = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;
            if (0 != t.length && (t.dataPoints && t.visible) && 0 !== C.length) {
              var N2, G;
              a = 75 * E3 / 100;
              var S2 = 30 * (L2 - a) / 100;
              "funnel" === t.type ? (N2 = u(t.options.neckHeight) ? 0.35 * F2 : t.neckHeight, G = u(t.options.neckWidth) ? 0.25 * a : t.neckWidth, "string" === typeof N2 && N2.match(/%$/) ? (N2 = parseInt(N2), N2 = N2 * F2 / 100) : N2 = parseInt(N2), "string" === typeof G && G.match(/%$/) ? (G = parseInt(G), G = G * a / 100) : G = parseInt(G), N2 > F2 ? N2 = F2 : 0 >= N2 && (N2 = 0), G > a ? G = a - 0.5 : 0 >= G && (G = 0)) : "pyramid" === t.type && (G = N2 = 0, t.reversed = t.reversed ? false : true);
              var y = I3 + a / 2, $3 = I3, V2 = I3 + a, pa = t.reversed ? Z : O2, K = y - G / 2, ea2 = y + G / 2, Da = t.reversed ? O2 + N2 : Z - N2, wa = t.reversed ? O2 : Z;
              a = [];
              var y = [], P = [], E3 = [], X3 = O2, fa3, ba2 = (Da - pa) / (K - $3), ha3 = -ba2, I3 = "area" === (t.valueRepresents ? t.valueRepresents : "height") ? b() : d();
              if (-1 !== I3) {
                if (t.reversed)
                  for (E3.push(X3), G = I3.length - 1; 0 < G; G--)
                    X3 += I3[G], E3.push(X3);
                else
                  for (G = 0; G < I3.length; G++)
                    X3 += I3[G], E3.push(X3);
                if (t.reversed)
                  for (G = 0; G < I3.length; G++)
                    E3[G] < Da ? (a.push(K), y.push(ea2), fa3 = G) : (a.push((E3[G] - pa + ba2 * $3) / ba2), y.push((E3[G] - pa + ha3 * V2) / ha3));
                else
                  for (G = 0; G < I3.length; G++)
                    E3[G] < Da ? (a.push((E3[G] - pa + ba2 * $3) / ba2), y.push((E3[G] - pa + ha3 * V2) / ha3), fa3 = G) : (a.push(K), y.push(ea2));
                for (G = 0; G < I3.length - 1; G++)
                  X3 = t.reversed ? C[C.length - 1 - G].color ? C[C.length - 1 - G].color : t._colorSet[(C.length - 1 - G) % t._colorSet.length] : C[G].color ? C[G].color : t._colorSet[G % t._colorSet.length], G === fa3 ? P.push({ x1: a[G], y1: E3[G], x2: y[G], y2: E3[G], x3: ea2, y3: Da, x4: y[G + 1], y4: E3[G + 1], x5: a[G + 1], y5: E3[G + 1], x6: K, y6: Da, id: G, height: E3[G + 1] - E3[G], color: X3 }) : P.push({ x1: a[G], y1: E3[G], x2: y[G], y2: E3[G], x3: y[G + 1], y3: E3[G + 1], x4: a[G + 1], y4: E3[G + 1], id: G, height: E3[G + 1] - E3[G], color: X3 });
                var ga3 = 2, J = [], ja3 = false, W2 = [], ia2 = [], I3 = false;
                a = a = 0;
                Fa(W2);
                for (G = 0; G < C.length; G++)
                  C[G].exploded && (I3 = true, t.reversed ? W2.push(C.length - 1 - G) : W2.push(G));
                Q3.clearRect(x.x1, x.y1, x.width, x.height);
                Q3.fillStyle = z2.backgroundColor;
                Q3.fillRect(x.x1, x.y1, x.width, x.height);
                if (H2 && t.visible && (c(), g(), e(), "inside" !== t.indexLabelPlacement)) {
                  k();
                  for (G = 0; G < C.length; G++)
                    J[G].isDirty || (a = J[G].textBlock.x + J[G].width, a = (L2 - a) / 2, 0 == G && (A = a), A > a && (A = a));
                  for (G = 0; G < P.length; G++)
                    P[G].x1 += A, P[G].x2 += A, P[G].x3 += A, P[G].x4 += A, P[G].x5 && (P[G].x5 += A, P[G].x6 += A), J[G].textBlock.x += A;
                }
                for (G = 0; G < P.length; G++)
                  A = P[G], ra2(Q3, A, t.fillOpacity), ia2.push(A.y1);
                v3(Q3);
                H2 && t.visible && ("inside" === t.indexLabelPlacement || z2.animationEnabled || s(Q3), z2.animationEnabled || p2());
                if (!H2)
                  for (G = 0; G < C.length; G++)
                    A = t.dataPointIds[G], a = { id: A, objectType: "dataPoint", dataPointIndex: G, dataSeriesIndex: 0, funnelSection: P[t.reversed ? C.length - 1 - G : G] }, z2._eventManager.objectMap[A] = a;
                !z2.animationEnabled && I3 ? h2(z2, -1, 0) : z2.animationEnabled && !z2.animatedRender && h2(z2, -1, 0);
                this.funnelPyramidClickHandler = function(a2) {
                  var b2 = -1;
                  if (!ja3 && !z2.isAnimating && (u(a2.dataSeries.explodeOnClick) || a2.dataSeries.explodeOnClick) && (b2 = t.reversed ? C.length - 1 - a2.dataPointIndex : a2.dataPointIndex, 0 <= b2)) {
                    a2 = b2;
                    if ("funnel" === t.type || "pyramid" === t.type)
                      t.reversed ? C[C.length - 1 - a2].exploded = C[C.length - 1 - a2].exploded ? false : true : C[a2].exploded = C[a2].exploded ? false : true;
                    h2(z2, b2, 500);
                  }
                };
                return { source: Q3, dest: this.plotArea.ctx, animationCallback: function(a2, b2) {
                  M.fadeInAnimation(a2, b2);
                  1 <= a2 && (h2(z2, -1, 500), v3(z2.plotArea.ctx || z2.ctx));
                }, easingFunction: M.easing.easeInQuad, animationBase: 0 };
              }
            }
          }
        };
        p.prototype.requestAnimFrame = function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
            window.setTimeout(a, 1e3 / 60);
          };
        }();
        p.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
        p.prototype.set = function(a, d, b) {
          b = "undefined" === typeof b ? true : b;
          "options" === a ? (this.options = d, b && this.render()) : p.base.set.call(this, a, d, b);
        };
        p.prototype.exportChart = function(a) {
          a = "undefined" === typeof a ? {} : a;
          var d = a.format ? a.format : "png", b = a.fileName ? a.fileName : this.exportFileName;
          if (a.toDataURL)
            return this.canvas.toDataURL("image/" + d);
          Ta(this.canvas, d, b);
        };
        p.prototype.print = function() {
          var a = this.exportChart({ toDataURL: true }), d = document.createElement("iframe");
          d.setAttribute("class", "canvasjs-chart-print-frame");
          d.setAttribute("style", "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;");
          d.style.height = this.height + "px";
          this._canvasJSContainer.appendChild(d);
          var b = this, c = d.contentWindow || d.contentDocument.document || d.contentDocument;
          c.document.open();
          c.document.write('<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' + a + '"/><body/></html>');
          c.document.close();
          setTimeout(function() {
            c.focus();
            c.print();
            setTimeout(function() {
              b._canvasJSContainer.removeChild(d);
            }, 1e3);
          }, 500);
        };
        p.prototype.getPercentAndTotal = function(a, d) {
          var b = null, c = null, e = null;
          if (0 <= a.type.indexOf("stacked"))
            c = 0, b = d.x.getTime ? d.x.getTime() : d.x, b in a.plotUnit.yTotals && (c = a.plotUnit.yTotals[b], e = isNaN(d.y) ? 0 : 100 * (d.y / c));
          else if ("pie" === a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type) {
            for (b = c = 0; b < a.dataPoints.length; b++)
              isNaN(a.dataPoints[b].y) || (c += a.dataPoints[b].y);
            e = isNaN(d.y) ? 0 : 100 * (d.y / c);
          }
          return { percent: e, total: c };
        };
        p.prototype.replaceKeywordsWithValue = function(a, d, b, c, e) {
          var g = this;
          e = "undefined" === typeof e ? 0 : e;
          if ((0 <= b.type.indexOf("stacked") || "pie" === b.type || "doughnut" === b.type || "funnel" === b.type || "pyramid" === b.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) {
            var k = "#percent", l = "#total", h2 = this.getPercentAndTotal(b, d), l = isNaN(h2.total) ? l : h2.total, k = isNaN(h2.percent) ? k : h2.percent;
            do {
              h2 = "";
              if (b.percentFormatString)
                h2 = b.percentFormatString;
              else {
                var h2 = "#,##0.", m = Math.max(Math.ceil(Math.log(1 / Math.abs(k)) / Math.LN10), 2);
                if (isNaN(m) || !isFinite(m))
                  m = 2;
                for (var s = 0; s < m; s++)
                  h2 += "#";
                b.percentFormatString = h2;
              }
              a = a.replace("#percent", ba(k, h2, g._cultureInfo));
              a = a.replace("#total", ba(l, b.yValueFormatString ? b.yValueFormatString : "#,##0.########", g._cultureInfo));
            } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"));
          }
          return a.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, function(a2) {
            if ('"' === a2[0] && '"' === a2[a2.length - 1] || "'" === a2[0] && "'" === a2[a2.length - 1])
              return a2.slice(1, a2.length - 1);
            a2 = Ia(a2.slice(1, a2.length - 1));
            a2 = a2.replace("#index", e);
            var k2 = null;
            try {
              var f = a2.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
              f && 0 < f.length && (k2 = Ia(f[2]), a2 = Ia(f[1]));
            } catch (l2) {
            }
            f = null;
            if ("color" === a2)
              return "waterfall" === b.type ? d.color ? d.color : 0 < d.y ? b.risingColor : b.fallingColor : "error" === b.type ? b.color ? b.color : b._colorSet[k2 % b._colorSet.length] : d.color ? d.color : b.color ? b.color : b._colorSet[c % b._colorSet.length];
            if (d.hasOwnProperty(a2))
              f = d;
            else if (b.hasOwnProperty(a2))
              f = b;
            else
              return "";
            f = f[a2];
            null !== k2 && (f = f[k2]);
            if ("x" === a2)
              if ("dateTime" === b.axisX.valueType || "dateTime" === b.xValueType || d.x && d.x.getTime) {
                if (g.plotInfo.plotTypes[0].plotUnits[0].axisX && !g.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic)
                  return Ca(f, d.xValueFormatString ? d.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = g.axisX && g.axisX.autoValueFormatString ? g.axisX.autoValueFormatString : "DD MMM YY", g._cultureInfo);
              } else
                return ba(f, d.xValueFormatString ? d.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = "#,##0.########", g._cultureInfo);
            else
              return "y" === a2 ? ba(f, d.yValueFormatString ? d.yValueFormatString : b.yValueFormatString ? b.yValueFormatString : b.yValueFormatString = "#,##0.########", g._cultureInfo) : "z" === a2 ? ba(f, d.zValueFormatString ? d.zValueFormatString : b.zValueFormatString ? b.zValueFormatString : b.zValueFormatString = "#,##0.########", g._cultureInfo) : f;
          });
        };
        qa(H, V);
        H.prototype.setLayout = function() {
          var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, d = a.layoutManager.getFreeSpace(), b = null, c = 0, e = 0, g = 0, k = 0, l = this.markerMargin = this.chart.options.legend && !u(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;
          this.height = 0;
          var h2 = [], m = [];
          "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (this.orientation = "horizontal", b = this.verticalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : d.width, k = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * d.height) : "center" === this.verticalAlign && (this.orientation = "vertical", b = this.horizontalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * d.width, k = this.maxHeight = null !== this.maxHeight ? this.maxHeight : d.height);
          this.errorMarkerColor = [];
          for (var s = 0; s < this.dataSeries.length; s++) {
            var q = this.dataSeries[s];
            if (q.dataPoints && q.dataPoints.length)
              if ("pie" !== q.type && "doughnut" !== q.type && "funnel" !== q.type && "pyramid" !== q.type) {
                var n = q.legendMarkerType = q.legendMarkerType ? q.legendMarkerType : "line" !== q.type && "stepLine" !== q.type && "spline" !== q.type && "scatter" !== q.type && "bubble" !== q.type || !q.markerType ? "error" === q.type && q._linkedSeries ? q._linkedSeries.legendMarkerType ? q._linkedSeries.legendMarkerType : F.getDefaultLegendMarker(q._linkedSeries.type) : F.getDefaultLegendMarker(q.type) : q.markerType, f = q.legendText ? q.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: q, dataPoint: null }) : q.name, p2 = q.legendMarkerColor = q.legendMarkerColor ? q.legendMarkerColor : q.markerColor ? q.markerColor : "error" === q.type ? u(q.whiskerColor) ? q._colorSet[0] : q.whiskerColor : q._colorSet[0], r2 = q.markerSize || "line" !== q.type && "stepLine" !== q.type && "spline" !== q.type ? 0.75 * this.lineHeight : 0, v3 = q.legendMarkerBorderColor ? q.legendMarkerBorderColor : q.markerBorderColor, t = q.legendMarkerBorderThickness ? q.legendMarkerBorderThickness : q.markerBorderThickness ? Math.max(1, Math.round(0.2 * r2)) : 0;
                "error" === q.type && this.errorMarkerColor.push(p2);
                f = this.chart.replaceKeywordsWithValue(f, q.dataPoints[0], q, s);
                n = { markerType: n, markerColor: p2, text: f, textBlock: null, chartType: q.type, markerSize: r2, lineColor: q._colorSet[0], dataSeriesIndex: q.index, dataPointIndex: null, markerBorderColor: v3, markerBorderThickness: t };
                h2.push(n);
              } else
                for (var z2 = 0; z2 < q.dataPoints.length; z2++) {
                  var x = q.dataPoints[z2], n = x.legendMarkerType ? x.legendMarkerType : q.legendMarkerType ? q.legendMarkerType : F.getDefaultLegendMarker(q.type), f = x.legendText ? x.legendText : q.legendText ? q.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: q, dataPoint: x }) : x.name ? x.name : "DataPoint: " + (z2 + 1), p2 = x.legendMarkerColor ? x.legendMarkerColor : q.legendMarkerColor ? q.legendMarkerColor : x.color ? x.color : q.color ? q.color : q._colorSet[z2 % q._colorSet.length], r2 = 0.75 * this.lineHeight, v3 = x.legendMarkerBorderColor ? x.legendMarkerBorderColor : q.legendMarkerBorderColor ? q.legendMarkerBorderColor : x.markerBorderColor ? x.markerBorderColor : q.markerBorderColor, t = x.legendMarkerBorderThickness ? x.legendMarkerBorderThickness : q.legendMarkerBorderThickness ? q.legendMarkerBorderThickness : x.markerBorderThickness || q.markerBorderThickness ? Math.max(1, Math.round(0.2 * r2)) : 0, f = this.chart.replaceKeywordsWithValue(f, x, q, z2), n = { markerType: n, markerColor: p2, text: f, textBlock: null, chartType: q.type, markerSize: r2, dataSeriesIndex: s, dataPointIndex: z2, markerBorderColor: v3, markerBorderThickness: t };
                  (x.showInLegend || q.showInLegend && false !== x.showInLegend) && h2.push(n);
                }
          }
          true === this.reversed && h2.reverse();
          if (0 < h2.length) {
            q = null;
            p2 = f = x = z2 = 0;
            x = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, g) : this.itemMaxWidth = Math.min(this.itemWidth, g) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, g) : this.itemMaxWidth = g;
            r2 = 0 === r2 ? 0.75 * this.lineHeight : r2;
            x -= r2 + l;
            for (s = 0; s < h2.length; s++) {
              n = h2[s];
              v3 = x;
              if ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType)
                v3 -= 2 * 0.1 * this.lineHeight;
              if (!(0 >= k || "undefined" === typeof k || 0 >= v3 || "undefined" === typeof v3)) {
                if ("horizontal" === this.orientation) {
                  n.textBlock = new ka(this.ctx, { x: 0, y: 0, maxWidth: v3, maxHeight: this.itemWrap ? k : this.lineHeight, angle: 0, text: n.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" });
                  n.textBlock.measureText();
                  null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (r2 + l + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * 0.1 * this.lineHeight : 0)));
                  if (!q || q.width + Math.round(n.textBlock.width + r2 + l + (0 === q.width ? 0 : this.horizontalSpacing) + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * 0.1 * this.lineHeight : 0)) > g)
                    q = { items: [], width: 0 }, m.push(q), this.height += f, f = 0;
                  f = Math.max(f, n.textBlock.height);
                } else
                  n.textBlock = new ka(this.ctx, {
                    x: 0,
                    y: 0,
                    maxWidth: x,
                    maxHeight: true === this.itemWrap ? k : 1.5 * this.fontSize,
                    angle: 0,
                    text: n.text,
                    horizontalAlign: "left",
                    fontSize: this.fontSize,
                    fontFamily: this.fontFamily,
                    fontWeight: this.fontWeight,
                    fontColor: this.fontColor,
                    fontStyle: this.fontStyle,
                    textBaseline: "middle"
                  }), n.textBlock.measureText(), null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (r2 + l + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < k - this.lineHeight ? (q = { items: [], width: 0 }, m.push(q)) : (q = m[z2], z2 = (z2 + 1) % m.length), this.height += n.textBlock.height;
                n.textBlock.x = q.width;
                n.textBlock.y = 0;
                q.width += Math.round(n.textBlock.width + r2 + l + (0 === q.width ? 0 : this.horizontalSpacing) + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * 0.1 * this.lineHeight : 0));
                q.items.push(n);
                this.width = Math.max(q.width, this.width);
                p2 = n.textBlock.width + (r2 + l + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * 0.1 * this.lineHeight : 0));
              }
            }
            this.itemWidth = p2;
            this.height = false === this.itemWrap ? m.length * this.lineHeight : this.height + f;
            this.height = Math.min(k, this.height);
            this.width = Math.min(g, this.width);
          }
          "top" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? d.x1 : "right" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y1) : "center" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? d.x1 : "right" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y1 + d.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (e = "left" === this.horizontalAlign ? d.x1 : "right" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y2 - this.height);
          this.items = h2;
          for (s = 0; s < this.items.length; s++)
            n = h2[s], n.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[n.id] = { id: n.id, objectType: "legendItem", legendItemIndex: s, dataSeriesIndex: n.dataSeriesIndex, dataPointIndex: n.dataPointIndex };
          this.markerSize = r2;
          this.rows = m;
          0 < h2.length && a.layoutManager.registerSpace(b, { width: this.width + 2 + 2, height: this.height + 5 + 5 });
          this.bounds = { x1: e, y1: c, x2: e + this.width, y2: c + this.height };
        };
        H.prototype.render = function() {
          var a = this.bounds.x1, d = this.bounds.y1, b = this.markerMargin, c = this.maxWidth, e = this.maxHeight, g = this.markerSize, k = this.rows;
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(a, d, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
          for (var l = 0, h2 = 0; h2 < k.length; h2++) {
            for (var m = k[h2], s = 0, q = 0; q < m.items.length; q++) {
              var n = m.items[q], f = n.textBlock.x + a + (0 === q ? 0.2 * g : this.horizontalSpacing), p2 = d + l, u2 = f;
              this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(a, d, c, Math.max(e - e % this.lineHeight, 0));
              this.ctx.clip();
              if ("line" === n.chartType || "stepLine" === n.chartType || "spline" === n.chartType)
                this.ctx.strokeStyle = n.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(f - 0.1 * this.lineHeight, p2 + this.lineHeight / 2), this.ctx.lineTo(f + 0.85 * this.lineHeight, p2 + this.lineHeight / 2), this.ctx.stroke(), u2 -= 0.1 * this.lineHeight;
              if ("error" === n.chartType) {
                this.ctx.strokeStyle = this.errorMarkerColor[0];
                this.ctx.lineWidth = g / 8;
                this.ctx.beginPath();
                var r2 = f - 0.08 * this.lineHeight + 0.1 * this.lineHeight, t = p2 + 0.15 * this.lineHeight, v3 = 0.7 * this.lineHeight, x = v3 + 0.02 * this.lineHeight;
                this.ctx.moveTo(r2, t);
                this.ctx.lineTo(r2 + v3, t);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(r2 + v3 / 2, t);
                this.ctx.lineTo(r2 + v3 / 2, t + x);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(r2, t + x);
                this.ctx.lineTo(r2 + v3, t + x);
                this.ctx.stroke();
                this.errorMarkerColor.shift();
              }
              ia.drawMarker(
                f + g / 2,
                p2 + this.lineHeight / 2,
                this.ctx,
                n.markerType,
                "error" === n.chartType || "line" === n.chartType || "spline" === n.chartType ? n.markerSize / 2 : n.markerSize,
                n.markerColor,
                n.markerBorderColor,
                n.markerBorderThickness
              );
              n.textBlock.x = f + b + g;
              if ("line" === n.chartType || "stepLine" === n.chartType || "spline" === n.chartType)
                n.textBlock.x += 0.1 * this.lineHeight;
              n.textBlock.y = Math.round(p2 + this.lineHeight / 2);
              n.textBlock.render(true);
              this.ctx.restore();
              s = 0 < q ? Math.max(s, n.textBlock.height) : n.textBlock.height;
              this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);
              f = N(n.id);
              this.ghostCtx.fillStyle = f;
              this.ghostCtx.beginPath();
              this.ghostCtx.fillRect(u2, n.textBlock.y - this.lineHeight / 2, n.textBlock.x + n.textBlock.width - u2, n.textBlock.height);
              n.x1 = this.chart._eventManager.objectMap[n.id].x1 = u2;
              n.y1 = this.chart._eventManager.objectMap[n.id].y1 = n.textBlock.y - this.lineHeight / 2;
              n.x2 = this.chart._eventManager.objectMap[n.id].x2 = n.textBlock.x + n.textBlock.width;
              n.y2 = this.chart._eventManager.objectMap[n.id].y2 = n.textBlock.y + n.textBlock.height - this.lineHeight / 2;
            }
            l += s;
          }
        };
        qa(F, V);
        F.prototype.getDefaultAxisPlacement = function() {
          var a = this.type;
          if ("column" === a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a)
            return "normal";
          if ("bar" === a || "stackedBar" === a || "stackedBar100" === a || "rangeBar" === a)
            return "xySwapped";
          if ("pie" === a || "doughnut" === a || "funnel" === a || "pyramid" === a)
            return "none";
          "error" !== a && window.console.log("Unknown Chart Type: " + a);
          return null;
        };
        F.getDefaultLegendMarker = function(a) {
          if ("column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a)
            return "square";
          if ("line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a)
            return "circle";
          if ("area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a || "funnel" === a || "pyramid" === a)
            return "triangle";
          if ("error" === a)
            return "none";
          window.console.log("Unknown Chart Type: " + a);
          return null;
        };
        F.prototype.getDataPointAtX = function(a, d) {
          if (!this.dataPoints || 0 === this.dataPoints.length)
            return null;
          var b = { dataPoint: null, distance: Infinity, index: NaN }, c = null, e = 0, g = 0, k = 1, l = Infinity, h2 = 0, m = 0, s = 0;
          "none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (s = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), s = 1 < s ? Math.min(Math.max((this.dataPoints.length - 1) / s * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (s = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, s = 0 < s ? Math.min(Math.max((this.dataPoints.length - 1) / s * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));
          for (; ; ) {
            g = 0 < k ? s + e : s - e;
            if (0 <= g && g < this.dataPoints.length) {
              var c = this.dataPoints[g], q = this.axisX.logarithmic ? c.x > a ? c.x / a : a / c.x : Math.abs(c.x - a);
              q < b.distance && (b.dataPoint = c, b.distance = q, b.index = g);
              c = q;
              c <= l ? l = c : 0 < k ? h2++ : m++;
              if (1e3 < h2 && 1e3 < m)
                break;
            } else if (0 > s - e && s + e >= this.dataPoints.length)
              break;
            -1 === k ? (e++, k = 1) : k = -1;
          }
          return d || b.dataPoint.x !== a ? d && null !== b.dataPoint ? b : null : b;
        };
        F.prototype.getDataPointAtXY = function(a, d, b) {
          if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || d < this.chart.plotArea.y1 || d > this.chart.plotArea.y2)
            return null;
          b = b || false;
          var c = [], e = 0, g = 0, k = 1, l = false, h2 = Infinity, m = 0, s = 0, q = 0;
          if ("none" !== this.chart.plotInfo.axisPlacement)
            if (q = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a, y: d }), this.axisX.logarithmic)
              var n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), q = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(q / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
            else
              n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, q = 0 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * (q - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
          for (; ; ) {
            g = 0 < k ? q + e : q - e;
            if (0 <= g && g < this.dataPoints.length) {
              var n = this.chart._eventManager.objectMap[this.dataPointIds[g]], f = this.dataPoints[g], p2 = null;
              if (n) {
                switch (this.type) {
                  case "column":
                  case "stackedColumn":
                  case "stackedColumn100":
                  case "bar":
                  case "stackedBar":
                  case "stackedBar100":
                  case "rangeColumn":
                  case "rangeBar":
                  case "waterfall":
                  case "error":
                    a >= n.x1 && (a <= n.x2 && d >= n.y1 && d <= n.y2) && (c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y1 - d), Math.abs(n.y2 - d)) }), l = true);
                    break;
                  case "line":
                  case "stepLine":
                  case "spline":
                  case "area":
                  case "stepArea":
                  case "stackedArea":
                  case "stackedArea100":
                  case "splineArea":
                  case "scatter":
                    var u2 = na("markerSize", f, this) || 4, r2 = b ? 20 : u2, p2 = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - d, 2));
                    p2 <= r2 && c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: p2 });
                    n = Math.abs(n.x1 - a);
                    n <= h2 ? h2 = n : 0 < k ? m++ : s++;
                    p2 <= u2 / 2 && (l = true);
                    break;
                  case "rangeArea":
                  case "rangeSplineArea":
                    u2 = na("markerSize", f, this) || 4;
                    r2 = b ? 20 : u2;
                    p2 = Math.min(Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - d, 2)), Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y2 - d, 2)));
                    p2 <= r2 && c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: p2 });
                    n = Math.abs(n.x1 - a);
                    n <= h2 ? h2 = n : 0 < k ? m++ : s++;
                    p2 <= u2 / 2 && (l = true);
                    break;
                  case "bubble":
                    u2 = n.size;
                    p2 = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - d, 2));
                    p2 <= u2 / 2 && (c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: p2 }), l = true);
                    break;
                  case "pie":
                  case "doughnut":
                    u2 = n.center;
                    r2 = "doughnut" === this.type ? n.percentInnerRadius * n.radius : 0;
                    p2 = Math.sqrt(Math.pow(u2.x - a, 2) + Math.pow(u2.y - d, 2));
                    p2 < n.radius && p2 > r2 && (p2 = Math.atan2(d - u2.y, a - u2.x), 0 > p2 && (p2 += 2 * Math.PI), p2 = Number(((180 * (p2 / Math.PI) % 360 + 360) % 360).toFixed(12)), u2 = Number(((180 * (n.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), r2 = Number(((180 * (n.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === r2 && 1 < n.endAngle && (r2 = 360), u2 >= r2 && 0 !== f.y && (r2 += 360, p2 < u2 && (p2 += 360)), p2 > u2 && p2 < r2 && (c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: 0 }), l = true));
                    break;
                  case "funnel":
                  case "pyramid":
                    p2 = n.funnelSection;
                    d > p2.y1 && d < p2.y4 && (p2.y6 ? d > p2.y6 ? (g = p2.x6 + (p2.x5 - p2.x6) / (p2.y5 - p2.y6) * (d - p2.y6), p2 = p2.x3 + (p2.x4 - p2.x3) / (p2.y4 - p2.y3) * (d - p2.y3)) : (g = p2.x1 + (p2.x6 - p2.x1) / (p2.y6 - p2.y1) * (d - p2.y1), p2 = p2.x2 + (p2.x3 - p2.x2) / (p2.y3 - p2.y2) * (d - p2.y2)) : (g = p2.x1 + (p2.x4 - p2.x1) / (p2.y4 - p2.y1) * (d - p2.y1), p2 = p2.x2 + (p2.x3 - p2.x2) / (p2.y3 - p2.y2) * (d - p2.y2)), a > g && a < p2 && (c.push({ dataPoint: f, dataPointIndex: n.dataPointIndex, dataSeries: this, distance: 0 }), l = true));
                    break;
                  case "boxAndWhisker":
                    if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && d >= n.y4 - n.borderThickness / 2 && d <= n.y1 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && d >= n.y1 && d <= n.y4)
                      c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - d), Math.abs(n.y3 - d)) }), l = true;
                    break;
                  case "candlestick":
                    if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && d >= n.y2 - n.borderThickness / 2 && d <= n.y3 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && d >= n.y1 && d <= n.y4)
                      c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(
                        Math.abs(n.x1 - a),
                        Math.abs(n.x2 - a),
                        Math.abs(n.y2 - d),
                        Math.abs(n.y3 - d)
                      ) }), l = true;
                    break;
                  case "ohlc":
                    if (Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && d >= n.y2 && d <= n.y3 || a >= n.x1 && a <= (n.x2 + n.x1) / 2 && d >= n.y1 - n.borderThickness / 2 && d <= n.y1 + n.borderThickness / 2 || a >= (n.x1 + n.x2) / 2 && a <= n.x2 && d >= n.y4 - n.borderThickness / 2 && d <= n.y4 + n.borderThickness / 2)
                      c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - d), Math.abs(n.y3 - d)) }), l = true;
                }
                if (l || 1e3 < m && 1e3 < s)
                  break;
              }
            } else if (0 > q - e && q + e >= this.dataPoints.length)
              break;
            -1 === k ? (e++, k = 1) : k = -1;
          }
          a = null;
          for (d = 0; d < c.length; d++)
            a ? c[d].distance <= a.distance && (a = c[d]) : a = c[d];
          return a;
        };
        F.prototype.getMarkerProperties = function(a, d, b, c) {
          var e = this.dataPoints;
          return { x: d, y: b, ctx: c, type: e[a].markerType ? e[a].markerType : this.markerType, size: e[a].markerSize ? e[a].markerSize : this.markerSize, color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor : e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], borderColor: e[a].markerBorderColor ? e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null };
        };
        qa(z, V);
        z.prototype.createExtraLabelsForLog = function(a) {
          a = (a || 0) + 1;
          if (!(5 < a)) {
            var d = this.logLabelValues[0] || this.intervalStartPosition;
            if (Math.log(this.range) / Math.log(d / this.viewportMinimum) < this.noTicks - 1) {
              for (var b = z.getNiceNumber((d - this.viewportMinimum) / Math.min(
                Math.max(2, this.noTicks - this.logLabelValues.length),
                3
              ), true), c = Math.ceil(this.viewportMinimum / b) * b; c < d; c += b)
                c < this.viewportMinimum || this.logLabelValues.push(c);
              this.logLabelValues.sort(Sa);
              this.createExtraLabelsForLog(a);
            }
          }
        };
        z.prototype.createLabels = function() {
          var a, d, b = 0, c = 0, e, g = 0, k = 0, c = 0, c = this.interval, l = 0, h2, m = 0.6 * this.chart.height, p2;
          a = false;
          var q = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], n = q.length ? u(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;
          if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
            e = this.viewportMaximum;
            if (this.labels) {
              a = Math.ceil(c);
              for (var c = Math.ceil(this.intervalStartPosition), f = false, b = c; b < this.viewportMaximum; b += a)
                if (this.labels[b])
                  f = true;
                else {
                  f = false;
                  break;
                }
              f && (this.interval = a, this.intervalStartPosition = c);
            }
            if (this.logarithmic && !this.equidistantInterval)
              for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), c = 0, f = n; c < this.logLabelValues.length; c++)
                if (b = this.logLabelValues[c], b < this.viewportMinimum)
                  c++;
                else {
                  for (; f < q.length && b > q[f].endValue; f++)
                    ;
                  a = f < q.length && b >= q[f].startValue && b <= q[f].endValue;
                  p2 = b;
                  a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: p2, label: this.labels[p2] ? this.labels[p2] : null }) : "axisX" === this.type && this.labels[p2] ? this.labels[p2] : ba(p2, this.valueFormatString, this.chart._cultureInfo), a = new ka(this.ctx, {
                    x: 0,
                    y: 0,
                    maxWidth: g,
                    maxHeight: k,
                    angle: this.labelAngle,
                    text: this.prefix + a + this.suffix,
                    backgroundColor: this.labelBackgroundColor,
                    borderColor: this.labelBorderColor,
                    borderThickness: this.labelBorderThickness,
                    cornerRadius: this.labelCornerRadius,
                    horizontalAlign: "left",
                    fontSize: this.labelFontSize,
                    fontFamily: this.labelFontFamily,
                    fontWeight: this.labelFontWeight,
                    fontColor: this.labelFontColor,
                    fontStyle: this.labelFontStyle,
                    textBaseline: "middle",
                    borderThickness: 0
                  }), this._labels.push({ position: p2, textBlock: a, effectiveHeight: null }));
                }
            f = n;
            for (b = this.intervalStartPosition; b <= e; b = parseFloat(1e-12 > this.interval ? this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase, this.interval) : b + this.interval : (this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase, this.interval) : b + this.interval).toFixed(12))) {
              for (; f < q.length && b > q[f].endValue; f++)
                ;
              a = f < q.length && b >= q[f].startValue && b <= q[f].endValue;
              p2 = b;
              a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: p2, label: this.labels[p2] ? this.labels[p2] : null }) : "axisX" === this.type && this.labels[p2] ? this.labels[p2] : ba(p2, this.valueFormatString, this.chart._cultureInfo), a = new ka(this.ctx, {
                x: 0,
                y: 0,
                maxWidth: g,
                maxHeight: k,
                angle: this.labelAngle,
                text: this.prefix + a + this.suffix,
                horizontalAlign: "left",
                backgroundColor: this.labelBackgroundColor,
                borderColor: this.labelBorderColor,
                borderThickness: this.labelBorderThickness,
                cornerRadius: this.labelCornerRadius,
                fontSize: this.labelFontSize,
                fontFamily: this.labelFontFamily,
                fontWeight: this.labelFontWeight,
                fontColor: this.labelFontColor,
                fontStyle: this.labelFontStyle,
                textBaseline: "middle"
              }), this._labels.push({ position: p2, textBlock: a, effectiveHeight: null }));
            }
          } else
            for (this.intervalStartPosition = this.getLabelStartPoint(
              new Date(this.viewportMinimum),
              this.intervalType,
              this.interval
            ), e = Ya(new Date(this.viewportMaximum), this.interval, this.intervalType), f = n, b = this.intervalStartPosition; b < e; Ya(b, c, this.intervalType)) {
              for (a = b.getTime(); f < q.length && a > q[f].endValue; f++)
                ;
              p2 = a;
              a = f < q.length && a >= q[f].startValue && a <= q[f].endValue;
              a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: new Date(p2), label: this.labels[p2] ? this.labels[p2] : null }) : "axisX" === this.type && this.labels[p2] ? this.labels[p2] : Ca(p2, this.valueFormatString, this.chart._cultureInfo), a = new ka(this.ctx, { x: 0, y: 0, maxWidth: g, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxHeight: k, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }), this._labels.push({
                position: p2,
                textBlock: a,
                effectiveHeight: null,
                breaksLabelType: void 0
              }));
            }
          if ("bottom" === this._position || "top" === this._position)
            l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * S[this.intervalType + "Duration"] * this.interval, g = "undefined" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (k = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);
          else if ("left" === this._position || "right" === this._position)
            l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * S[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (g = "undefined" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), k = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
          for (c = 0; c < this._labels.length; c++) {
            a = this._labels[c].textBlock;
            a.maxWidth = g;
            a.maxHeight = k;
            var B = a.measureText();
            h2 = B.height;
          }
          e = [];
          n = q = 0;
          if (this.labelAutoFit || this.options.labelAutoFit) {
            if (u(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position)
              if (g = 0.9 * l >> 0, n = 0, !this.chart.panEnabled && 1 <= this._labels.length) {
                this.sessionVariables.labelFontSize = this.labelFontSize;
                this.sessionVariables.labelMaxWidth = g;
                this.sessionVariables.labelMaxHeight = k;
                this.sessionVariables.labelAngle = this.labelAngle;
                this.sessionVariables.labelWrap = this.labelWrap;
                for (b = 0; b < this._labels.length; b++)
                  if (!this._labels[b].breaksLabelType) {
                    a = this._labels[b].textBlock;
                    for (var v3, f = a.text.split(" "), c = 0; c < f.length; c++)
                      p2 = f[c], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, p2 = this.ctx.measureText(p2), p2.width > n && (v3 = b, n = p2.width);
                  }
                b = 0;
                for (b = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; b < this._labels.length; b++)
                  if (!this._labels[b].breaksLabelType) {
                    a = this._labels[b].textBlock;
                    B = a.measureText();
                    for (f = b + 1; f < this._labels.length; f++)
                      if (!this._labels[f].breaksLabelType) {
                        d = this._labels[f].textBlock;
                        d = d.measureText();
                        break;
                      }
                    e.push(a.height);
                    this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);
                    Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                    c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (k - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    if (u(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle)
                      if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), p2 = (m - (h2 + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !u(this.options.labelWrap))
                        this.labelWrap ? u(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), p2), this.sessionVariables.labelWrap = this.labelWrap, B.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle) : u(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelMaxWidth = g, B.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p2)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelWrap = this.labelWrap);
                      else {
                        if (u(this.options.labelWrap)) {
                          if (!u(this.options.labelMaxWidth))
                            this.options.labelMaxWidth < g ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = k);
                          else if (!u(d)) {
                            if (c = B.width + d.width >> 0, f = this.labelFontSize, n < g)
                              c - 2 * g > q && (q = c - 2 * g, c >= 2 * g && c < 2.2 * g ? (this.sessionVariables.labelMaxWidth = g, u(this.options.labelFontSize) && 12 < f && (f = Math.floor(12 / 13 * f), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 2.2 * g && c < 2.8 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p2, this.sessionVariables.labelFontSize = f) : c >= 2.8 * g && c < 3.2 * g ? (this.sessionVariables.labelMaxWidth = Math.max(g, n), this.sessionVariables.labelWrap = true, u(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 3.2 * g && c < 3.6 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = p2, this.sessionVariables.labelFontSize = this.labelFontSize) : c > 3.6 * g && c < 5 * g ? (u(this.options.labelFontSize) && 12 < f && (f = Math.floor(12 / 13 * f), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p2) : c > 5 * g && (this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelFontSize = f, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelAngle = this.labelAngle));
                            else if (v3 === b && (0 === v3 && n + this._labels[v3 + 1].textBlock.measureText().width - 2 * g > q || v3 === this._labels.length - 1 && n + this._labels[v3 - 1].textBlock.measureText().width - 2 * g > q || 0 < v3 && v3 < this._labels.length - 1 && n + this._labels[v3 + 1].textBlock.measureText().width - 2 * g > q && n + this._labels[v3 - 1].textBlock.measureText().width - 2 * g > q))
                              q = 0 === v3 ? n + this._labels[v3 + 1].textBlock.measureText().width - 2 * g : n + this._labels[v3 - 1].textBlock.measureText().width - 2 * g, this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p2;
                            else if (0 === q)
                              for (this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelWrap = true, c = 0; c < this._labels.length; c++)
                                a = this._labels[c].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), p2), B = a.measureText(), c < this._labels.length - 1 && (f = c + 1, d = this._labels[f].textBlock, d.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), p2), d = d.measureText(), B.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25));
                          }
                        }
                      }
                    else
                      (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), p2 = 0 != this.labelAngle ? (m - (h2 + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : g, this.sessionVariables.labelMaxHeight = k = this.labelWrap ? (m - p2 * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, u(this.options.labelWrap)) ? u(this.options.labelWrap) && (this.labelWrap && !u(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : p2, this.sessionVariables.labelMaxHeight = k) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = p2, this.sessionVariables.labelMaxHeight = c < 0.9 * l ? 0.9 * l : c, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : p2) : (u(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : p2, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = k);
                  }
                for (c = 0; c < this._labels.length; c++)
                  a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
              } else
                for (b = 0; b < this._labels.length; b++)
                  a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = u(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = u(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = u(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = u(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
            else if ("left" === this._position || "right" === this._position)
              if (g = u(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, k = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
                this.sessionVariables.labelFontSize = this.labelFontSize;
                this.sessionVariables.labelMaxWidth = g;
                this.sessionVariables.labelMaxHeight = k;
                this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                this.sessionVariables.labelWrap = this.labelWrap;
                for (b = 0; b < this._labels.length; b++)
                  if (!this._labels[b].breaksLabelType) {
                    a = this._labels[b].textBlock;
                    B = a.measureText();
                    for (f = b + 1; f < this._labels.length; f++)
                      if (!this._labels[f].breaksLabelType) {
                        d = this._labels[f].textBlock;
                        d = d.measureText();
                        break;
                      }
                    e.push(a.height);
                    this.sessionVariables.labelMaxHeight = Math.max.apply(
                      Math,
                      e
                    );
                    c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (k - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                    u(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? u(this.options.labelWrap) ? u(this.options.labelWrap) && (u(this.options.labelMaxWidth) ? u(d) || (l = B.height + d.height >> 0, l - 2 * k > n && (n = l - 2 * k, l >= 2 * k && l < 2.4 * k ? (u(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : l >= 2.4 * k && l < 2.8 * k ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = true) : l >= 2.8 * k && l < 3.2 * k ? (this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelWrap = true, u(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l >= 3.2 * k && l < 3.6 * k ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = true, this.sessionVariables.labelFontSize = this.labelFontSize) : l > 3.6 * k && l < 10 * k ? (u(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l > 10 * k && l < 50 * k && (u(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = k) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? g : Math.min((c - k * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), k), u(this.options.labelWrap)) ? u(this.options.labelWrap) && (this.labelWrap && !u(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : c, u(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : c, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = g) : (this.sessionVariables.labelMaxHeight = k, u(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);
                  }
                for (c = 0; c < this._labels.length; c++)
                  a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
              } else
                for (b = 0; b < this._labels.length; b++)
                  a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = u(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = u(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = u(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = u(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
          }
          for (b = 0; b < this.stripLines.length; b++) {
            var g = this.stripLines[b], z2;
            if ("outside" === g.labelPlacement) {
              k = this.sessionVariables.labelMaxWidth;
              if ("bottom" === this._position || "top" === this._position)
                z2 = u(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
              if ("left" === this._position || "right" === this._position)
                z2 = u(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;
              u(g.labelBackgroundColor) && (g.labelBackgroundColor = "#EEEEEE");
            } else
              k = "bottom" === this._position || "top" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, z2 = u(g.options.labelWrap) || g.labelWrap ? "bottom" === this._position || "top" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, u(g.labelBackgroundColor) && (u(g.startValue) && 0 !== g.startValue ? g.labelBackgroundColor = r ? "transparent" : null : g.labelBackgroundColor = "#EEEEEE");
            a = new ka(this.ctx, { x: 0, y: 0, backgroundColor: g.labelBackgroundColor, borderColor: g.labelBorderColor, borderThickness: g.labelBorderThickness, cornerRadius: g.labelCornerRadius, maxWidth: g.options.labelMaxWidth ? g.options.labelMaxWidth : k, maxHeight: z2, angle: this.labelAngle, text: g.labelFormatter ? g.labelFormatter({ chart: this.chart, axis: this, stripLine: g }) : g.label, horizontalAlign: "left", fontSize: "outside" === g.labelPlacement ? g.options.labelFontSize ? g.labelFontSize : this.labelFontSize : g.labelFontSize, fontFamily: "outside" === g.labelPlacement ? g.options.labelFontFamily ? g.labelFontFamily : this.labelFontFamily : g.labelFontFamily, fontWeight: "outside" === g.labelPlacement ? g.options.labelFontWeight ? g.labelFontWeight : this.labelFontWeight : g.labelFontWeight, fontColor: g.labelFontColor || g.color, fontStyle: "outside" === g.labelPlacement ? g.options.labelFontStyle ? g.labelFontStyle : this.fontWeight : g.labelFontStyle, textBaseline: "middle" });
            this._stripLineLabels.push({ position: g.value, textBlock: a, effectiveHeight: null, stripLine: g });
          }
        };
        z.prototype.createLabelsAndCalculateWidth = function() {
          var a = 0, d = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var b = this.chart.isNavigator ? 0 : 5;
          if ("left" === this._position || "right" === this._position) {
            this.createLabels();
            for (d = 0; d < this._labels.length; d++) {
              var c = this._labels[d].textBlock, e = c.measureText(), g = 0, g = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
              a < g && (a = g);
              this._labels[d].effectiveWidth = g;
            }
            for (d = 0; d < this._stripLineLabels.length; d++)
              "outside" === this._stripLineLabels[d].stripLine.labelPlacement && (this._stripLineLabels[d].stripLine.value >= this.viewportMinimum && this._stripLineLabels[d].stripLine.value <= this.viewportMaximum) && (c = this._stripLineLabels[d].textBlock, e = c.measureText(), g = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < g && (a = g), this._stripLineLabels[d].effectiveWidth = g);
          }
          d = this.title ? this._titleTextBlock.measureText().height + 2 : 0;
          return c = "inside" === this.labelPlacement ? c = d + b : d + a + this.tickLength + b;
        };
        z.prototype.createLabelsAndCalculateHeight = function() {
          var a = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var d, b = 0, c = this.chart.isNavigator ? 0 : 5;
          this.createLabels();
          if ("bottom" === this._position || "top" === this._position) {
            for (b = 0; b < this._labels.length; b++) {
              d = this._labels[b].textBlock;
              var e = d.measureText(), g = 0, g = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
              a < g && (a = g);
              this._labels[b].effectiveHeight = g;
            }
            for (b = 0; b < this._stripLineLabels.length; b++)
              "outside" === this._stripLineLabels[b].stripLine.labelPlacement && (this._stripLineLabels[b].stripLine.value >= this.viewportMinimum && this._stripLineLabels[b].stripLine.value <= this.viewportMaximum) && (d = this._stripLineLabels[b].textBlock, e = d.measureText(), g = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < g && (a = g), this._stripLineLabels[b].effectiveHeight = g);
          }
          d = this.title ? this._titleTextBlock.measureText().height + 2 : 0;
          return b = "inside" === this.labelPlacement ? b = d + c : d + a + this.tickLength + c;
        };
        z.setLayout = function(a, d, b, c, e, g) {
          var k, l, h2, m, p2 = a[0] ? a[0].chart : d[0].chart, q = p2.isNavigator ? 0 : 10, n = p2._axes;
          if (a && 0 < a.length)
            for (var f = 0; f < a.length; f++)
              a[f] && a[f].calculateAxisParameters();
          if (d && 0 < d.length)
            for (f = 0; f < d.length; f++)
              d[f].calculateAxisParameters();
          if (b && 0 < b.length)
            for (f = 0; f < b.length; f++)
              b[f].calculateAxisParameters();
          if (c && 0 < c.length)
            for (f = 0; f < c.length; f++)
              c[f].calculateAxisParameters();
          for (f = 0; f < n.length; f++)
            if (n[f] && n[f].scaleBreaks && n[f].scaleBreaks._appliedBreaks.length)
              for (var r2 = n[f].scaleBreaks._appliedBreaks, v3 = 0; v3 < r2.length && !(r2[v3].startValue > n[f].viewportMaximum); v3++)
                r2[v3].endValue < n[f].viewportMinimum || (u(n[f].scaleBreaks.firstBreakIndex) && (n[f].scaleBreaks.firstBreakIndex = v3), r2[v3].startValue >= n[f].viewPortMinimum && (n[f].scaleBreaks.lastBreakIndex = v3));
          for (var z2 = v3 = 0, t = 0, C = 0, x = 0, D = 0, y = 0, A, E3, F2 = l = 0, H2, I3, L2, r2 = H2 = I3 = L2 = false, f = 0; f < n.length; f++)
            n[f] && n[f].title && (n[f]._titleTextBlock = new ka(n[f].ctx, {
              text: n[f].title,
              horizontalAlign: "center",
              fontSize: n[f].titleFontSize,
              fontFamily: n[f].titleFontFamily,
              fontWeight: n[f].titleFontWeight,
              fontColor: n[f].titleFontColor,
              fontStyle: n[f].titleFontStyle,
              borderColor: n[f].titleBorderColor,
              borderThickness: n[f].titleBorderThickness,
              backgroundColor: n[f].titleBackgroundColor,
              cornerRadius: n[f].titleCornerRadius,
              textBaseline: "top"
            }));
          for (f = 0; f < n.length; f++)
            if (n[f].title)
              switch (n[f]._position) {
                case "left":
                  n[f]._titleTextBlock.maxWidth = n[f].titleMaxWidth || g.height;
                  n[f]._titleTextBlock.maxHeight = n[f].titleWrap ? 0.8 * g.width : 1.5 * n[f].titleFontSize;
                  n[f]._titleTextBlock.angle = -90;
                  break;
                case "right":
                  n[f]._titleTextBlock.maxWidth = n[f].titleMaxWidth || g.height;
                  n[f]._titleTextBlock.maxHeight = n[f].titleWrap ? 0.8 * g.width : 1.5 * n[f].titleFontSize;
                  n[f]._titleTextBlock.angle = 90;
                  break;
                default:
                  n[f]._titleTextBlock.maxWidth = n[f].titleMaxWidth || g.width, n[f]._titleTextBlock.maxHeight = n[f].titleWrap ? 0.8 * g.height : 1.5 * n[f].titleFontSize, n[f]._titleTextBlock.angle = 0;
              }
          if ("normal" === e) {
            for (var C = [], x = [], D = [], y = [], M2 = [], N2 = [], O2 = [], Q3 = []; 4 > v3; ) {
              var G = 0, R2 = 0, S2 = 0, U2 = 0, W2 = e = 0, K = 0, $3 = 0, V2 = 0, X3 = 0, P = 0, ba2 = 0;
              if (b && 0 < b.length)
                for (D = [], f = P = 0; f < b.length; f++)
                  D.push(Math.ceil(b[f] ? b[f].createLabelsAndCalculateWidth() : 0)), P += D[f], K += b[f] && !p2.isNavigator ? b[f].margin : 0;
              else
                D.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));
              O2.push(D);
              if (c && 0 < c.length)
                for (y = [], f = ba2 = 0; f < c.length; f++)
                  y.push(Math.ceil(c[f] ? c[f].createLabelsAndCalculateWidth() : 0)), ba2 += y[f], $3 += c[f] ? c[f].margin : 0;
              else
                y.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));
              Q3.push(y);
              k = Math.round(g.x1 + P + K);
              h2 = Math.round(g.x2 - ba2 - $3 > p2.width - q ? p2.width - q : g.x2 - ba2 - $3);
              if (a && 0 < a.length)
                for (C = [], f = V2 = 0; f < a.length; f++)
                  a[f] && (a[f].lineCoordinates = {}), a[f].lineCoordinates.width = Math.abs(h2 - k), a[f].title && (a[f]._titleTextBlock.maxWidth = 0 < a[f].titleMaxWidth && a[f].titleMaxWidth < a[f].lineCoordinates.width ? a[f].titleMaxWidth : a[f].lineCoordinates.width), C.push(Math.ceil(a[f] ? a[f].createLabelsAndCalculateHeight() : 0)), V2 += C[f], e += a[f] && !p2.isNavigator ? a[f].margin : 0;
              else
                C.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));
              M2.push(C);
              if (d && 0 < d.length)
                for (x = [], f = X3 = 0; f < d.length; f++)
                  d[f] && (d[f].lineCoordinates = {}), d[f].lineCoordinates.width = Math.abs(h2 - k), d[f].title && (d[f]._titleTextBlock.maxWidth = 0 < d[f].titleMaxWidth && d[f].titleMaxWidth < d[f].lineCoordinates.width ? d[f].titleMaxWidth : d[f].lineCoordinates.width), x.push(Math.ceil(d[f] ? d[f].createLabelsAndCalculateHeight() : 0)), X3 += x[f], W2 += d[f] && !p2.isNavigator ? d[f].margin : 0;
              else
                x.push(Math.ceil(d[0] ? d[0].createLabelsAndCalculateHeight() : 0));
              N2.push(x);
              if (a && 0 < a.length)
                for (f = 0; f < a.length; f++)
                  a[f] && (a[f].lineCoordinates.x1 = k, h2 = Math.round(g.x2 - ba2 - $3 > p2.width - q ? p2.width - q : g.x2 - ba2 - $3), a[f]._labels && 1 < a[f]._labels.length && (l = m = 0, m = a[f]._labels[1], l = "dateTime" === a[f].valueType ? a[f]._labels[a[f]._labels.length - 2] : a[f]._labels[a[f]._labels.length - 1], z2 = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), t = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), !a[f] || (!a[f].labelAutoFit || u(A) || u(E3) || p2.isNavigator) || (l = 0, 0 < a[f].labelAngle ? E3 + t > h2 && (l += 0 < a[f].labelAngle ? E3 + t - h2 - ba2 : 0) : 0 > a[f].labelAngle ? A - z2 < k && A - z2 < a[f].viewportMinimum && (F2 = k - (K + a[f].tickLength + D + A - z2 + a[f].labelFontSize / 2)) : 0 === a[f].labelAngle && (E3 + t > h2 && (l = E3 + t / 2 - h2 - ba2), A - z2 < k && A - z2 < a[f].viewportMinimum && (F2 = k - K - a[f].tickLength - D - A + z2 / 2)), a[f].viewportMaximum === a[f].maximum && a[f].viewportMinimum === a[f].minimum && 0 < a[f].labelAngle && 0 < l ? h2 -= l : a[f].viewportMaximum === a[f].maximum && a[f].viewportMinimum === a[f].minimum && 0 > a[f].labelAngle && 0 < F2 ? k += F2 : a[f].viewportMaximum === a[f].maximum && a[f].viewportMinimum === a[f].minimum && 0 === a[f].labelAngle && (0 < F2 && (k += F2), 0 < l && (h2 -= l))), p2.panEnabled ? V2 = p2.sessionVariables.axisX.height : p2.sessionVariables.axisX.height = V2, l = Math.round(g.y2 - V2 - e + G), m = Math.round(g.y2), a[f].lineCoordinates.x2 = h2, a[f].lineCoordinates.width = h2 - k, a[f].lineCoordinates.y1 = l, a[f].lineCoordinates.y2 = l, a[f].bounds = { x1: k, y1: l, x2: h2, y2: m - (V2 + e - C[f] - G), width: h2 - k, height: m - l }), G += C[f] + a[f].margin;
              if (d && 0 < d.length)
                for (f = 0; f < d.length; f++)
                  d[f].lineCoordinates.x1 = Math.round(g.x1 + P + K), d[f].lineCoordinates.x2 = Math.round(g.x2 - ba2 - $3 > p2.width - q ? p2.width - q : g.x2 - ba2 - $3), d[f].lineCoordinates.width = Math.abs(h2 - k), d[f]._labels && 1 < d[f]._labels.length && (m = d[f]._labels[1], l = "dateTime" === d[f].valueType ? d[f]._labels[d[f]._labels.length - 2] : d[f]._labels[d[f]._labels.length - 1], z2 = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), t = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), p2.panEnabled ? X3 = p2.sessionVariables.axisX2.height : p2.sessionVariables.axisX2.height = X3, l = Math.round(g.y1), m = Math.round(g.y2 + d[f].margin), d[f].lineCoordinates.y1 = l + X3 + W2 - R2, d[f].lineCoordinates.y2 = l, d[f].bounds = { x1: k, y1: l + (X3 + W2 - x[f] - R2), x2: h2, y2: m, width: h2 - k, height: m - l }, R2 += x[f] + d[f].margin;
              if (b && 0 < b.length)
                for (f = 0; f < b.length; f++)
                  K = p2.isNavigator ? 0 : 10, b[f] && (k = Math.round(a[0] ? a[0].lineCoordinates.x1 : d[0].lineCoordinates.x1), K = b[f]._labels && 0 < b[f]._labels.length ? b[f]._labels[b[f]._labels.length - 1].textBlock.height / 2 : q, l = Math.round(g.y1 + X3 + W2 < Math.max(K, q) ? Math.max(K, q) : g.y1 + X3 + W2), h2 = Math.round(a[0] ? a[0].lineCoordinates.x1 : d[0].lineCoordinates.x1), K = 0 < a.length ? 0 : b[f]._labels && 0 < b[f]._labels.length ? b[f]._labels[0].textBlock.height / 2 : q, m = Math.round(g.y2 - V2 - e - K), b[f].lineCoordinates = { x1: h2 - S2, y1: l, x2: h2 - S2, y2: m, height: Math.abs(m - l) }, b[f].bounds = { x1: k - (D[f] + S2), y1: l, x2: h2, y2: m, width: h2 - k, height: m - l }, b[f].title && (b[f]._titleTextBlock.maxWidth = 0 < b[f].titleMaxWidth && b[f].titleMaxWidth < b[f].lineCoordinates.height ? b[f].titleMaxWidth : b[f].lineCoordinates.height), S2 += D[f] + b[f].margin);
              if (c && 0 < c.length)
                for (f = 0; f < c.length; f++)
                  c[f] && (k = Math.round(a[0] ? a[0].lineCoordinates.x2 : d[0].lineCoordinates.x2), h2 = Math.round(k), K = c[f]._labels && 0 < c[f]._labels.length ? c[f]._labels[c[f]._labels.length - 1].textBlock.height / 2 : 0, l = Math.round(g.y1 + X3 + W2 < Math.max(K, q) ? Math.max(K, q) : g.y1 + X3 + W2), K = 0 < a.length ? 0 : c[f]._labels && 0 < c[f]._labels.length ? c[f]._labels[0].textBlock.height / 2 : 0, m = Math.round(g.y2 - (V2 + e + K)), c[f].lineCoordinates = { x1: k + U2, y1: l, x2: k + U2, y2: m, height: Math.abs(m - l) }, c[f].bounds = { x1: k, y1: l, x2: h2 + (y[f] + U2), y2: m, width: h2 - k, height: m - l }, c[f].title && (c[f]._titleTextBlock.maxWidth = 0 < c[f].titleMaxWidth && c[f].titleMaxWidth < c[f].lineCoordinates.height ? c[f].titleMaxWidth : c[f].lineCoordinates.height), U2 += y[f] + c[f].margin);
              if (a && 0 < a.length)
                for (f = 0; f < a.length; f++)
                  a[f] && (a[f].calculateValueToPixelConversionParameters(), a[f].calculateBreaksSizeInValues(), a[f]._labels && 1 < a[f]._labels.length && (A = (a[f].logarithmic ? Math.log(a[f]._labels[1].position / a[f].viewportMinimum) / a[f].conversionParameters.lnLogarithmBase : a[f]._labels[1].position - a[f].viewportMinimum) * Math.abs(a[f].conversionParameters.pixelPerUnit) + a[f].lineCoordinates.x1, k = a[f]._labels[a[f]._labels.length - ("dateTime" === a[f].valueType ? 2 : 1)].position, k = a[f].getApparentDifference(a[f].viewportMinimum, k), E3 = a[f].logarithmic ? (1 < k ? Math.log(k) / a[f].conversionParameters.lnLogarithmBase * Math.abs(a[f].conversionParameters.pixelPerUnit) : 0) + a[f].lineCoordinates.x1 : (0 < k ? k * Math.abs(a[f].conversionParameters.pixelPerUnit) : 0) + a[f].lineCoordinates.x1));
              if (d && 0 < d.length)
                for (f = 0; f < d.length; f++)
                  d[f].calculateValueToPixelConversionParameters(), d[f].calculateBreaksSizeInValues(), d[f]._labels && 1 < d[f]._labels.length && (A = (d[f].logarithmic ? Math.log(d[f]._labels[1].position / d[f].viewportMinimum) / d[f].conversionParameters.lnLogarithmBase : d[f]._labels[1].position - d[f].viewportMinimum) * Math.abs(d[f].conversionParameters.pixelPerUnit) + d[f].lineCoordinates.x1, k = d[f]._labels[d[f]._labels.length - ("dateTime" === d[f].valueType ? 2 : 1)].position, k = d[f].getApparentDifference(d[f].viewportMinimum, k), E3 = d[f].logarithmic ? (1 < k ? Math.log(k) / d[f].conversionParameters.lnLogarithmBase * Math.abs(d[f].conversionParameters.pixelPerUnit) : 0) + d[f].lineCoordinates.x1 : (0 < k ? k * Math.abs(d[f].conversionParameters.pixelPerUnit) : 0) + d[f].lineCoordinates.x1);
              for (f = 0; f < n.length; f++)
                "axisY" === n[f].type && (n[f].calculateValueToPixelConversionParameters(), n[f].calculateBreaksSizeInValues());
              if (0 < v3) {
                if (a && 0 < a.length)
                  for (f = 0; f < a.length; f++)
                    r2 = M2[v3 - 1][f] === M2[v3][f] ? true : false;
                else
                  r2 = true;
                if (d && 0 < d.length)
                  for (f = 0; f < d.length; f++)
                    H2 = N2[v3 - 1][f] === N2[v3][f] ? true : false;
                else
                  H2 = true;
                if (b && 0 < b.length)
                  for (f = 0; f < b.length; f++)
                    I3 = O2[v3 - 1][f] === O2[v3][f] ? true : false;
                else
                  I3 = true;
                if (c && 0 < c.length)
                  for (f = 0; f < c.length; f++)
                    L2 = Q3[v3 - 1][f] === Q3[v3][f] ? true : false;
                else
                  L2 = true;
              }
              if (r2 && H2 && I3 && L2)
                break;
              v3++;
            }
            if (a && 0 < a.length)
              for (f = 0; f < a.length; f++)
                a[f].calculateStripLinesThicknessInValues(), a[f].calculateBreaksInPixels();
            if (d && 0 < d.length)
              for (f = 0; f < d.length; f++)
                d[f].calculateStripLinesThicknessInValues(), d[f].calculateBreaksInPixels();
            if (b && 0 < b.length)
              for (f = 0; f < b.length; f++)
                b[f].calculateStripLinesThicknessInValues(), b[f].calculateBreaksInPixels();
            if (c && 0 < c.length)
              for (f = 0; f < c.length; f++)
                c[f].calculateStripLinesThicknessInValues(), c[f].calculateBreaksInPixels();
          } else {
            q = [];
            A = [];
            F2 = [];
            z2 = [];
            E3 = [];
            t = [];
            M2 = [];
            for (N2 = []; 4 > v3; ) {
              V2 = U2 = R2 = S2 = $3 = K = W2 = e = Q3 = O2 = G = X3 = 0;
              if (a && 0 < a.length)
                for (F2 = [], f = U2 = 0; f < a.length; f++)
                  F2.push(Math.ceil(a[f] ? a[f].createLabelsAndCalculateWidth() : 0)), U2 += F2[f], e += a[f] && !p2.isNavigator ? a[f].margin : 0;
              else
                F2.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));
              M2.push(F2);
              if (d && 0 < d.length)
                for (z2 = [], f = V2 = 0; f < d.length; f++)
                  z2.push(Math.ceil(d[f] ? d[f].createLabelsAndCalculateWidth() : 0)), V2 += z2[f], W2 += d[f] ? d[f].margin : 0;
              else
                z2.push(Math.ceil(d[0] ? d[0].createLabelsAndCalculateWidth() : 0));
              N2.push(z2);
              if (b && 0 < b.length)
                for (f = 0; f < b.length; f++)
                  b[f].lineCoordinates = {}, k = Math.round(g.x1 + U2 + e), h2 = Math.round(g.x2 - V2 - W2 > p2.width - 10 ? p2.width - 10 : g.x2 - V2 - W2), b[f].labelAutoFit && !u(C) && (0 < !a.length && (k = 0 > b[f].labelAngle ? Math.max(k, C) : 0 === b[f].labelAngle ? Math.max(k, C / 2) : k), 0 < !d.length && (h2 = 0 < b[f].labelAngle ? h2 - x / 2 : 0 === b[f].labelAngle ? h2 - x / 2 : h2)), b[f].lineCoordinates.x1 = k, b[f].lineCoordinates.x2 = h2, b[f].lineCoordinates.width = Math.abs(h2 - k), b[f].title && (b[f]._titleTextBlock.maxWidth = 0 < b[f].titleMaxWidth && b[f].titleMaxWidth < b[f].lineCoordinates.width ? b[f].titleMaxWidth : b[f].lineCoordinates.width);
              if (c && 0 < c.length)
                for (f = 0; f < c.length; f++)
                  c[f].lineCoordinates = {}, k = Math.round(g.x1 + U2 + e), h2 = Math.round(g.x2 - V2 - W2 > c[f].chart.width - 10 ? c[f].chart.width - 10 : g.x2 - V2 - W2), c[f] && c[f].labelAutoFit && !u(D) && (0 < !a.length && (k = 0 < c[f].labelAngle ? Math.max(k, D) : 0 === c[f].labelAngle ? Math.max(k, D / 2) : k), 0 < !d.length && (h2 -= y / 2)), c[f].lineCoordinates.x1 = k, c[f].lineCoordinates.x2 = h2, c[f].lineCoordinates.width = Math.abs(h2 - k), c[f].title && (c[f]._titleTextBlock.maxWidth = 0 < c[f].titleMaxWidth && c[f].titleMaxWidth < c[f].lineCoordinates.width ? c[f].titleMaxWidth : c[f].lineCoordinates.width);
              if (b && 0 < b.length)
                for (q = [], f = S2 = 0; f < b.length; f++)
                  q.push(Math.ceil(b[f] ? b[f].createLabelsAndCalculateHeight() : 0)), S2 += q[f] + b[f].margin, K += b[f].margin;
              else
                q.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));
              E3.push(q);
              if (c && 0 < c.length)
                for (A = [], f = R2 = 0; f < c.length; f++)
                  A.push(Math.ceil(c[f] ? c[f].createLabelsAndCalculateHeight() : 0)), R2 += A[f], $3 += c[f].margin;
              else
                A.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0));
              t.push(A);
              if (b && 0 < b.length)
                for (f = 0; f < b.length; f++)
                  0 < b[f]._labels.length && (m = b[f]._labels[0], l = b[f]._labels[b[f]._labels.length - 1], C = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), x = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));
              if (c && 0 < c.length)
                for (f = 0; f < c.length; f++)
                  c[f] && 0 < c[f]._labels.length && (m = c[f]._labels[0], l = c[f]._labels[c[f]._labels.length - 1], D = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), y = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));
              if (p2.panEnabled)
                for (f = 0; f < b.length; f++)
                  q[f] = p2.sessionVariables.axisY.height;
              else
                for (f = 0; f < b.length; f++)
                  p2.sessionVariables.axisY.height = q[f];
              if (b && 0 < b.length)
                for (f = b.length - 1; 0 <= f; f--)
                  l = Math.round(g.y2), m = Math.round(g.y2 > b[f].chart.height - 10 ? b[f].chart.height - 10 : g.y2), b[f].lineCoordinates.y1 = l - (q[f] + b[f].margin + X3), b[f].lineCoordinates.y2 = l - (q[f] + b[f].margin + X3), b[f].bounds = { x1: k, y1: l - (q[f] + X3 + b[f].margin), x2: h2, y2: m - (X3 + b[f].margin), width: h2 - k, height: q[f] }, b[f].title && (b[f]._titleTextBlock.maxWidth = 0 < b[f].titleMaxWidth && b[f].titleMaxWidth < b[f].lineCoordinates.width ? b[f].titleMaxWidth : b[f].lineCoordinates.width), X3 += q[f] + b[f].margin;
              if (c && 0 < c.length)
                for (f = c.length - 1; 0 <= f; f--)
                  c[f] && (l = Math.round(g.y1), m = Math.round(g.y1 + (A[f] + c[f].margin + G)), c[f].lineCoordinates.y1 = m, c[f].lineCoordinates.y2 = m, c[f].bounds = { x1: k, y1: l + (c[f].margin + G), x2: h2, y2: m, width: h2 - k, height: R2 }, c[f].title && (c[f]._titleTextBlock.maxWidth = 0 < c[f].titleMaxWidth && c[f].titleMaxWidth < c[f].lineCoordinates.width ? c[f].titleMaxWidth : c[f].lineCoordinates.width), G += A[f] + c[f].margin);
              if (a && 0 < a.length)
                for (f = 0; f < a.length; f++) {
                  K = a[f]._labels && 0 < a[f]._labels.length ? a[f]._labels[0].textBlock.fontSize / 2 : 0;
                  k = Math.round(g.x1 + e);
                  l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;
                  h2 = Math.round(g.x1 + U2 + e);
                  m = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - S2 > p2.height - Math.max(K, 10) ? p2.height - Math.max(K, 10) : g.y2 - S2) : g.y2 > p2.height - Math.max(K, 10) ? p2.height - Math.max(K, 10) : g.y2;
                  if (b && 0 < b.length)
                    for (K = 0; K < b.length; K++)
                      b[K] && b[K].labelAutoFit && (h2 = 0 > b[K].labelAngle ? Math.max(h2, C) : 0 === b[K].labelAngle ? Math.max(h2, C / 2) : h2, k = 0 > b[K].labelAngle || 0 === b[K].labelAngle ? h2 - U2 : k);
                  if (c && 0 < c.length)
                    for (K = 0; K < c.length; K++)
                      c[K] && c[K].labelAutoFit && (h2 = c[K].lineCoordinates.x1, k = h2 - U2);
                  a[f].lineCoordinates = { x1: h2 - O2, y1: l, x2: h2 - O2, y2: m, height: Math.abs(m - l) };
                  a[f].bounds = { x1: h2 - (F2[f] + O2), y1: l, x2: h2, y2: m, width: h2 - k, height: m - l };
                  a[f].title && (a[f]._titleTextBlock.maxWidth = 0 < a[f].titleMaxWidth && a[f].titleMaxWidth < a[f].lineCoordinates.height ? a[f].titleMaxWidth : a[f].lineCoordinates.height);
                  a[f].calculateValueToPixelConversionParameters();
                  a[f].calculateBreaksSizeInValues();
                  O2 += F2[f] + a[f].margin;
                }
              if (d && 0 < d.length)
                for (f = 0; f < d.length; f++) {
                  K = d[f]._labels && 0 < d[f]._labels.length ? d[f]._labels[0].textBlock.fontSize / 2 : 0;
                  k = Math.round(g.x1 - e);
                  l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;
                  h2 = Math.round(g.x2 - V2 - W2);
                  m = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - S2 > p2.height - Math.max(K, 10) ? p2.height - Math.max(K, 10) : g.y2 - S2) : g.y2 > p2.height - Math.max(K, 10) ? p2.height - Math.max(K, 10) : g.y2;
                  if (b && 0 < b.length)
                    for (K = 0; K < b.length; K++)
                      b[K] && b[K].labelAutoFit && (h2 = 0 > b[K].labelAngle ? Math.max(h2, C) : 0 === b[K].labelAngle ? Math.max(h2, C / 2) : h2, k = 0 > b[K].labelAngle || 0 === b[K].labelAngle ? h2 - V2 : k);
                  if (c && 0 < c.length)
                    for (K = 0; K < c.length; K++)
                      c[K] && c[K].labelAutoFit && (h2 = c[K].lineCoordinates.x2, k = h2 - V2);
                  d[f].lineCoordinates = { x1: h2 + Q3, y1: l, x2: h2 + Q3, y2: m, height: Math.abs(m - l) };
                  d[f].bounds = { x1: k, y1: l, x2: h2 + z2[f] + Q3, y2: m, width: h2 - k, height: m - l };
                  d[f].title && (d[f]._titleTextBlock.maxWidth = 0 < d[f].titleMaxWidth && d[f].titleMaxWidth < d[f].lineCoordinates.height ? d[f].titleMaxWidth : d[f].lineCoordinates.height);
                  d[f].calculateValueToPixelConversionParameters();
                  d[f].calculateBreaksSizeInValues();
                  Q3 += z2[f] + d[f].margin;
                }
              for (f = 0; f < n.length; f++)
                "axisY" === n[f].type && (n[f].calculateValueToPixelConversionParameters(), n[f].calculateBreaksSizeInValues());
              if (0 < v3) {
                if (a && 0 < a.length)
                  for (f = 0; f < a.length; f++)
                    r2 = M2[v3 - 1][f] === M2[v3][f] ? true : false;
                else
                  r2 = true;
                if (d && 0 < d.length)
                  for (f = 0; f < d.length; f++)
                    H2 = N2[v3 - 1][f] === N2[v3][f] ? true : false;
                else
                  H2 = true;
                if (b && 0 < b.length)
                  for (f = 0; f < b.length; f++)
                    I3 = E3[v3 - 1][f] === E3[v3][f] ? true : false;
                else
                  I3 = true;
                if (c && 0 < c.length)
                  for (f = 0; f < c.length; f++)
                    L2 = t[v3 - 1][f] === t[v3][f] ? true : false;
                else
                  L2 = true;
              }
              if (r2 && H2 && I3 && L2)
                break;
              v3++;
            }
            if (b && 0 < b.length)
              for (f = 0; f < b.length; f++)
                b[f].calculateStripLinesThicknessInValues(), b[f].calculateBreaksInPixels();
            if (c && 0 < c.length)
              for (f = 0; f < c.length; f++)
                c[f].calculateStripLinesThicknessInValues(), c[f].calculateBreaksInPixels();
            if (a && 0 < a.length)
              for (f = 0; f < a.length; f++)
                a[f].calculateStripLinesThicknessInValues(), a[f].calculateBreaksInPixels();
            if (d && 0 < d.length)
              for (f = 0; f < d.length; f++)
                d[f].calculateStripLinesThicknessInValues(), d[f].calculateBreaksInPixels();
          }
        };
        z.render = function(a, d, b, c, e) {
          var g = a[0] ? a[0].chart : d[0].chart;
          e = g.ctx;
          var k = g._axes;
          g.alignVerticalAxes && g.alignVerticalAxes();
          e.save();
          e.beginPath();
          a[0] && e.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[0].bounds.height);
          d[0] && e.rect(5, d[d.length - 1].bounds.y1, d[0].chart.width - 10, d[0].bounds.height);
          e.clip();
          if (a && 0 < a.length)
            for (var l = 0; l < a.length; l++)
              a[l].renderLabelsTicksAndTitle();
          if (d && 0 < d.length)
            for (l = 0; l < d.length; l++)
              d[l].renderLabelsTicksAndTitle();
          e.restore();
          if (b && 0 < b.length)
            for (l = 0; l < b.length; l++)
              b[l].renderLabelsTicksAndTitle();
          if (c && 0 < c.length)
            for (l = 0; l < c.length; l++)
              c[l].renderLabelsTicksAndTitle();
          g.preparePlotArea();
          g = g.plotArea;
          e.save();
          e.beginPath();
          e.rect(g.x1, g.y1, Math.abs(g.x2 - g.x1), Math.abs(g.y2 - g.y1));
          e.clip();
          if (a && 0 < a.length)
            for (l = 0; l < k.length; l++)
              k[l].renderStripLinesOfThicknessType("value");
          if (d && 0 < d.length)
            for (l = 0; l < d.length; l++)
              d[l].renderStripLinesOfThicknessType("value");
          if (b && 0 < b.length)
            for (l = 0; l < b.length; l++)
              b[l].renderStripLinesOfThicknessType("value");
          if (c && 0 < c.length)
            for (l = 0; l < c.length; l++)
              c[l].renderStripLinesOfThicknessType("value");
          if (a && 0 < a.length)
            for (l = 0; l < a.length; l++)
              a[l].renderInterlacedColors();
          if (d && 0 < d.length)
            for (l = 0; l < d.length; l++)
              d[l].renderInterlacedColors();
          if (b && 0 < b.length)
            for (l = 0; l < b.length; l++)
              b[l].renderInterlacedColors();
          if (c && 0 < c.length)
            for (l = 0; l < c.length; l++)
              c[l].renderInterlacedColors();
          e.restore();
          if (a && 0 < a.length)
            for (l = 0; l < a.length; l++)
              a[l].renderGrid(), r && (a[l].createMask(), a[l].renderBreaksBackground());
          if (d && 0 < d.length)
            for (l = 0; l < d.length; l++)
              d[l].renderGrid(), r && (d[l].createMask(), d[l].renderBreaksBackground());
          if (b && 0 < b.length)
            for (l = 0; l < b.length; l++)
              b[l].renderGrid(), r && (b[l].createMask(), b[l].renderBreaksBackground());
          if (c && 0 < c.length)
            for (l = 0; l < c.length; l++)
              c[l].renderGrid(), r && (c[l].createMask(), c[l].renderBreaksBackground());
          if (a && 0 < a.length)
            for (l = 0; l < a.length; l++)
              a[l].renderAxisLine();
          if (d && 0 < d.length)
            for (l = 0; l < d.length; l++)
              d[l].renderAxisLine();
          if (b && 0 < b.length)
            for (l = 0; l < b.length; l++)
              b[l].renderAxisLine();
          if (c && 0 < c.length)
            for (l = 0; l < c.length; l++)
              c[l].renderAxisLine();
          if (a && 0 < a.length)
            for (l = 0; l < a.length; l++)
              a[l].renderStripLinesOfThicknessType("pixel");
          if (d && 0 < d.length)
            for (l = 0; l < d.length; l++)
              d[l].renderStripLinesOfThicknessType("pixel");
          if (b && 0 < b.length)
            for (l = 0; l < b.length; l++)
              b[l].renderStripLinesOfThicknessType("pixel");
          if (c && 0 < c.length)
            for (l = 0; l < c.length; l++)
              c[l].renderStripLinesOfThicknessType("pixel");
        };
        z.prototype.calculateStripLinesThicknessInValues = function() {
          for (var a = 0; a < this.stripLines.length; a++)
            if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {
              var d = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue), b = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue), d = this.getApparentDifference(d, b);
              this.stripLines[a].value = this.logarithmic ? this.stripLines[a].value * Math.sqrt(Math.log(this.stripLines[a].endValue / this.stripLines[a].startValue) / Math.log(d)) : this.stripLines[a].value + (Math.abs(this.stripLines[a].endValue - this.stripLines[a].startValue) - d) / 2;
              this.stripLines[a].thickness = d;
              this.stripLines[a]._thicknessType = "value";
            }
        };
        z.prototype.calculateBreaksSizeInValues = function() {
          for (var a = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, d = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), c = this.scaleBreaks && !u(this.scaleBreaks.options.spacing), e, g = 0; g < d.length; g++)
            e = c || !u(d[g].options.spacing), d[g].spacing = I2(d[g].spacing, a, 8, e ? 0.1 * a : 8, e ? 0 : 3) << 0, d[g].size = 0 > d[g].spacing ? 0 : Math.abs(d[g].spacing / b), this.logarithmic && (d[g].size = Math.pow(this.logarithmBase, d[g].size));
        };
        z.prototype.calculateBreaksInPixels = function() {
          if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
            var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);
            for (var d = 0; d < a.length && !(a[d].startValue > this.conversionParameters.maximum); d++)
              a[d].endValue < this.conversionParameters.minimum || (u(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = d), a[d].startValue >= this.conversionParameters.minimum && (a[d].startPixel = this.convertValueToPixel(a[d].startValue), this.scaleBreaks.lastBreakIndex = d), a[d].endValue <= this.conversionParameters.maximum && (a[d].endPixel = this.convertValueToPixel(a[d].endValue)));
          }
        };
        z.prototype.renderLabelsTicksAndTitle = function() {
          var a = this, d = false, b = 0, c = 0, e = 1, g = 0;
          0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2);
          if ("undefined" === typeof this.options.interval) {
            if ("bottom" === this._position || "top" === this._position)
              if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                for (var b = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, k, l = this.viewportMaximum, h2 = this.lineCoordinates.width / Math.log(this.range), m = this._labels.length - 1; 0 <= m; m--) {
                  q = this._labels[m];
                  if (q.position < this.viewportMinimum)
                    break;
                  q.position > this.viewportMaximum || !(m === this._labels.length - 1 || k < Math.log(l / q.position) * h2 / e) || (b.push(q), l = q.position, k = q.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                }
                this._labels = b;
              } else {
                for (m = 0; m < this._labels.length; m++)
                  q = this._labels[m], q.position < this.viewportMinimum || (k = q.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += k);
                b > this.lineCoordinates.width * e && this.labelAutoFit && (d = true);
              }
            if ("left" === this._position || "right" === this._position)
              if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                for (var b = [], p2, l = this.viewportMaximum, h2 = this.lineCoordinates.height / Math.log(this.range), m = this._labels.length - 1; 0 <= m; m--) {
                  q = this._labels[m];
                  if (q.position < this.viewportMinimum)
                    break;
                  q.position > this.viewportMaximum || !(m === this._labels.length - 1 || p2 < Math.log(l / q.position) * h2) || (b.push(q), l = q.position, p2 = q.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                }
                this._labels = b;
              } else {
                for (m = 0; m < this._labels.length; m++)
                  q = this._labels[m], q.position < this.viewportMinimum || (p2 = q.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += p2);
                c > this.lineCoordinates.height * e && this.labelAutoFit && (d = true);
              }
          }
          this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function(a2, b2) {
            return a2.position - b2.position;
          });
          var m = 0, q, n;
          if ("bottom" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y + this.tickLength << 0), this.ctx.stroke()), 0 === q.textBlock.angle ? (n.x -= q.textBlock.width / 2, n.y = "inside" === this.labelPlacement ? n.y - (this.tickLength + q.textBlock.fontSize / 2) : n.y + this.tickLength + q.textBlock.fontSize / 2) : (n.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? n.x : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x - (0 > this.labelAngle ? q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? n.y - this.tickLength - 5 : n.y - this.tickLength - Math.abs(q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : n.y + this.tickLength + Math.abs(0 > this.labelAngle ? q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), q.textBlock.x = n.x, q.textBlock.y = n.y);
            "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === a.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(b2, n.y << 0);
                  a.ctx.lineTo(b2, n.y - a.tickLength << 0);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("top" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y - this.tickLength << 0), this.ctx.stroke()), 0 === q.textBlock.angle ? (n.x -= q.textBlock.width / 2, n.y = "inside" === this.labelPlacement ? n.y + this.labelFontSize / 2 + this.tickLength + 5 : n.y - (this.tickLength + q.textBlock.height - q.textBlock.fontSize / 2)) : (n.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? n.x : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x + (q.textBlock.height - this.tickLength - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ? n.y + this.tickLength + 5 : n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength + 5 : n.y - (this.tickLength + ((q.textBlock.height - q.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), q.textBlock.x = n.x, q.textBlock.y = n.y);
            "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(b2, n.y << 0);
                  a.ctx.lineTo(b2, n.y + a.tickLength << 0);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("left" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x - this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ? (q.textBlock.y = n.y, q.textBlock.x = "inside" === this.labelPlacement ? n.x + this.tickLength + 5 : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (q.textBlock.y = "inside" === this.labelPlacement ? n.y : n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), q.textBlock.x = "inside" === this.labelPlacement ? n.x + this.tickLength + 5 : 0 < this.labelAngle ? n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength));
            "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(n.x << 0, b2);
                  a.ctx.lineTo(n.x + a.tickLength << 0, b2);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("right" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x + this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ? (q.textBlock.y = n.y, q.textBlock.x = "inside" === this.labelPlacement ? n.x - q.textBlock.width - this.tickLength - 5 : n.x + this.tickLength + 5) : (q.textBlock.y = "inside" === this.labelPlacement ? n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? n.y : n.y - (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), q.textBlock.x = "inside" === this.labelPlacement ? n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : 0 < this.labelAngle ? n.x + (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : n.x + this.tickLength + 5));
            "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(n.x << 0, b2);
                  a.ctx.lineTo(n.x - a.tickLength << 0, b2);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          }
          g = 0;
          if ("inside" === this.labelPlacement)
            this.chart.addEventListener(
              "dataAnimationIterationEnd",
              function() {
                for (m = 0; m < a._labels.length; m++)
                  q = a._labels[m], q.position < a.viewportMinimum || (q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) || (a.ctx.save(), a.ctx.beginPath(), q.textBlock.render(true), a.ctx.restore());
              },
              this
            );
          else
            for (m = 0; m < this._labels.length; m++)
              q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || q.textBlock.render(true);
        };
        z.prototype.renderInterlacedColors = function() {
          var a = this.chart.plotArea.ctx, d, b, c = this.chart.plotArea, e = 0;
          d = true;
          if (("bottom" === this._position || "top" === this._position) && this.interlacedColor)
            for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)
              d ? (d = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(b.x, d.x), c.y1, Math.abs(b.x - d.x), Math.abs(c.y1 - c.y2)), d = false) : d = true;
          else if (("left" === this._position || "right" === this._position) && this.interlacedColor)
            for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)
              d ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), d = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(c.x1, Math.min(b.y, d.y), Math.abs(c.x1 - c.x2), Math.abs(d.y - b.y)), d = false) : d = true;
          a.beginPath();
        };
        z.prototype.renderStripLinesOfThicknessType = function(a) {
          if (this.stripLines && 0 < this.stripLines.length && a) {
            for (var d = this, b, c = 0, e = 0, g = false, k = false, l = [], h2 = [], k = false, c = 0; c < this.stripLines.length; c++) {
              var m = this.stripLines[c];
              m._thicknessType === a && ("pixel" === a && (m.value < this.viewportMinimum || m.value > this.viewportMaximum || u(m.value) || isNaN(this.range)) || l.push(m));
            }
            for (c = 0; c < this._stripLineLabels.length; c++)
              if (m = this.stripLines[c], b = this._stripLineLabels[c], !(b.position < this.viewportMinimum || b.position > this.viewportMaximum || isNaN(this.range))) {
                a = this.getPixelCoordinatesOnAxis(b.position);
                if ("outside" === b.stripLine.labelPlacement)
                  if (m && (this.ctx.strokeStyle = m.color, "pixel" === m._thicknessType && (this.ctx.lineWidth = m.thickness)), "bottom" === this._position) {
                    var p2 = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0;
                    this.ctx.beginPath();
                    this.ctx.moveTo(p2, a.y << 0);
                    this.ctx.lineTo(p2, a.y + this.tickLength << 0);
                    this.ctx.stroke();
                    0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y += this.tickLength + b.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));
                  } else
                    "top" === this._position ? (p2 = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(p2, a.y << 0), this.ctx.lineTo(p2, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y -= this.tickLength + b.textBlock.height) : (a.x += (b.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength + (b.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (p2 = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, p2), this.ctx.lineTo(a.x - this.tickLength << 0, p2), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (p2 = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, p2), this.ctx.lineTo(a.x + this.tickLength << 0, p2), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5));
                else
                  b.textBlock.angle = -90, "bottom" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? u(m.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, u(m.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y1 + b.textBlock.width + 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - b.textBlock.width - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? u(m.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, u(m.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + b.textBlock.width + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y2 - b.textBlock.width - 3) : "left" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - b.textBlock.height > this.chart.plotArea.y1 ? u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x2 - b.textBlock.width - 3) : "right" === this._position && (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - +b.textBlock.height > this.chart.plotArea.y1 ? u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 - 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x2 - b.textBlock.width - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x1 + 3);
                b.textBlock.x = a.x;
                b.textBlock.y = a.y;
                h2.push(b);
              }
            if (!k) {
              k = false;
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
              this.ctx.clip();
              for (c = 0; c < l.length; c++)
                m = l[c], m.showOnTop ? g || (g = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                  this.ctx.save();
                  this.ctx.beginPath();
                  this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                  this.ctx.clip();
                  for (e = 0; e < l.length; e++)
                    m = l[e], m.showOnTop && m.render();
                  this.ctx.restore();
                }, m)) : m.render();
              for (c = 0; c < h2.length; c++)
                b = h2[c], b.stripLine.showOnTop ? k || (k = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                  for (e = 0; e < h2.length; e++)
                    b = h2[e], "inside" === b.stripLine.labelPlacement && b.stripLine.showOnTop && (d.ctx.save(), d.ctx.beginPath(), d.ctx.rect(d.chart.plotArea.x1, d.chart.plotArea.y1, d.chart.plotArea.width, d.chart.plotArea.height), d.ctx.clip(), b.textBlock.render(true), d.ctx.restore());
                }, b.textBlock)) : "inside" === b.stripLine.labelPlacement && b.textBlock.render(true);
              this.ctx.restore();
              k = true;
            }
            if (k)
              for (k = false, c = 0; c < h2.length; c++)
                b = h2[c], b.stripLine.showOnTop ? k || (k = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                  for (e = 0; e < h2.length; e++)
                    b = h2[e], "outside" === b.stripLine.labelPlacement && b.stripLine.showOnTop && b.textBlock.render(true);
                }, b.textBlock)) : "outside" === b.stripLine.labelPlacement && b.textBlock.render(true);
          }
        };
        z.prototype.renderBreaksBackground = function() {
          this.chart._breaksCanvas && (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());
        };
        z.prototype.createMask = function() {
          if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
            var a = this.scaleBreaks._appliedBreaks;
            r ? (this.maskCanvas = ta(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);
            this.maskCtx.save();
            this.maskCtx.beginPath();
            this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.maskCtx.clip();
            for (var d = 0; d < a.length; d++)
              a[d].endValue < this.viewportMinimum || (a[d].startValue > this.viewportMaximum || isNaN(this.range)) || a[d].render(this.maskCtx);
            this.maskCtx.restore();
          }
        };
        z.prototype.renderCrosshair = function(a, d) {
          this.crosshair.render(a, d);
        };
        z.prototype.renderGrid = function() {
          if (this.gridThickness && 0 < this.gridThickness) {
            var a = this.chart.ctx;
            a.save();
            var d, b = this.chart.plotArea;
            a.lineWidth = this.gridThickness;
            a.strokeStyle = this.gridColor;
            a.setLineDash && a.setLineDash(R(this.gridDashType, this.gridThickness));
            if ("bottom" === this._position || "top" === this._position)
              for (c = 0; c < this._labels.length; c++)
                this._labels[c].position < this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(), d = this.getPixelCoordinatesOnAxis(this._labels[c].position), d = 1 === a.lineWidth % 2 ? (d.x << 0) + 0.5 : d.x << 0, a.moveTo(d, b.y1 << 0), a.lineTo(d, b.y2 << 0), a.stroke());
            else if ("left" === this._position || "right" === this._position)
              for (var c = 0; c < this._labels.length; c++)
                this._labels[c].position < this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(), d = this.getPixelCoordinatesOnAxis(this._labels[c].position), d = 1 === a.lineWidth % 2 ? (d.y << 0) + 0.5 : d.y << 0, a.moveTo(b.x1 << 0, d), a.lineTo(b.x2 << 0, d), a.stroke());
            a.restore();
          }
        };
        z.prototype.renderAxisLine = function() {
          var a = this.chart.ctx, d = r ? this.chart._preRenderCtx : a, b = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), c = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)), e, g;
          d.save();
          if ("bottom" === this._position || "top" === this._position) {
            if (this.lineThickness) {
              this.reversed ? (e = this.lineCoordinates.x2, g = this.lineCoordinates.x1) : (e = this.lineCoordinates.x1, g = this.lineCoordinates.x2);
              d.lineWidth = this.lineThickness;
              d.strokeStyle = this.lineColor ? this.lineColor : "black";
              d.setLineDash && d.setLineDash(R(this.lineDashType, this.lineThickness));
              var k = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;
              d.beginPath();
              if (this.scaleBreaks && !u(this.scaleBreaks.firstBreakIndex))
                if (u(this.scaleBreaks.lastBreakIndex))
                  e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c;
                else
                  for (var l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++)
                    d.moveTo(e, k), d.lineTo(this.scaleBreaks._appliedBreaks[l].startPixel + b, k), e = this.scaleBreaks._appliedBreaks[l].endPixel + c;
              e && (d.moveTo(e, k), d.lineTo(g, k));
              d.stroke();
            }
          } else if (("left" === this._position || "right" === this._position) && this.lineThickness) {
            this.reversed ? (e = this.lineCoordinates.y1, g = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, g = this.lineCoordinates.y1);
            d.lineWidth = this.lineThickness;
            d.strokeStyle = this.lineColor;
            d.setLineDash && d.setLineDash(R(this.lineDashType, this.lineThickness));
            k = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;
            d.beginPath();
            if (this.scaleBreaks && !u(this.scaleBreaks.firstBreakIndex))
              if (u(this.scaleBreaks.lastBreakIndex))
                e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;
              else
                for (l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++)
                  d.moveTo(k, e), d.lineTo(k, this.scaleBreaks._appliedBreaks[l].startPixel + c), e = this.scaleBreaks._appliedBreaks[l].endPixel + b;
            e && (d.moveTo(k, e), d.lineTo(k, g));
            d.stroke();
          }
          r && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), d.clearRect(0, 0, this.chart.width, this.chart.height));
          d.restore();
        };
        z.prototype.getPixelCoordinatesOnAxis = function(a) {
          var d = {};
          if ("bottom" === this._position || "top" === this._position)
            d.x = this.convertValueToPixel(a), d.y = this.lineCoordinates.y1;
          if ("left" === this._position || "right" === this._position)
            d.y = this.convertValueToPixel(a), d.x = this.lineCoordinates.x2;
          return d;
        };
        z.prototype.convertPixelToValue = function(a) {
          if ("undefined" === typeof a)
            return null;
          var d = 0, b = 0, c, d = true, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = "number" === typeof a ? a : "left" === this._position || "right" === this._position ? a.y : a.x;
          if (this.logarithmic) {
            a = c = Math.pow(this.logarithmBase, (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);
            if (b <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
              for (b = 0; b < e.length; b++) {
                if (!(e[b].endValue < this.conversionParameters.minimum))
                  if (d)
                    if (e[b].startValue < this.conversionParameters.minimum) {
                      if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) < e[b].endValue) {
                        a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));
                        break;
                      } else
                        a *= e[b].endValue / this.conversionParameters.minimum / Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)), c /= Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue));
                      d = false;
                    } else if (c > e[b].startValue / this.conversionParameters.minimum) {
                      c /= e[b].startValue / this.conversionParameters.minimum;
                      if (c < e[b].size) {
                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;
                        break;
                      } else
                        a *= e[b].endValue / e[b].startValue / e[b].size;
                      c /= e[b].size;
                      d = false;
                    } else
                      break;
                  else if (c > e[b].startValue / e[b - 1].endValue) {
                    c /= e[b].startValue / e[b - 1].endValue;
                    if (c < e[b].size) {
                      a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;
                      break;
                    } else
                      a *= e[b].endValue / e[b].startValue / e[b].size;
                    c /= e[b].size;
                  } else
                    break;
              }
            else
              for (b = e.length - 1; 0 <= b; b--)
                if (!(e[b].startValue > this.conversionParameters.minimum))
                  if (d)
                    if (e[b].endValue > this.conversionParameters.minimum) {
                      if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) > e[b].startValue) {
                        a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));
                        break;
                      } else
                        a *= e[b].startValue / this.conversionParameters.minimum * Math.pow(e[b].size, Math.log(e[b].startValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)) * c, c *= Math.pow(e[b].size, Math.log(this.conversionParameters.minimum / e[b].startValue) / Math.log(e[b].endValue / e[b].startValue));
                      d = false;
                    } else if (c < e[b].endValue / this.conversionParameters.minimum) {
                      c /= e[b].endValue / this.conversionParameters.minimum;
                      if (c > 1 / e[b].size) {
                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;
                        break;
                      } else
                        a /= e[b].endValue / e[b].startValue / e[b].size;
                      c *= e[b].size;
                      d = false;
                    } else
                      break;
                  else if (c < e[b].endValue / e[b + 1].startValue) {
                    c /= e[b].endValue / e[b + 1].startValue;
                    if (c > 1 / e[b].size) {
                      a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;
                      break;
                    } else
                      a /= e[b].endValue / e[b].startValue / e[b].size;
                    c *= e[b].size;
                  } else
                    break;
            d = a * this.viewportMinimum;
          } else {
            a = c = (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;
            if (b <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
              for (b = 0; b < e.length; b++) {
                if (!(e[b].endValue < this.conversionParameters.minimum))
                  if (d)
                    if (e[b].startValue < this.conversionParameters.minimum) {
                      if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size < e[b].endValue) {
                        a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size;
                        break;
                      } else
                        a += e[b].endValue - this.conversionParameters.minimum - e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue), c -= e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue);
                      d = false;
                    } else if (c > e[b].startValue - this.conversionParameters.minimum) {
                      c -= e[b].startValue - this.conversionParameters.minimum;
                      if (c < e[b].size) {
                        a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;
                        break;
                      } else
                        a += e[b].endValue - e[b].startValue - e[b].size;
                      c -= e[b].size;
                      d = false;
                    } else
                      break;
                  else if (c > e[b].startValue - e[b - 1].endValue) {
                    c -= e[b].startValue - e[b - 1].endValue;
                    if (c < e[b].size) {
                      a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;
                      break;
                    } else
                      a += e[b].endValue - e[b].startValue - e[b].size;
                    c -= e[b].size;
                  } else
                    break;
              }
            else
              for (b = e.length - 1; 0 <= b; b--)
                if (!(e[b].startValue > this.conversionParameters.minimum))
                  if (d)
                    if (e[b].endValue > this.conversionParameters.minimum)
                      if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size > e[b].startValue) {
                        a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size;
                        break;
                      } else
                        a += e[b].startValue - this.conversionParameters.minimum + e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), c += e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), d = false;
                    else if (c < e[b].endValue - this.conversionParameters.minimum) {
                      c -= e[b].endValue - this.conversionParameters.minimum;
                      if (c > -1 * e[b].size) {
                        a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;
                        break;
                      } else
                        a -= e[b].endValue - e[b].startValue - e[b].size;
                      c += e[b].size;
                      d = false;
                    } else
                      break;
                  else if (c < e[b].endValue - e[b + 1].startValue) {
                    c -= e[b].endValue - e[b + 1].startValue;
                    if (c > -1 * e[b].size) {
                      a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;
                      break;
                    } else
                      a -= e[b].endValue - e[b].startValue - e[b].size;
                    c += e[b].size;
                  } else
                    break;
            d = this.conversionParameters.minimum + a;
          }
          return d;
        };
        z.prototype.convertValueToPixel = function(a) {
          a = this.getApparentDifference(
            this.conversionParameters.minimum,
            a,
            a
          );
          return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5;
        };
        z.prototype.getApparentDifference = function(a, d, b, c) {
          var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          if (this.logarithmic) {
            b = u(b) ? d / a : b;
            for (var g = 0; g < e.length && !(d < e[g].startValue); g++)
              a > e[g].endValue || (a <= e[g].startValue && d >= e[g].endValue ? b = b / e[g].endValue * e[g].startValue * e[g].size : a >= e[g].startValue && d >= e[g].endValue ? b = b / e[g].endValue * a * Math.pow(e[g].size, Math.log(e[g].endValue / a) / Math.log(e[g].endValue / e[g].startValue)) : a <= e[g].startValue && d <= e[g].endValue ? b = b / d * e[g].startValue * Math.pow(e[g].size, Math.log(d / e[g].startValue) / Math.log(e[g].endValue / e[g].startValue)) : !c && (a > e[g].startValue && d < e[g].endValue) && (b = a * Math.pow(e[g].size, Math.log(d / a) / Math.log(e[g].endValue / e[g].startValue))));
          } else
            for (b = u(b) ? Math.abs(d - a) : b, g = 0; g < e.length && !(d < e[g].startValue); g++)
              a > e[g].endValue || (a <= e[g].startValue && d >= e[g].endValue ? b = b - e[g].endValue + e[g].startValue + e[g].size : a > e[g].startValue && d >= e[g].endValue ? b = b - e[g].endValue + a + e[g].size * (e[g].endValue - a) / (e[g].endValue - e[g].startValue) : a <= e[g].startValue && d < e[g].endValue ? b = b - d + e[g].startValue + e[g].size * (d - e[g].startValue) / (e[g].endValue - e[g].startValue) : !c && (a > e[g].startValue && d < e[g].endValue) && (b = a + e[g].size * (d - a) / (e[g].endValue - e[g].startValue)));
          return b;
        };
        z.prototype.setViewPortRange = function(a, d) {
          this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, d);
          this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, d);
        };
        z.prototype.getXValueAt = function(a) {
          if (!a)
            return null;
          var d = null;
          "left" === this._position ? d = this.convertPixelToValue(a.y) : "bottom" === this._position && (d = this.convertPixelToValue(a.x));
          return d;
        };
        z.prototype.calculateValueToPixelConversionParameters = function(a) {
          a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          var d = { pixelPerUnit: null, minimum: null, reference: null }, b = this.lineCoordinates.width, c = this.lineCoordinates.height, b = "bottom" === this._position || "top" === this._position ? b : c, c = Math.abs(this.range);
          if (this.logarithmic)
            for (var e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)
              this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c / this.viewportMaximum * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)));
          else
            for (e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)
              this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c - this.viewportMaximum + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)));
          d.minimum = this.viewportMinimum;
          d.maximum = this.viewportMaximum;
          d.range = c;
          if ("bottom" === this._position || "top" === this._position)
            this.logarithmic ? (d.lnLogarithmBase = Math.log(this.logarithmBase), d.pixelPerUnit = (this.reversed ? -1 : 1) * b * d.lnLogarithmBase / Math.log(Math.abs(c))) : d.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(c), d.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;
          if ("left" === this._position || "right" === this._position)
            this.logarithmic ? (d.lnLogarithmBase = Math.log(this.logarithmBase), d.pixelPerUnit = (this.reversed ? 1 : -1) * b * d.lnLogarithmBase / Math.log(Math.abs(c))) : d.pixelPerUnit = (this.reversed ? 1 : -1) * b / Math.abs(c), d.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;
          this.conversionParameters = d;
        };
        z.prototype.calculateAxisParameters = function() {
          if (this.logarithmic)
            this.calculateLogarithmicAxisParameters();
          else {
            var a = this.chart.layoutManager.getFreeSpace(), d = false, b = false;
            "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
            var a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40, c = 4;
            "axisX" === this.type && (c = 600 > this.maxWidth ? 8 : 6);
            var a = Math.max(c, Math.floor(this.maxWidth / a)), e, g, k, c = 0;
            !u(this.options.viewportMinimum) && (!u(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) && (this.viewportMinimum = this.viewportMaximum = null);
            if (u(this.options.viewportMinimum) && !u(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum))
              this.viewportMinimum = this.sessionVariables.newViewportMinimum;
            else if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
              this.viewportMinimum = this.minimum;
            if (u(this.options.viewportMaximum) && !u(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum))
              this.viewportMaximum = this.sessionVariables.newViewportMaximum;
            else if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
              this.viewportMaximum = this.maximum;
            if (this.scaleBreaks) {
              for (c = 0; c < this.scaleBreaks._appliedBreaks.length; c++)
                if ((!u(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue || !u(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[c].startValue || !u(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue) && (!u(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue || !u(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[c].endValue || !u(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue)) {
                  this.scaleBreaks._appliedBreaks.splice(c, 1);
                  break;
                }
            }
            if ("axisX" === this.type) {
              if (this.dataSeries && 0 < this.dataSeries.length)
                for (e = 0; e < this.dataSeries.length; e++)
                  "dateTime" === this.dataSeries[e].xValueType && (b = true);
              e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;
              g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;
              0 === g - e && (c = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c);
              Infinity !== this.dataInfo.minDiff ? k = this.dataInfo.minDiff : 1 < g - e ? k = 0.5 * Math.abs(g - e) : (k = 1, b && (d = true));
            } else
              "axisY" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(e) || isFinite(g) ? isFinite(e) ? isFinite(g) || (g = e) : e = g : (g = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, true)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(
                e,
                g,
                null,
                true
              )), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)), k = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > g && (g = 0));
            c = this.getApparentDifference(
              isNaN(this.viewportMinimum) || null === this.viewportMinimum ? e : this.viewportMinimum,
              isNaN(this.viewportMaximum) || null === this.viewportMaximum ? g : this.viewportMaximum,
              null,
              true
            );
            if ("axisX" === this.type && b) {
              this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : c / 2 <= a ? (this.interval = 2, this.intervalType = "millisecond") : c / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : c / 10 <= a ? (this.interval = 10, this.intervalType = "millisecond") : c / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : c / 50 <= a ? (this.interval = 50, this.intervalType = "millisecond") : c / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : c / 200 <= a ? (this.interval = 200, this.intervalType = "millisecond") : c / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : c / 300 <= a ? (this.interval = 300, this.intervalType = "millisecond") : c / 400 <= a ? (this.interval = 400, this.intervalType = "millisecond") : c / 500 <= a ? (this.interval = 500, this.intervalType = "millisecond") : c / (1 * S.secondDuration) <= a ? (this.interval = 1, this.intervalType = "second") : c / (2 * S.secondDuration) <= a ? (this.interval = 2, this.intervalType = "second") : c / (5 * S.secondDuration) <= a ? (this.interval = 5, this.intervalType = "second") : c / (10 * S.secondDuration) <= a ? (this.interval = 10, this.intervalType = "second") : c / (15 * S.secondDuration) <= a ? (this.interval = 15, this.intervalType = "second") : c / (20 * S.secondDuration) <= a ? (this.interval = 20, this.intervalType = "second") : c / (30 * S.secondDuration) <= a ? (this.interval = 30, this.intervalType = "second") : c / (1 * S.minuteDuration) <= a ? (this.interval = 1, this.intervalType = "minute") : c / (2 * S.minuteDuration) <= a ? (this.interval = 2, this.intervalType = "minute") : c / (5 * S.minuteDuration) <= a ? (this.interval = 5, this.intervalType = "minute") : c / (10 * S.minuteDuration) <= a ? (this.interval = 10, this.intervalType = "minute") : c / (15 * S.minuteDuration) <= a ? (this.interval = 15, this.intervalType = "minute") : c / (20 * S.minuteDuration) <= a ? (this.interval = 20, this.intervalType = "minute") : c / (30 * S.minuteDuration) <= a ? (this.interval = 30, this.intervalType = "minute") : c / (1 * S.hourDuration) <= a ? (this.interval = 1, this.intervalType = "hour") : c / (2 * S.hourDuration) <= a ? (this.interval = 2, this.intervalType = "hour") : c / (3 * S.hourDuration) <= a ? (this.interval = 3, this.intervalType = "hour") : c / (6 * S.hourDuration) <= a ? (this.interval = 6, this.intervalType = "hour") : c / (1 * S.dayDuration) <= a ? (this.interval = 1, this.intervalType = "day") : c / (2 * S.dayDuration) <= a ? (this.interval = 2, this.intervalType = "day") : c / (4 * S.dayDuration) <= a ? (this.interval = 4, this.intervalType = "day") : c / (1 * S.weekDuration) <= a ? (this.interval = 1, this.intervalType = "week") : c / (2 * S.weekDuration) <= a ? (this.interval = 2, this.intervalType = "week") : c / (3 * S.weekDuration) <= a ? (this.interval = 3, this.intervalType = "week") : c / (1 * S.monthDuration) <= a ? (this.interval = 1, this.intervalType = "month") : c / (2 * S.monthDuration) <= a ? (this.interval = 2, this.intervalType = "month") : c / (3 * S.monthDuration) <= a ? (this.interval = 3, this.intervalType = "month") : c / (6 * S.monthDuration) <= a ? (this.interval = 6, this.intervalType = "month") : (this.interval = c / (1 * S.yearDuration) <= a ? 1 : c / (2 * S.yearDuration) <= a ? 2 : c / (4 * S.yearDuration) <= a ? 4 : Math.floor(z.getNiceNumber(c / (a - 1), true) / S.yearDuration), this.intervalType = "year"));
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
                this.viewportMinimum = e - k / 2;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
                this.viewportMaximum = g + k / 2;
              d ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'");
              this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);
            } else {
              this.intervalType = "number";
              c = z.getNiceNumber(c, false);
              this.interval = this.options && 0 < this.options.interval ? this.options.interval : z.getNiceNumber(c / (a - 1), true);
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
                this.viewportMinimum = "axisX" === this.type ? e - k / 2 : Math.floor(e / this.interval) * this.interval;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
                this.viewportMaximum = "axisX" === this.type ? g + k / 2 : Math.ceil(g / this.interval) * this.interval;
              0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && "undefined" === typeof this.options.interval && (this.interval = z.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), true)));
            }
            if (null === this.minimum || null === this.maximum)
              if ("axisX" === this.type ? (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === g - e && (c = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c), k = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1) : "axisY" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(g) ? 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(
                Math.abs(0.01 * Math.abs(g)),
                5
              ), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, true)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, true)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)) : (g = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), k = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > g && (g = 0)), Math.abs(this.getApparentDifference(e, g, null, true)), "axisX" === this.type && b) {
                this.valueType = "dateTime";
                if (null === this.minimum || isNaN(this.minimum))
                  this.minimum = e - k / 2;
                if (null === this.maximum || isNaN(this.maximum))
                  this.maximum = g + k / 2;
              } else
                this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? e - k / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(
                  this.minimum,
                  null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum
                )), null === this.maximum && (this.maximum = "axisX" === this.type ? g + k / 2 : Math.ceil(g / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));
            u(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
            u(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
            this.range = this.viewportMaximum - this.viewportMinimum;
            this.intervalStartPosition = "axisX" === this.type && b ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval;
            this.valueFormatString || (this.valueFormatString = z.generateValueFormatString(this.range, 2));
          }
        };
        z.prototype.calculateLogarithmicAxisParameters = function() {
          var a = this.chart.layoutManager.getFreeSpace(), d = Math.log(this.logarithmBase), b;
          "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
          var a = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3), c, e, g, k;
          k = 1;
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
            this.viewportMinimum = this.minimum;
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
            this.viewportMaximum = this.maximum;
          if (this.scaleBreaks) {
            for (k = 0; k < this.scaleBreaks._appliedBreaks.length; k++)
              if ((!u(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[k].startValue || !u(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[k].startValue || !u(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[k].startValue) && (!u(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[k].endValue || !u(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[k].endValue || !u(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[k].endValue)) {
                this.scaleBreaks._appliedBreaks.splice(k, 1);
                break;
              }
          }
          "axisX" === this.type ? (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / c && (k = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), e *= k, c /= k), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= c && !isFinite(e) ? (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, c = 1) : 0 >= c ? c = e : isFinite(e) || (e = c), 1 === c && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, c = 1) : 1 === e / c ? (k = Math.min(e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), e *= k, c /= k) : c > e ? (k = Math.min(c / e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= e ? c = e / k : e = c * k) : (k = Math.min(e / c * Math.pow(
            this.logarithmBase,
            0.01
          ), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= k), 1 !== c && (c /= k)), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < c && (c = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1));
          k = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);
          var l = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);
          this.intervalType = "number";
          k = Math.pow(this.logarithmBase, z.getNiceNumber(Math.abs(Math.log(k) / d), false));
          this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = z.getNiceExponent(Math.log(k) / d / (a - 1), true), b = z.getNiceNumber(l / (a - 1), true));
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
            this.viewportMinimum = "axisX" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / d / this.interval));
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
            this.viewportMaximum = "axisX" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d / this.interval));
          1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && "undefined" === typeof this.options.interval && (this.interval = z.getNiceExponent(Math.ceil(Math.log(k) / d) / (a - 1)), b = z.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), true)));
          if (null === this.minimum || null === this.maximum)
            "axisX" === this.type ? (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / c && (k = Math.pow(
              this.logarithmBase,
              "undefined" === typeof this.options.interval ? 0.4 : this.options.interval
            ), e *= k, c /= k), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(c) || isFinite(e) ? 1 === c && 1 === e ? (e *= this.logarithmBase, c /= this.logarithmBase) : 1 === e / c ? (k = Math.pow(this.logarithmBase, this.interval), e *= k, c /= k) : c > e ? (k = Math.min(0.01 * (c / e), 5), 1 <= e ? c = e / k : e = c * k) : (k = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= k), 1 !== c && (c /= k)) : (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, c = 1), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < c && (c = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > e && (e = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / d / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));
          this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
          this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);
          this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);
          c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d * this.interval) + 0.2) * this.interval);
          this.range = this.viewportMaximum / this.viewportMinimum;
          this.noTicks = a;
          if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {
            for (d = Math.floor(this.viewportMinimum / b + 0.5) * b; d < this.viewportMinimum; )
              d += b;
            this.equidistantInterval = false;
            this.intervalStartPosition = d;
            this.interval = b;
          } else
            this.options.interval || (b = Math.ceil(this.interval), this.range > this.interval && (this.interval = b, c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d * this.interval) + 0.2) * this.interval))), this.equidistantInterval = true, this.intervalStartPosition = c;
          if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum)) {
            d = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;
            if (isNaN(d) || !isFinite(d))
              d = 2;
            if (2 < d)
              for (k = 0; k < d - 2; k++)
                this.valueFormatString += "#";
          }
        };
        z.generateValueFormatString = function(a, d) {
          var b = "#,##0.", c = d;
          1 > a && (c += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(c) || !isFinite(c)) && (c = d);
          for (var e = 0; e < c; e++)
            b += "#";
          return b;
        };
        z.getNiceExponent = function(a, d) {
          var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = 0 > b ? 1 >= c ? 1 : 5 >= c ? 5 : 10 : Math.max(Math.floor(c), 1);
          return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20));
        };
        z.getNiceNumber = function(a, d) {
          var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = d ? 1.5 > c ? 1 : 3 > c ? 2 : 7 > c ? 5 : 10 : 1 >= c ? 1 : 2 >= c ? 2 : 5 >= c ? 5 : 10;
          return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20));
        };
        z.prototype.getLabelStartPoint = function() {
          var a = S[this.intervalType + "Duration"] * this.interval, a = new Date(Math.floor(this.viewportMinimum / a) * a);
          if ("millisecond" !== this.intervalType)
            if ("second" === this.intervalType)
              0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));
            else if ("minute" === this.intervalType) {
              if (0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("hour" === this.intervalType) {
              if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("day" === this.intervalType) {
              if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("week" === this.intervalType) {
              if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("month" === this.intervalType) {
              if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else
              "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));
          return a;
        };
        qa(Q2, V);
        qa(L, V);
        L.prototype.createUserOptions = function(a) {
          if ("undefined" !== typeof a || this.options._isPlaceholder) {
            var d = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Fa(this.parent[this.optionsName]), d = this.parent.options[this.optionsName].indexOf(this.options));
            this.options = "undefined" === typeof a ? {} : a;
            this.parent.options[this.optionsName][d] = this.options;
          }
        };
        L.prototype.render = function(a) {
          if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {
            var d = this.ctx, b = this.ctx.globalAlpha;
            this.ctx = a || this.ctx;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.ctx.clip();
            var c = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);
            this.ctx.strokeStyle = this.lineColor;
            this.ctx.fillStyle = this.color;
            this.ctx.beginPath();
            this.ctx.globalAlpha = 1;
            N(this.id);
            var g, k, l, h2, m, p2;
            a = Math.max(this.spacing, 3);
            var q = Math.max(0, this.lineThickness);
            this.ctx.lineWidth = q;
            this.ctx.setLineDash && this.ctx.setLineDash(R(this.lineDashType, q));
            if ("bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position)
              if (c = 1 === q % 2 ? (c.x << 0) + 0.5 : c.x << 0, k = 1 === q % 2 ? (e.x << 0) + 0.5 : e.x << 0, "top" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, l = this.chart.plotArea.y2 + q / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, l = this.chart.plotArea.y1 - q / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c - q / 2, y1: e, x2: k + q / 2, y2: l }, this.ctx.moveTo(c, e), "straight" === this.type || "top" === this.scaleBreaks.parent._position && 0 >= a || "bottom" === this.scaleBreaks.parent._position && 0 <= a)
                this.ctx.lineTo(c, l), this.ctx.lineTo(k, l), this.ctx.lineTo(k, e);
              else if ("wavy" === this.type) {
                h2 = c;
                m = e;
                g = 0.5;
                p2 = (l - m) / a / 3;
                for (var n = 0; n < p2; n++)
                  this.ctx.bezierCurveTo(h2 + g * a, m + a, h2 + g * a, m + 2 * a, h2, m + 3 * a), m += 3 * a, g *= -1;
                this.ctx.bezierCurveTo(h2 + g * a, m + a, h2 + g * a, m + 2 * a, h2, m + 3 * a);
                h2 = k;
                g *= -1;
                this.ctx.lineTo(h2, m);
                for (n = 0; n < p2; n++)
                  this.ctx.bezierCurveTo(h2 + g * a, m - a, h2 + g * a, m - 2 * a, h2, m - 3 * a), m -= 3 * a, g *= -1;
              } else {
                if ("zigzag" === this.type) {
                  g = -1;
                  m = e + a;
                  h2 = c + a;
                  p2 = (l - m) / a / 2;
                  for (n = 0; n < p2; n++)
                    this.ctx.lineTo(h2, m), h2 += 2 * g * a, m += 2 * a, g *= -1;
                  this.ctx.lineTo(h2, m);
                  h2 += k - c;
                  for (n = 0; n < p2 + 1; n++)
                    this.ctx.lineTo(h2, m), h2 += 2 * g * a, m -= 2 * a, g *= -1;
                  this.ctx.lineTo(h2 + g * a, m + a);
                }
              }
            else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position) {
              if (e = 1 === q % 2 ? (e.y << 0) + 0.5 : e.y << 0, l = 1 === q % 2 ? (c.y << 0) + 0.5 : c.y << 0, "left" === this.scaleBreaks.parent._position ? (c = this.chart.plotArea.x1, k = this.chart.plotArea.x2 + q / 2 + 0.5 << 0) : (c = this.chart.plotArea.x2, k = this.chart.plotArea.x1 - q / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c, y1: e - q / 2, x2: k, y2: l + q / 2 }, this.ctx.moveTo(c, e), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= a || "right" === this.scaleBreaks.parent._position && 0 <= a)
                this.ctx.lineTo(k, e), this.ctx.lineTo(k, l), this.ctx.lineTo(c, l);
              else if ("wavy" === this.type) {
                h2 = c;
                m = e;
                g = 0.5;
                p2 = (k - h2) / a / 3;
                for (n = 0; n < p2; n++)
                  this.ctx.bezierCurveTo(h2 + a, m + g * a, h2 + 2 * a, m + g * a, h2 + 3 * a, m), h2 += 3 * a, g *= -1;
                this.ctx.bezierCurveTo(h2 + a, m + g * a, h2 + 2 * a, m + g * a, h2 + 3 * a, m);
                m = l;
                g *= -1;
                this.ctx.lineTo(h2, m);
                for (n = 0; n < p2; n++)
                  this.ctx.bezierCurveTo(h2 - a, m + g * a, h2 - 2 * a, m + g * a, h2 - 3 * a, m), h2 -= 3 * a, g *= -1;
              } else if ("zigzag" === this.type) {
                g = 1;
                m = e - a;
                h2 = c + a;
                p2 = (k - h2) / a / 2;
                for (n = 0; n < p2; n++)
                  this.ctx.lineTo(h2, m), m += 2 * g * a, h2 += 2 * a, g *= -1;
                this.ctx.lineTo(h2, m);
                m += l - e;
                for (n = 0; n < p2 + 1; n++)
                  this.ctx.lineTo(
                    h2,
                    m
                  ), m += 2 * g * a, h2 -= 2 * a, g *= -1;
                this.ctx.lineTo(h2 + a, m + g * a);
              }
            }
            0 < q && this.ctx.stroke();
            this.ctx.closePath();
            this.ctx.globalAlpha = this.fillOpacity;
            this.ctx.globalCompositeOperation = "destination-over";
            this.ctx.fill();
            this.ctx.restore();
            this.ctx.globalAlpha = b;
            this.ctx = d;
          }
        };
        qa(X2, V);
        X2.prototype.createUserOptions = function(a) {
          if ("undefined" !== typeof a || this.options._isPlaceholder) {
            var d = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Fa(this.parent.stripLines), d = this.parent.options.stripLines.indexOf(this.options));
            this.options = "undefined" === typeof a ? {} : a;
            this.parent.options.stripLines[d] = this.options;
          }
        };
        X2.prototype.render = function() {
          this.ctx.save();
          var a = this.parent.getPixelCoordinatesOnAxis(this.value), d = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);
          if (0 < d) {
            var b = null === this.opacity ? 1 : this.opacity;
            this.ctx.strokeStyle = this.color;
            this.ctx.beginPath();
            var c = this.ctx.globalAlpha;
            this.ctx.globalAlpha = b;
            N(this.id);
            var e, g, k, l;
            this.ctx.lineWidth = d;
            this.ctx.setLineDash && this.ctx.setLineDash(R(this.lineDashType, d));
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              e = g = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, k = this.chart.plotArea.y1, l = this.chart.plotArea.y2, this.bounds = { x1: e - d / 2, y1: k, x2: g + d / 2, y2: l };
            else if ("left" === this.parent._position || "right" === this.parent._position)
              k = l = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, e = this.chart.plotArea.x1, g = this.chart.plotArea.x2, this.bounds = { x1: e, y1: k - d / 2, x2: g, y2: l + d / 2 };
            this.ctx.moveTo(
              e,
              k
            );
            this.ctx.lineTo(g, l);
            this.ctx.stroke();
            this.ctx.globalAlpha = c;
          }
          this.ctx.restore();
        };
        qa(fa2, V);
        fa2.prototype.render = function(a, d) {
          var b, c, e, g, k = null, l = k = null, h2 = "";
          if (!this.valueFormatString)
            if ("dateTime" === this.parent.valueType)
              this.valueFormatString = this.parent.valueFormatString;
            else {
              var m = 0, m = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0);
              this.valueFormatString = z.generateValueFormatString(this.parent.range, m);
            }
          var l = null === this.opacity ? 1 : this.opacity, m = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), p2 = this.chart.overlaidCanvasCtx, q = p2.globalAlpha;
          p2.globalAlpha = l;
          p2.beginPath();
          p2.strokeStyle = this.color;
          p2.lineWidth = m;
          p2.save();
          this.labelFontSize = u(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize;
          if ("left" === this.parent._position || "right" === this.parent._position)
            this.labelMaxWidth = u(this.options.labelMaxWidth) ? this.parent.bounds.x2 - this.parent.bounds.x1 : this.labelMaxWidth, this.labelMaxHeight = u(this.options.labelWrap) || this.labelWrap ? 3 * this.chart.height : 2 * this.labelFontSize;
          else if ("top" === this.parent._position || "bottom" === this.parent._position)
            this.labelMaxWidth = u(this.options.labelMaxWidth) ? 3 * this.chart.width : this.labelMaxWidth, this.labelMaxHeight = u(this.options.labelWrap) || this.labelWrap ? this.parent.bounds.height : 2 * this.labelFontSize;
          0 < m && p2.setLineDash && p2.setLineDash(R(this.lineDashType, m));
          l = new ka(p2, {
            x: 0,
            y: 0,
            padding: { top: 2, right: 3, bottom: 2, left: 4 },
            backgroundColor: this.labelBackgroundColor,
            borderColor: this.labelBorderColor,
            borderThickness: this.labelBorderThickness,
            cornerRadius: this.labelCornerRadius,
            maxWidth: this.labelMaxWidth,
            maxHeight: this.labelMaxHeight,
            angle: this.labelAngle,
            text: h2,
            horizontalAlign: "left",
            fontSize: this.labelFontSize,
            fontFamily: this.labelFontFamily,
            fontWeight: this.labelFontWeight,
            fontColor: this.labelFontColor,
            fontStyle: this.labelFontStyle,
            textBaseline: "middle"
          });
          if (this.snapToDataPoint) {
            var n = 0, k = [];
            if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
              var f = null;
              if ("bottom" === this.parent._position || "top" === this.parent._position)
                n = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: d });
              else if ("left" === this.parent._position || "right" === this.parent._position)
                n = this.parent.convertPixelToValue({ y: d });
              for (var r2 = 0; r2 < this.parent.dataSeries.length; r2++)
                (f = this.parent.dataSeries[r2].getDataPointAtX(n, true)) && 0 <= f.index && (f.dataSeries = this.parent.dataSeries[r2], null !== f.dataPoint.y && k.push(f));
              f = null;
              if (0 === k.length)
                return;
              k.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y));
              r2 = 0;
              if ("rangeBar" === k[0].dataSeries.type || "error" === k[0].dataSeries.type)
                for (var f = Math.abs(a - this.parent.convertValueToPixel(k[r2].dataPoint.y[0])), v3 = 0, n = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    v3 = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y)), v3 < f && (f = v3, r2 = n);
              else if ("stackedBar" === k[0].dataSeries.type)
                for (var f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y)), D = v3 = 0, n = r2 = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    D += k[n].dataPoint.y, v3 = Math.abs(a - this.parent.convertValueToPixel(D)), v3 < f && (f = v3, r2 = n);
              else if ("stackedBar100" === k[0].dataSeries.type)
                for (var f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y)), t = D = v3 = 0, n = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ? k[n].dataPoint.x.getTime() : k[n].dataPoint.x, t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]), v3 = Math.abs(a - this.parent.convertValueToPixel(t)), v3 < f && (f = v3, r2 = n);
              else
                for (f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = r2 = v3 = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    v3 = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y)), v3 < f && (f = v3, r2 = n);
              h2 = k[r2];
              if ("bottom" === this.parent._position || "top" === this.parent._position) {
                b = 0;
                if ("rangeBar" === this.parent.dataSeries[r2].type || "error" === this.parent.dataSeries[r2].type) {
                  f = Math.abs(a - this.parent.convertValueToPixel(h2.dataPoint.y[0]));
                  for (n = v3 = 0; n < h2.dataPoint.y.length; n++)
                    v3 = Math.abs(a - this.parent.convertValueToPixel(h2.dataPoint.y[n])), v3 < f && (f = v3, b = n);
                  k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(h2.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(h2.dataPoint.y[b]) << 0;
                  l.text = this.labelFormatter ? this.labelFormatter({
                    chart: this.chart,
                    axis: this.parent.options,
                    crosshair: this.options,
                    value: h2.dataPoint.y[b]
                  }) : u(this.options.label) ? ba(h2.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else if ("stackedBar" === this.parent.dataSeries[r2].type) {
                  f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y));
                  D = v3 = 0;
                  for (n = r2; 0 <= n; n--)
                    D += k[n].dataPoint.y, v3 = Math.abs(a - this.parent.convertValueToPixel(D)), v3 < f && (f = v3, b = n);
                  k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(D) << 0) + 0.5 : this.parent.convertValueToPixel(D) << 0;
                  l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.y }) : u(this.options.label) ? ba(h2.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else if ("stackedBar100" === this.parent.dataSeries[r2].type) {
                  f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y));
                  t = D = v3 = 0;
                  for (n = r2; 0 <= n; n--)
                    D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ? k[n].dataPoint.x.getTime() : k[n].dataPoint.x, t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]), v3 = Math.abs(a - this.parent.convertValueToPixel(t)), v3 < f && (f = v3, b = n);
                  k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(t) << 0) + 0.5 : this.parent.convertValueToPixel(t) << 0;
                  l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: t }) : u(this.options.label) ? ba(t, this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else
                  k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(h2.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(h2.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.y }) : u(this.options.label) ? ba(h2.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;
                b = c = k;
                e = this.chart.plotArea.y1;
                g = this.chart.plotArea.y2;
                this.bounds = { x1: b - m / 2, y1: e, x2: c + m / 2, y2: g };
                l.x = b - l.measureText().width / 2;
                l.x + l.width > this.chart.bounds.x2 ? l.x = this.chart.bounds.x2 - l.width : l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);
                l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2;
              } else if ("left" === this.parent._position || "right" === this.parent._position) {
                e = g = k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(h2.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(h2.dataPoint.x) << 0;
                b = this.chart.plotArea.x1;
                c = this.chart.plotArea.x2;
                this.bounds = { x1: b, y1: e - m / 2, x2: c, y2: g + m / 2 };
                t = false;
                if (this.parent.labels)
                  for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)
                    if (this.parent.labels[n])
                      t = true;
                    else {
                      t = false;
                      break;
                    }
                if (t) {
                  if ("axisX" === this.parent.type)
                    for (n = this.parent.convertPixelToValue({ y: d }), f = null, r2 = 0; r2 < this.parent.dataSeries.length; r2++)
                      (f = this.parent.dataSeries[r2].getDataPointAtX(n, true)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.x }) : u(this.options.label) ? f.dataPoint.label : this.label);
                } else
                  "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.x }) : u(this.options.label) ? Ca(h2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.x }) : u(this.options.label) ? ba(h2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);
                l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;
                l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);
                "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);
              }
            } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              n = this.parent.convertPixelToValue({ x: a });
              for (r2 = 0; r2 < this.parent.dataSeries.length; r2++)
                (f = this.parent.dataSeries[r2].getDataPointAtX(n, true)) && 0 <= f.index && (f.dataSeries = this.parent.dataSeries[r2], null !== f.dataPoint.y && k.push(f));
              if (0 === k.length)
                return;
              k.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              h2 = k[0];
              b = c = k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(h2.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(h2.dataPoint.x) << 0;
              e = this.chart.plotArea.y1;
              g = this.chart.plotArea.y2;
              this.bounds = { x1: b - m / 2, y1: e, x2: c + m / 2, y2: g };
              t = false;
              if (this.parent.labels)
                for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)
                  if (this.parent.labels[n])
                    t = true;
                  else {
                    t = false;
                    break;
                  }
              if (t) {
                if ("axisX" === this.parent.type)
                  for (n = this.parent.convertPixelToValue({ x: a }), f = null, r2 = 0; r2 < this.parent.dataSeries.length; r2++)
                    (f = this.parent.dataSeries[r2].getDataPointAtX(n, true)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.x }) : u(this.options.label) ? f.dataPoint.label : this.label);
              } else
                "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: h2.dataPoint.x
                }) : u(this.options.label) ? Ca(h2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.x }) : u(this.options.label) ? ba(h2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);
              l.x = b - l.measureText().width / 2;
              l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);
              l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position) {
              !u(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (n = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a }));
              for (r2 = 0; r2 < this.parent.dataSeries.length; r2++)
                (f = this.parent.dataSeries[r2].getDataPointAtX(n, true)) && 0 <= f.index && (f.dataSeries = this.parent.dataSeries[r2], null !== f.dataPoint.y && k.push(f));
              if (0 === k.length)
                return;
              k.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              r2 = 0;
              if ("rangeColumn" === k[0].dataSeries.type || "rangeArea" === k[0].dataSeries.type || "error" === k[0].dataSeries.type || "rangeSplineArea" === k[0].dataSeries.type || "candlestick" === k[0].dataSeries.type || "ohlc" === k[0].dataSeries.type || "boxAndWhisker" === k[0].dataSeries.type)
                for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y[0])), n = v3 = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    v3 = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y)), v3 < f && (f = v3, r2 = n);
              else if ("stackedColumn" === k[0].dataSeries.type || "stackedArea" === k[0].dataSeries.type)
                for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = D = v3 = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    D += k[n].dataPoint.y, v3 = Math.abs(d - this.parent.convertValueToPixel(D)), v3 < f && (f = v3, r2 = n);
              else if ("stackedColumn100" === k[0].dataSeries.type || "stackedArea100" === k[0].dataSeries.type)
                for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = t = D = v3 = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ? k[n].dataPoint.x.getTime() : k[n].dataPoint.x, t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]), v3 = Math.abs(d - this.parent.convertValueToPixel(t)), v3 < f && (f = v3, r2 = n);
              else
                for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = v3 = 0; n < k.length; n++)
                  if (k[n].dataPoint.y && k[n].dataPoint.y.length)
                    for (h2 = 0; h2 < k[n].dataPoint.y.length; h2++)
                      v3 = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h2])), v3 < f && (f = v3, r2 = n);
                  else
                    v3 = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y)), v3 < f && (f = v3, r2 = n);
              h2 = k[r2];
              b = 0;
              if ("rangeColumn" === this.parent.dataSeries[r2].type || "rangeArea" === this.parent.dataSeries[r2].type || "error" === this.parent.dataSeries[r2].type || "rangeSplineArea" === this.parent.dataSeries[r2].type || "candlestick" === this.parent.dataSeries[r2].type || "ohlc" === this.parent.dataSeries[r2].type || "boxAndWhisker" === this.parent.dataSeries[r2].type) {
                f = Math.abs(d - this.parent.convertValueToPixel(h2.dataPoint.y[0]));
                for (n = v3 = 0; n < h2.dataPoint.y.length; n++)
                  v3 = Math.abs(d - this.parent.convertValueToPixel(h2.dataPoint.y[n])), v3 < f && (f = v3, b = n);
                k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(h2.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(h2.dataPoint.y[b]) << 0;
                l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.y[b] }) : u(this.options.label) ? ba(h2.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;
              } else if ("stackedColumn" === this.parent.dataSeries[r2].type || "stackedArea" === this.parent.dataSeries[r2].type) {
                f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y));
                D = v3 = 0;
                for (n = r2; 0 <= n; n--)
                  D += k[n].dataPoint.y, v3 = Math.abs(d - this.parent.convertValueToPixel(D)), v3 < f && (f = v3, b = n);
                k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(D) << 0) + 0.5 : this.parent.convertValueToPixel(D) << 0;
                l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.y }) : u(this.options.label) ? ba(h2.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;
              } else if ("stackedColumn100" === this.parent.dataSeries[r2].type || "stackedArea100" === this.parent.dataSeries[r2].type) {
                f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y));
                D = v3 = 0;
                for (n = r2; 0 <= n; n--)
                  D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ? k[n].dataPoint.x.getTime() : k[n].dataPoint.x, t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]), v3 = Math.abs(d - this.parent.convertValueToPixel(t)), v3 < f && (f = v3, b = n);
                k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(t) << 0) + 0.5 : this.parent.convertValueToPixel(t) << 0;
                l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: t }) : u(this.options.label) ? ba(t, this.valueFormatString, this.chart._cultureInfo) : this.label;
              } else
                "waterfall" === this.parent.dataSeries[r2].type ? (k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(h2.dataSeries.dataPointEOs[h2.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(h2.dataSeries.dataPointEOs[h2.index].cumulativeSum) << 0, l.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: h2.dataSeries.dataPointEOs[h2.index].cumulativeSum
                }) : u(this.options.label) ? ba(h2.dataSeries.dataPointEOs[h2.index].cumulativeSum, this.valueFormatString, this.chart._cultureInfo) : this.label) : (k = 1 === p2.lineWidth % 2 ? (this.parent.convertValueToPixel(h2.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(h2.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h2.dataPoint.y }) : u(this.options.label) ? ba(
                  h2.dataPoint.y,
                  this.valueFormatString,
                  this.chart._cultureInfo
                ) : this.label);
              e = g = k;
              b = this.chart.plotArea.x1;
              c = this.chart.plotArea.x2;
              this.bounds = { x1: b, y1: e - m / 2, x2: c, y2: g + m / 2 };
              l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;
              l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);
              "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);
            }
            k = null;
            ("bottom" === this.parent._position || "top" === this.parent._position) && (b >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && c <= this.parent.convertValueToPixel(this.parent.viewportMaximum)) && (0 < m && (p2.moveTo(b, e), p2.lineTo(c, g), p2.stroke()), p2.restore(), !u(l.text) && ("number" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(true));
            ("left" === this.parent._position || "right" === this.parent._position) && (g >= this.parent.convertValueToPixel(this.parent.viewportMaximum) && e <= this.parent.convertValueToPixel(this.parent.viewportMinimum)) && (0 < m && (p2.moveTo(b, e), p2.lineTo(c, g), p2.stroke()), p2.restore(), !u(l.text) && ("number" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(true));
          } else {
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              b = c = k = 1 === p2.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, e = this.chart.plotArea.y1, g = this.chart.plotArea.y2, this.bounds = { x1: b - m / 2, y1: e, x2: c + m / 2, y2: g };
            else if ("left" === this.parent._position || "right" === this.parent._position)
              e = g = k = 1 === p2.lineWidth % 2 ? (d << 0) + 0.5 : d << 0, b = this.chart.plotArea.x1, c = this.chart.plotArea.x2, this.bounds = { x1: b, y1: e - m / 2, x2: c, y2: g + m / 2 };
            if ("xySwapped" === this.chart.plotInfo.axisPlacement)
              if ("left" === this.parent._position || "right" === this.parent._position) {
                t = false;
                if (this.parent.labels)
                  for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)
                    if (this.parent.labels[n])
                      t = true;
                    else {
                      t = false;
                      break;
                    }
                if (t) {
                  if ("axisX" === this.parent.type)
                    for (n = this.parent.convertPixelToValue({ y: d }), f = null, r2 = 0; r2 < this.parent.dataSeries.length; r2++)
                      (f = this.parent.dataSeries[r2].getDataPointAtX(n, true)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : u(this.options.label) ? f.dataPoint.label : this.label);
                } else
                  "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(d) }) : u(this.options.label) ? Ca(
                    this.parent.convertPixelToValue(d),
                    this.valueFormatString,
                    this.chart._cultureInfo
                  ) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(d) }) : u(this.options.label) ? ba(this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) : this.label);
                l.y = d + l.fontSize / 2 - l.measureText().height / 2 + 2;
                l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);
                "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x1 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);
              } else {
                if ("bottom" === this.parent._position || "top" === this.parent._position)
                  l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : u(this.options.label) ? ba(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label, l.x = b - l.measureText().width / 2, l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width), l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1), "bottom" === this.parent._position && (l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2), "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);
              }
            else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              t = false;
              h2 = "";
              if (this.parent.labels)
                for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)
                  if (this.parent.labels[n])
                    t = true;
                  else {
                    t = false;
                    break;
                  }
              if (t) {
                if ("axisX" === this.parent.type)
                  for (n = this.parent.convertPixelToValue({ x: a }), f = null, r2 = 0; r2 < this.parent.dataSeries.length; r2++)
                    (f = this.parent.dataSeries[r2].getDataPointAtX(n, true)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : u(this.options.label) ? f.dataPoint.label : this.label);
              } else
                "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : u(this.options.label) ? Ca(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : ""
                }) : u(this.options.label) ? ba(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label);
              l.x = b - l.measureText().width / 2;
              l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);
              l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position)
              l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(d) }) : u(this.options.label) ? ba(this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) : this.label, l.y = d + l.fontSize / 2 - l.measureText().height / 2 + 2, l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2), "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);
            0 < m && (p2.moveTo(b, e), p2.lineTo(c, g), p2.stroke());
            p2.restore();
            !u(l.text) && ("number" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(true);
          }
          p2.globalAlpha = q;
        };
        qa($2, V);
        $2.prototype._initialize = function() {
          if (this.enabled) {
            this.container = document.createElement("div");
            this.container.setAttribute("class", "canvasjs-chart-tooltip");
            this.container.style.position = "absolute";
            this.container.style.height = "auto";
            this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)";
            this.container.style.zIndex = "1000";
            this.container.style.pointerEvents = "none";
            this.container.style.display = "none";
            var a;
            a = '<div style=" width: auto;height: auto;min-width: 50px;';
            a += "line-height: auto;";
            a += "margin: 0px 0px 0px 0px;";
            a += "padding: 5px;";
            a += "font-family: Calibri, Arial, Georgia, serif;";
            a += "font-weight: normal;";
            a += "font-style: " + (r ? "italic;" : "normal;");
            a += "font-size: 14px;";
            a += "color: #000000;";
            a += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);";
            a += "text-align: left;";
            a += "border: 2px solid gray;";
            a += r ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);";
            a += "text-indent: 0px;";
            a += "white-space: nowrap;";
            a += "border-radius: 5px;";
            a += "-moz-user-select:none;";
            a += "-khtml-user-select: none;";
            a += "-webkit-user-select: none;";
            a += "-ms-user-select: none;";
            a += "user-select: none;";
            r || (a += "filter: alpha(opacity = 90);", a += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');");
            a += '} "> Sample Tooltip</div>';
            this.container.innerHTML = a;
            this.contentDiv = this.container.firstChild;
            this.container.style.borderRadius = this.contentDiv.style.borderRadius;
            this.chart._canvasJSContainer.appendChild(this.container);
          }
        };
        $2.prototype.mouseMoveHandler = function(a, d) {
          this._lastUpdated && 4 > (/* @__PURE__ */ new Date()).getTime() - this._lastUpdated || (this._lastUpdated = (/* @__PURE__ */ new Date()).getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, d));
        };
        $2.prototype._updateToolTip = function(a, d, b) {
          b = "undefined" === typeof b ? true : b;
          this.container || this._initialize();
          this.enabled || this.hide();
          if (!this.chart.disableToolTip) {
            if ("undefined" === typeof a || "undefined" === typeof d) {
              if (isNaN(this._prevX) || isNaN(this._prevY))
                return;
              a = this._prevX;
              d = this._prevY;
            } else
              this._prevX = a, this._prevY = d;
            var c = null, e = null, g = [], k = 0;
            if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
              if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                var l = [];
                if (this.chart.axisX)
                  for (var h2 = 0; h2 < this.chart.axisX.length; h2++) {
                    for (var k = this.chart.axisX[h2].convertPixelToValue({ y: d }), m = null, c = 0; c < this.chart.axisX[h2].dataSeries.length; c++)
                      (m = this.chart.axisX[h2].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX[h2].dataSeries[c], null !== m.dataPoint.y && l.push(m));
                    m = null;
                  }
                if (this.chart.axisX2)
                  for (h2 = 0; h2 < this.chart.axisX2.length; h2++) {
                    k = this.chart.axisX2[h2].convertPixelToValue({ y: d });
                    m = null;
                    for (c = 0; c < this.chart.axisX2[h2].dataSeries.length; c++)
                      (m = this.chart.axisX2[h2].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX2[h2].dataSeries[c], null !== m.dataPoint.y && l.push(m));
                    m = null;
                  }
              } else {
                l = [];
                if (this.chart.axisX)
                  for (h2 = 0; h2 < this.chart.axisX.length; h2++)
                    for (k = this.chart.axisX[h2].convertPixelToValue({ x: a }), m = null, c = 0; c < this.chart.axisX[h2].dataSeries.length; c++)
                      (m = this.chart.axisX[h2].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX[h2].dataSeries[c], null !== m.dataPoint.y && l.push(m));
                if (this.chart.axisX2)
                  for (h2 = 0; h2 < this.chart.axisX2.length; h2++)
                    for (k = this.chart.axisX2[h2].convertPixelToValue({ x: a }), m = null, c = 0; c < this.chart.axisX2[h2].dataSeries.length; c++)
                      (m = this.chart.axisX2[h2].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX2[h2].dataSeries[c], null !== m.dataPoint.y && l.push(m));
              }
              if (0 === l.length)
                return;
              l.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              b = l[0];
              for (c = 0; c < l.length; c++)
                l[c].dataPoint.x.valueOf() === b.dataPoint.x.valueOf() && g.push(l[c]);
              l = null;
            } else {
              if (m = this.chart.getDataPointAtXY(a, d, b))
                this.currentDataPointIndex = m.dataPointIndex, this.currentSeriesIndex = m.dataSeries.index;
              else if (r)
                if (m = ab(a, d, this.chart._eventManager.ghostCtx), 0 < m && "undefined" !== typeof this.chart._eventManager.objectMap[m]) {
                  m = this.chart._eventManager.objectMap[m];
                  if ("legendItem" === m.objectType)
                    return;
                  this.currentSeriesIndex = m.dataSeriesIndex;
                  this.currentDataPointIndex = 0 <= m.dataPointIndex ? m.dataPointIndex : -1;
                } else
                  this.currentDataPointIndex = -1;
              else
                this.currentDataPointIndex = -1;
              if (0 <= this.currentSeriesIndex) {
                e = this.chart.data[this.currentSeriesIndex];
                m = {};
                if (0 <= this.currentDataPointIndex)
                  c = e.dataPoints[this.currentDataPointIndex], m.dataSeries = e, m.dataPoint = c, m.index = this.currentDataPointIndex, m.distance = Math.abs(c.x - k), "waterfall" === e.type && (m.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, m.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);
                else {
                  if (!this.enabled || "line" !== e.type && "stepLine" !== e.type && "spline" !== e.type && "area" !== e.type && "stepArea" !== e.type && "splineArea" !== e.type && "stackedArea" !== e.type && "stackedArea100" !== e.type && "rangeArea" !== e.type && "rangeSplineArea" !== e.type && "candlestick" !== e.type && "ohlc" !== e.type && "boxAndWhisker" !== e.type)
                    return;
                  k = e.axisX.convertPixelToValue({ x: a });
                  m = e.getDataPointAtX(k, b);
                  u(m) || (m.dataSeries = e, this.currentDataPointIndex = m.index, c = m.dataPoint);
                }
                if (!u(m) && !u(m.dataPoint) && !u(m.dataPoint.y))
                  if (m.dataSeries.axisY)
                    if (0 < m.dataPoint.y.length) {
                      for (c = b = 0; c < m.dataPoint.y.length; c++)
                        m.dataPoint.y[c] < m.dataSeries.axisY.viewportMinimum ? b-- : m.dataPoint.y[c] > m.dataSeries.axisY.viewportMaximum && b++;
                      b < m.dataPoint.y.length && b > -m.dataPoint.y.length && g.push(m);
                    } else
                      "column" === e.type || "bar" === e.type ? 0 > m.dataPoint.y ? 0 > m.dataSeries.axisY.viewportMinimum && m.dataSeries.axisY.viewportMaximum >= m.dataPoint.y && g.push(m) : m.dataSeries.axisY.viewportMinimum <= m.dataPoint.y && 0 <= m.dataSeries.axisY.viewportMaximum && g.push(m) : "bubble" === e.type ? (b = this.chart._eventManager.objectMap[e.dataPointIds[m.index]].size / 2, m.dataPoint.y >= m.dataSeries.axisY.viewportMinimum - b && m.dataPoint.y <= m.dataSeries.axisY.viewportMaximum + b && g.push(m)) : "waterfall" === e.type ? (b = 0, m.cumulativeSumYStartValue < m.dataSeries.axisY.viewportMinimum ? b-- : m.cumulativeSumYStartValue > m.dataSeries.axisY.viewportMaximum && b++, m.cumulativeSum < m.dataSeries.axisY.viewportMinimum ? b-- : m.cumulativeSum > m.dataSeries.axisY.viewportMaximum && b++, 2 > b && -2 < b && g.push(m)) : (0 <= m.dataSeries.type.indexOf("100") || "stackedColumn" === e.type || "stackedBar" === e.type || m.dataPoint.y >= m.dataSeries.axisY.viewportMinimum && m.dataPoint.y <= m.dataSeries.axisY.viewportMaximum) && g.push(m);
                  else
                    g.push(m);
              }
            }
            if (0 < g.length) {
              if (this.highlightObjects(g), this.enabled)
                if (b = "", b = this.getToolTipInnerHTML({ entries: g }), null !== b) {
                  this.contentDiv.innerHTML = b;
                  b = false;
                  "none" === this.container.style.display && (b = true, this.container.style.display = "block");
                  try {
                    this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : 0 < g[0].dataPoint.y ? g[0].dataSeries.risingColor : g[0].dataSeries.fallingColor : "error" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[e.index % g[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[g[0].index % g[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : r ? "italic" : "normal";
                  } catch (p2) {
                  }
                  "pie" === g[0].dataSeries.type || "doughnut" === g[0].dataSeries.type || "funnel" === g[0].dataSeries.type || "pyramid" === g[0].dataSeries.type || "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" === g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);
                  0 > a && (a += this.container.clientWidth + 20);
                  a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
                  d = 1 !== g.length || this.shared || "line" !== g[0].dataSeries.type && "stepLine" !== g[0].dataSeries.type && "spline" !== g[0].dataSeries.type && "area" !== g[0].dataSeries.type && "stepArea" !== g[0].dataSeries.type && "splineArea" !== g[0].dataSeries.type ? "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" === g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) : d : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y);
                  d = -d + 10;
                  0 < d + this.container.clientHeight + 5 && (d -= d + this.container.clientHeight + 5 - 0);
                  this.fixMozTransitionDelay(a, d);
                  !this.animationEnabled || b ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
                  this.container.style.left = a + "px";
                  this.container.style.bottom = d + "px";
                } else
                  this.hide(false);
            } else
              this.hide();
          }
        };
        $2.prototype.highlightObjects = function(a) {
          var d = this.chart.overlaidCanvasCtx;
          this.chart.resetOverlayedCanvas();
          d.clearRect(0, 0, this.chart.width, this.chart.height);
          d.save();
          var b = this.chart.plotArea, c = 0;
          d.beginPath();
          d.rect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);
          d.clip();
          for (b = 0; b < a.length; b++) {
            var e = a[b];
            if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && "dataPoint" === e.objectType) {
              var c = this.chart.data[e.dataSeriesIndex], g = c.dataPoints[e.dataPointIndex], k = e.dataPointIndex;
              false === g.highlightEnabled || true !== c.highlightEnabled && true !== g.highlightEnabled || ("line" === c.type || "stepLine" === c.type || "spline" === c.type || "scatter" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type ? (g = c.getMarkerProperties(k, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || "#FFFFFF", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), ia.drawMarkers([g]), "undefined" !== typeof e.y2 && (g = c.getMarkerProperties(k, e.x1, e.y2, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || "#FFFFFF", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), ia.drawMarkers([g]))) : "bubble" === c.type ? (g = c.getMarkerProperties(k, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = e.size, g.color = "white", g.borderColor = "white", d.globalAlpha = 0.3, ia.drawMarkers([g]), d.globalAlpha = 1) : "column" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "bar" === c.type || "rangeBar" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "rangeColumn" === c.type || "waterfall" === c.type ? ea(d, e.x1, e.y1, e.x2, e.y2, "white", 0, null, false, false, false, false, 0.3) : "pie" === c.type || "doughnut" === c.type ? ja2(d, e.center, e.radius, "white", c.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : "funnel" === c.type || "pyramid" === c.type ? ra2(d, e.funnelSection, 0.3, "white") : "candlestick" === c.type ? (d.globalAlpha = 1, d.strokeStyle = e.color, d.lineWidth = 2 * e.borderThickness, c = 0 === d.lineWidth % 2 ? 0 : 0.5, d.beginPath(), d.moveTo(e.x3 - c, Math.min(e.y2, e.y3)), d.lineTo(e.x3 - c, Math.min(e.y1, e.y4)), d.stroke(), d.beginPath(), d.moveTo(e.x3 - c, Math.max(e.y1, e.y4)), d.lineTo(e.x3 - c, Math.max(e.y2, e.y3)), d.stroke(), ea(d, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), "transparent", 2 * e.borderThickness, e.color, false, false, false, false), d.globalAlpha = 1) : "ohlc" === c.type ? (d.globalAlpha = 1, d.strokeStyle = e.color, d.lineWidth = 2 * e.borderThickness, c = 0 === d.lineWidth % 2 ? 0 : 0.5, d.beginPath(), d.moveTo(e.x3 - c, e.y2), d.lineTo(e.x3 - c, e.y3), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y1), d.lineTo(e.x1, e.y1), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y4), d.lineTo(e.x2, e.y4), d.stroke(), d.globalAlpha = 1) : "boxAndWhisker" === c.type ? (d.save(), d.globalAlpha = 1, d.strokeStyle = e.stemColor, d.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (d.beginPath(), d.moveTo(e.x3, e.y2 + e.borderThickness / 2), d.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), d.lineTo(e.x3, e.y3 - e.borderThickness / 2), d.stroke()), d.beginPath(), ea(d, e.x1 - e.borderThickness / 2, Math.max(e.y2 + e.borderThickness / 2, e.y3 + e.borderThickness / 2), e.x2 + e.borderThickness / 2, Math.min(e.y2 - e.borderThickness / 2, e.y3 - e.borderThickness / 2), "transparent", e.borderThickness, e.color, false, false, false, false), d.globalAlpha = 1, d.strokeStyle = e.whiskerColor, d.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (d.beginPath(), d.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), d.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), d.stroke(), d.beginPath(), d.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y1), d.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), d.stroke()), d.globalAlpha = 1, d.strokeStyle = e.lineColor, d.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (d.beginPath(), d.moveTo(e.x1, e.y5), d.lineTo(e.x2, e.y5), d.stroke()), d.restore(), d.globalAlpha = 1) : "error" === c.type && E2(d, e.x1, e.y1, e.x2, e.y2, "white", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3));
            }
          }
          d.restore();
          d.globalAlpha = 1;
          d.beginPath();
        };
        $2.prototype.getToolTipInnerHTML = function(a) {
          a = a.entries;
          for (var d = null, b = null, c = null, e = 0, g = "", k = true, h2 = 0; h2 < a.length; h2++)
            if (a[h2].dataSeries.toolTipContent || a[h2].dataPoint.toolTipContent) {
              k = false;
              break;
            }
          if (k && (this.content && "function" === typeof this.content || this.contentFormatter))
            a = { chart: this.chart, toolTip: this.options, entries: a }, d = this.contentFormatter ? this.contentFormatter(a) : this.content(a);
          else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
            for (var p2 = null, m = "", h2 = 0; h2 < a.length; h2++)
              b = a[h2].dataSeries, c = a[h2].dataPoint, e = a[h2].index, g = "", 0 === h2 && (k && !this.content) && (this.chart.axisX && 0 < this.chart.axisX.length ? m += "undefined" !== typeof this.chart.axisX[0].labels[c.x] ? this.chart.axisX[0].labels[c.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (m += "undefined" !== typeof this.chart.axisX2[0].labels[c.x] ? this.chart.axisX2[0].labels[c.x] : "{x}"), m += "</br>", m = this.chart.replaceKeywordsWithValue(m, c, b, e)), null === c.toolTipContent || "undefined" === typeof c.toolTipContent && null === b.options.toolTipContent || ("line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "column" === b.type || "bar" === b.type || "scatter" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "waterfall" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p2 != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>{name}:</span>&nbsp;&nbsp;{y}`, p2 = b.axisXIndex) : "bubble" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p2 != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}`) : "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p2 != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}`) : "candlestick" === b.type || "ohlc" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p2 != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}`) : "boxAndWhisker" === b.type && (this.chart.axisX && 1 < this.chart.axisX.length && (g += p2 != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}`), null === d && (d = ""), true === this.reversed ? (d = this.chart.replaceKeywordsWithValue(g, c, b, e) + d, h2 < a.length - 1 && (d = "</br>" + d)) : (d += this.chart.replaceKeywordsWithValue(g, c, b, e), h2 < a.length - 1 && (d += "</br>")));
            null !== d && (d = m + d);
          } else {
            b = a[0].dataSeries;
            c = a[0].dataPoint;
            e = a[0].index;
            if (null === c.toolTipContent || "undefined" === typeof c.toolTipContent && null === b.options.toolTipContent)
              return null;
            "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "column" === b.type || "bar" === b.type || "scatter" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "waterfall" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>` + (c.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>` + (c.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === b.type || "doughnut" === b.type || "funnel" === b.type || "pyramid" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>` + (c.name ? "{name}:</span>&nbsp;&nbsp;" : c.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>` + (c.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" === b.type || "ohlc" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>` + (c.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === b.type && (g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span style='"` + (this.options.fontColor ? "" : "'color:{color};'") + `"'>` + (c.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");
            null === d && (d = "");
            d += this.chart.replaceKeywordsWithValue(g, c, b, e);
          }
          return d;
        };
        $2.prototype.enableAnimation = function() {
          if (!this.container.style.WebkitTransition) {
            var a = this.getContainerTransition(this.containerTransitionDuration);
            this.container.style.WebkitTransition = a;
            this.container.style.MsTransition = a;
            this.container.style.transition = a;
            this.container.style.MozTransition = this.mozContainerTransition;
          }
        };
        $2.prototype.disableAnimation = function() {
          this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "");
        };
        $2.prototype.hide = function(a) {
          this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, ("undefined" === typeof a || a) && this.chart.resetOverlayedCanvas());
        };
        $2.prototype.show = function(a, d, b) {
          this._updateToolTip(a, d, "undefined" === typeof b ? false : b);
        };
        $2.prototype.fixMozTransitionDelay = function(a, d) {
          if (20 < this.chart._eventManager.lastObjectId)
            this.mozContainerTransition = this.getContainerTransition(0);
          else {
            var b = parseFloat(this.container.style.left), b = isNaN(b) ? 0 : b, c = parseFloat(this.container.style.bottom), c = isNaN(c) ? 0 : c;
            10 < Math.sqrt(Math.pow(b - a, 2) + Math.pow(c - d, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);
          }
        };
        $2.prototype.getContainerTransition = function(a) {
          return "left " + a + "s ease-out 0s, bottom " + a + "s ease-out 0s";
        };
        ha2.prototype.reset = function() {
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.eventObjects = [];
          r && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());
        };
        ha2.prototype.getNewObjectTrackingId = function() {
          return ++this.lastObjectId;
        };
        ha2.prototype.mouseEventHandler = function(a) {
          if ("mousemove" === a.type || "click" === a.type) {
            var d = [], b = Ra(a), c = null;
            if ((c = this.chart.getObjectAtXY(b.x, b.y, false)) && "undefined" !== typeof this.objectMap[c])
              if (c = this.objectMap[c], "dataPoint" === c.objectType) {
                var e = this.chart.data[c.dataSeriesIndex], g = e.dataPoints[c.dataPointIndex], h2 = c.dataPointIndex;
                c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h2, dataSeriesIndex: e.index, chart: this.chart };
                c.eventContext = { context: g, userContext: g, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" };
                d.push(c);
                c = this.objectMap[e.id];
                c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h2, dataSeriesIndex: e.index, chart: this.chart };
                c.eventContext = {
                  context: e,
                  userContext: e.options,
                  mouseover: "mouseover",
                  mousemove: "mousemove",
                  mouseout: "mouseout",
                  click: "click"
                };
                d.push(this.objectMap[e.id]);
              } else
                "legendItem" === c.objectType && (e = this.chart.data[c.dataSeriesIndex], g = null !== c.dataPointIndex ? e.dataPoints[c.dataPointIndex] : null, c.eventParameter = { x: b.x, y: b.y, dataSeries: e.options, dataPoint: g, dataPointIndex: c.dataPointIndex, dataSeriesIndex: c.dataSeriesIndex, chart: this.chart }, c.eventContext = {
                  context: this.chart.legend,
                  userContext: this.chart.legend.options,
                  mouseover: "itemmouseover",
                  mousemove: "itemmousemove",
                  mouseout: "itemmouseout",
                  click: "itemclick"
                }, d.push(c));
            e = [];
            for (b = 0; b < this.mouseoveredObjectMaps.length; b++) {
              g = true;
              for (c = 0; c < d.length; c++)
                if (d[c].id === this.mouseoveredObjectMaps[b].id) {
                  g = false;
                  break;
                }
              g ? this.fireEvent(this.mouseoveredObjectMaps[b], "mouseout", a) : e.push(this.mouseoveredObjectMaps[b]);
            }
            this.mouseoveredObjectMaps = e;
            for (b = 0; b < d.length; b++) {
              e = false;
              for (c = 0; c < this.mouseoveredObjectMaps.length; c++)
                if (d[b].id === this.mouseoveredObjectMaps[c].id) {
                  e = true;
                  break;
                }
              e || (this.fireEvent(d[b], "mouseover", a), this.mouseoveredObjectMaps.push(d[b]));
              "click" === a.type ? this.fireEvent(d[b], "click", a) : "mousemove" === a.type && this.fireEvent(d[b], "mousemove", a);
            }
          }
        };
        ha2.prototype.fireEvent = function(a, d, b) {
          if (a && d) {
            var c = a.eventParameter, e = a.eventContext, g = a.eventContext.userContext;
            g && (e && g[e[d]]) && g[e[d]].call(g, c);
            "mouseout" !== d ? g.cursor && g.cursor !== b.target.style.cursor && (b.target.style.cursor = g.cursor) : (b.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);
            "click" === d && ("dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler) && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], c);
            "click" === d && ("dataPoint" === a.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], c);
          }
        };
        ga2.prototype.animate = function(a, d, b, c, e) {
          var g = this;
          this.chart.isAnimating = true;
          e = e || M.easing.linear;
          b && this.animations.push({ startTime: (/* @__PURE__ */ new Date()).getTime() + (a ? a : 0), duration: d, animationCallback: b, onComplete: c });
          for (a = []; 0 < this.animations.length; )
            if (d = this.animations.shift(), b = (/* @__PURE__ */ new Date()).getTime(), c = 0, d.startTime <= b && (c = e(Math.min(b - d.startTime, d.duration), 0, 1, d.duration), c = Math.min(c, 1), isNaN(c) || !isFinite(c)) && (c = 1), 1 > c && a.push(d), d.animationCallback(c), 1 <= c && d.onComplete)
              d.onComplete();
          this.animations = a;
          0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function() {
            g.animate.call(g);
          }) : this.chart.isAnimating = false;
        };
        ga2.prototype.cancelAllAnimations = function() {
          this.animations = [];
          this.animationRequestId && this.chart.cancelRequestAnimFrame.call(
            window,
            this.animationRequestId
          );
          this.animationRequestId = null;
          this.chart.isAnimating = false;
        };
        var M = { yScaleAnimation: function(a, d) {
          if (0 !== a) {
            var b = d.dest, c = d.source.canvas, e = d.animationBase;
            b.drawImage(c, 0, 0, c.width, c.height, 0, e - e * a, b.canvas.width / W, a * b.canvas.height / W);
          }
        }, xScaleAnimation: function(a, d) {
          if (0 !== a) {
            var b = d.dest, c = d.source.canvas, e = d.animationBase;
            b.drawImage(c, 0, 0, c.width, c.height, e - e * a, 0, a * b.canvas.width / W, b.canvas.height / W);
          }
        }, xClipAnimation: function(a, d) {
          if (0 !== a) {
            var b = d.dest, c = d.source.canvas;
            b.save();
            0 < a && b.drawImage(c, 0, 0, c.width * a, c.height, 0, 0, c.width * a / W, c.height / W);
            b.restore();
          }
        }, fadeInAnimation: function(a, d) {
          if (0 !== a) {
            var b = d.dest, c = d.source.canvas;
            b.save();
            b.globalAlpha = a;
            b.drawImage(c, 0, 0, c.width, c.height, 0, 0, b.canvas.width / W, b.canvas.height / W);
            b.restore();
          }
        }, easing: { linear: function(a, d, b, c) {
          return b * a / c + d;
        }, easeOutQuad: function(a, d, b, c) {
          return -b * (a /= c) * (a - 2) + d;
        }, easeOutQuart: function(a, d, b, c) {
          return -b * ((a = a / c - 1) * a * a * a - 1) + d;
        }, easeInQuad: function(a, d, b, c) {
          return b * (a /= c) * a + d;
        }, easeInQuart: function(a, d, b, c) {
          return b * (a /= c) * a * a * a + d;
        } } }, ia = { drawMarker: function(a, d, b, c, e, g, h2, l) {
          if (b) {
            var p2 = 1;
            b.fillStyle = g ? g : "#000000";
            b.strokeStyle = h2 ? h2 : "#000000";
            b.lineWidth = l ? l : 0;
            b.setLineDash && b.setLineDash(R("solid", l));
            "circle" === c ? (b.moveTo(a, d), b.beginPath(), b.arc(a, d, e / 2, 0, 2 * Math.PI, false), g && b.fill(), l && (h2 ? b.stroke() : (p2 = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = p2))) : "square" === c ? (b.beginPath(), b.rect(a - e / 2, d - e / 2, e, e), g && b.fill(), l && (h2 ? b.stroke() : (p2 = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = p2))) : "triangle" === c ? (b.beginPath(), b.moveTo(a - e / 2, d + e / 2), b.lineTo(a + e / 2, d + e / 2), b.lineTo(a, d - e / 2), b.closePath(), g && b.fill(), l && (h2 ? b.stroke() : (p2 = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = p2)), b.beginPath()) : "cross" === c && (b.strokeStyle = g, b.lineWidth = e / 4, b.beginPath(), b.moveTo(a - e / 2, d - e / 2), b.lineTo(a + e / 2, d + e / 2), b.stroke(), b.moveTo(a + e / 2, d - e / 2), b.lineTo(a - e / 2, d + e / 2), b.stroke());
          }
        }, drawMarkers: function(a) {
          for (var d = 0; d < a.length; d++) {
            var b = a[d];
            ia.drawMarker(b.x, b.y, b.ctx, b.type, b.size, b.color, b.borderColor, b.borderThickness);
          }
        } };
        return p;
      }();
      Na.Chart.version = "v2.3.2 GA";
    })();
    document.createElement("canvas").getContext || function() {
      function V() {
        return this.context_ || (this.context_ = new C(this));
      }
      function W(a, b, c) {
        var g = M.call(arguments, 2);
        return function() {
          return a.apply(b, g.concat(M.call(arguments)));
        };
      }
      function N(a) {
        return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
      }
      function O(a) {
        a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML");
        a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");
        a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}");
      }
      function X(a) {
        var b = a.srcElement;
        switch (a.propertyName) {
          case "width":
            b.getContext().clearRect();
            b.style.width = b.attributes.width.nodeValue + "px";
            b.firstChild.style.width = b.clientWidth + "px";
            break;
          case "height":
            b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight + "px";
        }
      }
      function Y(a) {
        a = a.srcElement;
        a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px");
      }
      function D() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      }
      function t(a, b) {
        for (var c = D(), g = 0; 3 > g; g++)
          for (var e = 0; 3 > e; e++) {
            for (var f = 0, d2 = 0; 3 > d2; d2++)
              f += a[g][d2] * b[d2][e];
            c[g][e] = f;
          }
        return c;
      }
      function P(a, b) {
        b.fillStyle = a.fillStyle;
        b.lineCap = a.lineCap;
        b.lineJoin = a.lineJoin;
        b.lineWidth = a.lineWidth;
        b.miterLimit = a.miterLimit;
        b.shadowBlur = a.shadowBlur;
        b.shadowColor = a.shadowColor;
        b.shadowOffsetX = a.shadowOffsetX;
        b.shadowOffsetY = a.shadowOffsetY;
        b.strokeStyle = a.strokeStyle;
        b.globalAlpha = a.globalAlpha;
        b.font = a.font;
        b.textAlign = a.textAlign;
        b.textBaseline = a.textBaseline;
        b.arcScaleX_ = a.arcScaleX_;
        b.arcScaleY_ = a.arcScaleY_;
        b.lineScale_ = a.lineScale_;
      }
      function Q(a) {
        var b = a.indexOf("(", 3), c = a.indexOf(")", b + 1), b = a.substring(b + 1, c).split(",");
        if (4 != b.length || "a" != a.charAt(3))
          b[3] = 1;
        return b;
      }
      function E(a, b, c) {
        return Math.min(c, Math.max(b, a));
      }
      function F(a, b, c) {
        0 > c && c++;
        1 < c && c--;
        return 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a;
      }
      function G(a) {
        if (a in H)
          return H[a];
        var b, c = 1;
        a = String(a);
        if ("#" == a.charAt(0))
          b = a;
        else if (/^rgb/.test(a)) {
          c = Q(a);
          b = "#";
          for (var g, e = 0; 3 > e; e++)
            g = -1 != c[e].indexOf("%") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)];
          c = +c[3];
        } else if (/^hsl/.test(a)) {
          e = c = Q(a);
          b = parseFloat(e[0]) / 360 % 360;
          0 > b && b++;
          g = E(parseFloat(e[1]) / 100, 0, 1);
          e = E(parseFloat(e[2]) / 100, 0, 1);
          if (0 == g)
            g = e = b = e;
          else {
            var f = 0.5 > e ? e * (1 + g) : e + g - e * g, d2 = 2 * e - f;
            g = F(d2, f, b + 1 / 3);
            e = F(d2, f, b);
            b = F(d2, f, b - 1 / 3);
          }
          b = "#" + v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];
          c = c[3];
        } else
          b = Z[a] || a;
        return H[a] = { color: b, alpha: c };
      }
      function C(a) {
        this.m_ = D();
        this.mStack_ = [];
        this.aStack_ = [];
        this.currentPath_ = [];
        this.fillStyle = this.strokeStyle = "#000";
        this.lineWidth = 1;
        this.lineJoin = "miter";
        this.lineCap = "butt";
        this.miterLimit = 1 * q;
        this.globalAlpha = 1;
        this.font = "10px sans-serif";
        this.textAlign = "left";
        this.textBaseline = "alphabetic";
        this.canvas = a;
        var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute", c = a.ownerDocument.createElement("div");
        c.style.cssText = b;
        a.appendChild(c);
        b = c.cloneNode(false);
        b.style.backgroundColor = "red";
        b.style.filter = "alpha(opacity=0)";
        a.appendChild(b);
        this.element_ = c;
        this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;
      }
      function R(a, b, c, g) {
        a.currentPath_.push({ type: "bezierCurveTo", cp1x: b.x, cp1y: b.y, cp2x: c.x, cp2y: c.y, x: g.x, y: g.y });
        a.currentX_ = g.x;
        a.currentY_ = g.y;
      }
      function S(a, b) {
        var c = G(a.strokeStyle), g = c.color, c = c.alpha * a.globalAlpha, e = a.lineScale_ * a.lineWidth;
        1 > e && (c *= e);
        b.push(
          "<g_vml_:stroke",
          ' opacity="',
          c,
          '"',
          ' joinstyle="',
          a.lineJoin,
          '"',
          ' miterlimit="',
          a.miterLimit,
          '"',
          ' endcap="',
          $[a.lineCap] || "square",
          '"',
          ' weight="',
          e,
          'px"',
          ' color="',
          g,
          '" />'
        );
      }
      function T(a, b, c, g) {
        var e = a.fillStyle, f = a.arcScaleX_, d2 = a.arcScaleY_, k2 = g.x - c.x, n = g.y - c.y;
        if (e instanceof w) {
          var h = 0, l = g = 0, u = 0, m = 1;
          if ("gradient" == e.type_) {
            h = e.x1_ / f;
            c = e.y1_ / d2;
            var p = s(a, e.x0_ / f, e.y0_ / d2), h = s(a, h, c), h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;
            0 > h && (h += 360);
            1e-6 > h && (h = 0);
          } else
            p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k2, l = (p.y - c.y) / n, k2 /= f * q, n /= d2 * q, m = x.max(k2, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;
          f = e.colors_;
          f.sort(function(a2, b2) {
            return a2.offset - b2.offset;
          });
          d2 = f.length;
          p = f[0].color;
          c = f[d2 - 1].color;
          k2 = f[0].alpha * a.globalAlpha;
          a = f[d2 - 1].alpha * a.globalAlpha;
          for (var n = [], r2 = 0; r2 < d2; r2++) {
            var t2 = f[r2];
            n.push(t2.offset * m + u + " " + t2.color);
          }
          b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', p, '"', ' color2="', c, '"', ' colors="', n.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', k2, '"', ' angle="', h, '"', ' focusposition="', g, ",", l, '" />');
        } else
          e instanceof I ? k2 && n && b.push("<g_vml_:fill", ' position="', -c.x / k2 * f * f, ",", -c.y / n * d2 * d2, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />'));
      }
      function s(a, b, c) {
        a = a.m_;
        return { x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r, y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r };
      }
      function z(a, b, c) {
        isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));
      }
      function w(a) {
        this.type_ = a;
        this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;
        this.colors_ = [];
      }
      function I(a, b) {
        if (!a || 1 != a.nodeType || "IMG" != a.tagName)
          throw new A("TYPE_MISMATCH_ERR");
        if ("complete" != a.readyState)
          throw new A("INVALID_STATE_ERR");
        switch (b) {
          case "repeat":
          case null:
          case "":
            this.repetition_ = "repeat";
            break;
          case "repeat-x":
          case "repeat-y":
          case "no-repeat":
            this.repetition_ = b;
            break;
          default:
            throw new A("SYNTAX_ERR");
        }
        this.src_ = a.src;
        this.width_ = a.width;
        this.height_ = a.height;
      }
      function A(a) {
        this.code = this[a];
        this.message = a + ": DOM Exception " + this.code;
      }
      var x = Math, k = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2;
      navigator.userAgent.match(/MSIE ([\d.]+)?/);
      var M = Array.prototype.slice;
      O(document);
      var U = { init: function(a) {
        a = a || document;
        a.createElement("canvas");
        a.attachEvent("onreadystatechange", W(this.init_, this, a));
      }, init_: function(a) {
        a = a.getElementsByTagName("canvas");
        for (var b = 0; b < a.length; b++)
          this.initElement(a[b]);
      }, initElement: function(a) {
        if (!a.getContext) {
          a.getContext = V;
          O(a.ownerDocument);
          a.innerHTML = "";
          a.attachEvent("onpropertychange", X);
          a.attachEvent("onresize", Y);
          var b = a.attributes;
          b.width && b.width.specified ? a.style.width = b.width.nodeValue + "px" : a.width = a.clientWidth;
          b.height && b.height.specified ? a.style.height = b.height.nodeValue + "px" : a.height = a.clientHeight;
        }
        return a;
      } };
      U.init();
      for (var v = [], d = 0; 16 > d; d++)
        for (var B = 0; 16 > B; B++)
          v[16 * d + B] = d.toString(16) + B.toString(16);
      var Z = {
        aliceblue: "#F0F8FF",
        antiquewhite: "#FAEBD7",
        aquamarine: "#7FFFD4",
        azure: "#F0FFFF",
        beige: "#F5F5DC",
        bisque: "#FFE4C4",
        black: "#000000",
        blanchedalmond: "#FFEBCD",
        blueviolet: "#8A2BE2",
        brown: "#A52A2A",
        burlywood: "#DEB887",
        cadetblue: "#5F9EA0",
        chartreuse: "#7FFF00",
        chocolate: "#D2691E",
        coral: "#FF7F50",
        cornflowerblue: "#6495ED",
        cornsilk: "#FFF8DC",
        crimson: "#DC143C",
        cyan: "#00FFFF",
        darkblue: "#00008B",
        darkcyan: "#008B8B",
        darkgoldenrod: "#B8860B",
        darkgray: "#A9A9A9",
        darkgreen: "#006400",
        darkgrey: "#A9A9A9",
        darkkhaki: "#BDB76B",
        darkmagenta: "#8B008B",
        darkolivegreen: "#556B2F",
        darkorange: "#FF8C00",
        darkorchid: "#9932CC",
        darkred: "#8B0000",
        darksalmon: "#E9967A",
        darkseagreen: "#8FBC8F",
        darkslateblue: "#483D8B",
        darkslategray: "#2F4F4F",
        darkslategrey: "#2F4F4F",
        darkturquoise: "#00CED1",
        darkviolet: "#9400D3",
        deeppink: "#FF1493",
        deepskyblue: "#00BFFF",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1E90FF",
        firebrick: "#B22222",
        floralwhite: "#FFFAF0",
        forestgreen: "#228B22",
        gainsboro: "#DCDCDC",
        ghostwhite: "#F8F8FF",
        gold: "#FFD700",
        goldenrod: "#DAA520",
        grey: "#808080",
        greenyellow: "#ADFF2F",
        honeydew: "#F0FFF0",
        hotpink: "#FF69B4",
        indianred: "#CD5C5C",
        indigo: "#4B0082",
        ivory: "#FFFFF0",
        khaki: "#F0E68C",
        lavender: "#E6E6FA",
        lavenderblush: "#FFF0F5",
        lawngreen: "#7CFC00",
        lemonchiffon: "#FFFACD",
        lightblue: "#ADD8E6",
        lightcoral: "#F08080",
        lightcyan: "#E0FFFF",
        lightgoldenrodyellow: "#FAFAD2",
        lightgreen: "#90EE90",
        lightgrey: "#D3D3D3",
        lightpink: "#FFB6C1",
        lightsalmon: "#FFA07A",
        lightseagreen: "#20B2AA",
        lightskyblue: "#87CEFA",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#B0C4DE",
        lightyellow: "#FFFFE0",
        limegreen: "#32CD32",
        linen: "#FAF0E6",
        magenta: "#FF00FF",
        mediumaquamarine: "#66CDAA",
        mediumblue: "#0000CD",
        mediumorchid: "#BA55D3",
        mediumpurple: "#9370DB",
        mediumseagreen: "#3CB371",
        mediumslateblue: "#7B68EE",
        mediumspringgreen: "#00FA9A",
        mediumturquoise: "#48D1CC",
        mediumvioletred: "#C71585",
        midnightblue: "#191970",
        mintcream: "#F5FFFA",
        mistyrose: "#FFE4E1",
        moccasin: "#FFE4B5",
        navajowhite: "#FFDEAD",
        oldlace: "#FDF5E6",
        olivedrab: "#6B8E23",
        orange: "#FFA500",
        orangered: "#FF4500",
        orchid: "#DA70D6",
        palegoldenrod: "#EEE8AA",
        palegreen: "#98FB98",
        paleturquoise: "#AFEEEE",
        palevioletred: "#DB7093",
        papayawhip: "#FFEFD5",
        peachpuff: "#FFDAB9",
        peru: "#CD853F",
        pink: "#FFC0CB",
        plum: "#DDA0DD",
        powderblue: "#B0E0E6",
        rosybrown: "#BC8F8F",
        royalblue: "#4169E1",
        saddlebrown: "#8B4513",
        salmon: "#FA8072",
        sandybrown: "#F4A460",
        seagreen: "#2E8B57",
        seashell: "#FFF5EE",
        sienna: "#A0522D",
        skyblue: "#87CEEB",
        slateblue: "#6A5ACD",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#FFFAFA",
        springgreen: "#00FF7F",
        steelblue: "#4682B4",
        tan: "#D2B48C",
        thistle: "#D8BFD8",
        tomato: "#FF6347",
        turquoise: "#40E0D0",
        violet: "#EE82EE",
        wheat: "#F5DEB3",
        whitesmoke: "#F5F5F5",
        yellowgreen: "#9ACD32"
      }, H = {}, L = {}, $ = { butt: "flat", round: "round" }, d = C.prototype;
      d.clearRect = function() {
        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(true), this.textMeasureEl_ = null);
        this.element_.innerHTML = "";
      };
      d.beginPath = function() {
        this.currentPath_ = [];
      };
      d.moveTo = function(a, b) {
        var c = s(this, a, b);
        this.currentPath_.push({ type: "moveTo", x: c.x, y: c.y });
        this.currentX_ = c.x;
        this.currentY_ = c.y;
      };
      d.lineTo = function(a, b) {
        var c = s(this, a, b);
        this.currentPath_.push({ type: "lineTo", x: c.x, y: c.y });
        this.currentX_ = c.x;
        this.currentY_ = c.y;
      };
      d.bezierCurveTo = function(a, b, c, g, e, f) {
        e = s(this, e, f);
        a = s(this, a, b);
        c = s(this, c, g);
        R(this, a, c, e);
      };
      d.quadraticCurveTo = function(a, b, c, g) {
        a = s(this, a, b);
        c = s(this, c, g);
        g = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) };
        R(this, g, { x: g.x + (c.x - this.currentX_) / 3, y: g.y + (c.y - this.currentY_) / 3 }, c);
      };
      d.arc = function(a, b, c, g, e, f) {
        c *= q;
        var d2 = f ? "at" : "wa", k2 = a + K(g) * c - r, n = b + J(g) * c - r;
        g = a + K(e) * c - r;
        e = b + J(e) * c - r;
        k2 != g || f || (k2 += 0.125);
        a = s(this, a, b);
        k2 = s(this, k2, n);
        g = s(this, g, e);
        this.currentPath_.push({
          type: d2,
          x: a.x,
          y: a.y,
          radius: c,
          xStart: k2.x,
          yStart: k2.y,
          xEnd: g.x,
          yEnd: g.y
        });
      };
      d.rect = function(a, b, c, g) {
        this.moveTo(a, b);
        this.lineTo(a + c, b);
        this.lineTo(a + c, b + g);
        this.lineTo(a, b + g);
        this.closePath();
      };
      d.strokeRect = function(a, b, c, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a, b);
        this.lineTo(a + c, b);
        this.lineTo(a + c, b + g);
        this.lineTo(a, b + g);
        this.closePath();
        this.stroke();
        this.currentPath_ = e;
      };
      d.fillRect = function(a, b, c, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a, b);
        this.lineTo(a + c, b);
        this.lineTo(a + c, b + g);
        this.lineTo(a, b + g);
        this.closePath();
        this.fill();
        this.currentPath_ = e;
      };
      d.createLinearGradient = function(a, b, c, g) {
        var e = new w("gradient");
        e.x0_ = a;
        e.y0_ = b;
        e.x1_ = c;
        e.y1_ = g;
        return e;
      };
      d.createRadialGradient = function(a, b, c, g, e, f) {
        var d2 = new w("gradientradial");
        d2.x0_ = a;
        d2.y0_ = b;
        d2.r0_ = c;
        d2.x1_ = g;
        d2.y1_ = e;
        d2.r1_ = f;
        return d2;
      };
      d.drawImage = function(a, b) {
        var c, g, e, d2, r2, y, n, h;
        e = a.runtimeStyle.width;
        d2 = a.runtimeStyle.height;
        a.runtimeStyle.width = "auto";
        a.runtimeStyle.height = "auto";
        var l = a.width, u = a.height;
        a.runtimeStyle.width = e;
        a.runtimeStyle.height = d2;
        if (3 == arguments.length)
          c = arguments[1], g = arguments[2], r2 = y = 0, n = e = l, h = d2 = u;
        else if (5 == arguments.length)
          c = arguments[1], g = arguments[2], e = arguments[3], d2 = arguments[4], r2 = y = 0, n = l, h = u;
        else if (9 == arguments.length)
          r2 = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d2 = arguments[8];
        else
          throw Error("Invalid number of arguments");
        var m = s(this, c, g), p = [];
        p.push(
          " <g_vml_:group",
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' coordorigin="0,0"',
          ' style="width:',
          10,
          "px;height:",
          10,
          "px;position:absolute;"
        );
        if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
          var t2 = [];
          t2.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k(m.x / q), ",", "Dy=", k(m.y / q), "");
          var v2 = s(this, c + e, g), w2 = s(this, c, g + d2);
          c = s(this, c + e, g + d2);
          m.x = x.max(m.x, v2.x, w2.x, c.x);
          m.y = x.max(m.y, v2.y, w2.y, c.y);
          p.push("padding:0 ", k(m.x / q), "px ", k(m.y / q), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", t2.join(""), ", sizingmethod='clip');");
        } else
          p.push(
            "top:",
            k(m.y / q),
            "px;left:",
            k(m.x / q),
            "px;"
          );
        p.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', q * e, "px;", " height:", q * d2, 'px"', ' cropleft="', r2 / l, '"', ' croptop="', y / u, '"', ' cropright="', (l - r2 - n) / l, '"', ' cropbottom="', (u - y - h) / u, '"', " />", "</g_vml_:group>");
        this.element_.insertAdjacentHTML("BeforeEnd", p.join(""));
      };
      d.stroke = function(a) {
        var b = [];
        b.push(
          "<g_vml_:shape",
          ' filled="',
          !!a,
          '"',
          ' style="position:absolute;width:',
          10,
          "px;height:",
          10,
          'px;"',
          ' coordorigin="0,0"',
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' stroked="',
          !a,
          '"',
          ' path="'
        );
        for (var c = { x: null, y: null }, d2 = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {
          var f = this.currentPath_[e];
          switch (f.type) {
            case "moveTo":
              b.push(" m ", k(f.x), ",", k(f.y));
              break;
            case "lineTo":
              b.push(" l ", k(f.x), ",", k(f.y));
              break;
            case "close":
              b.push(" x ");
              f = null;
              break;
            case "bezierCurveTo":
              b.push(" c ", k(f.cp1x), ",", k(f.cp1y), ",", k(f.cp2x), ",", k(f.cp2y), ",", k(f.x), ",", k(f.y));
              break;
            case "at":
            case "wa":
              b.push(" ", f.type, " ", k(f.x - this.arcScaleX_ * f.radius), ",", k(f.y - this.arcScaleY_ * f.radius), " ", k(f.x + this.arcScaleX_ * f.radius), ",", k(f.y + this.arcScaleY_ * f.radius), " ", k(f.xStart), ",", k(f.yStart), " ", k(f.xEnd), ",", k(f.yEnd));
          }
          if (f) {
            if (null == c.x || f.x < c.x)
              c.x = f.x;
            if (null == d2.x || f.x > d2.x)
              d2.x = f.x;
            if (null == c.y || f.y < c.y)
              c.y = f.y;
            if (null == d2.y || f.y > d2.y)
              d2.y = f.y;
          }
        }
        b.push(' ">');
        a ? T(this, b, c, d2) : S(this, b);
        b.push("</g_vml_:shape>");
        this.element_.insertAdjacentHTML("beforeEnd", b.join(""));
      };
      d.fill = function() {
        this.stroke(true);
      };
      d.closePath = function() {
        this.currentPath_.push({ type: "close" });
      };
      d.save = function() {
        var a = {};
        P(this, a);
        this.aStack_.push(a);
        this.mStack_.push(this.m_);
        this.m_ = t(D(), this.m_);
      };
      d.restore = function() {
        this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());
      };
      d.translate = function(a, b) {
        z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), false);
      };
      d.rotate = function(a) {
        var b = K(a);
        a = J(a);
        z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), false);
      };
      d.scale = function(a, b) {
        this.arcScaleX_ *= a;
        this.arcScaleY_ *= b;
        z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), true);
      };
      d.transform = function(a, b, c, d2, e, f) {
        z(this, t([[
          a,
          b,
          0
        ], [c, d2, 0], [e, f, 1]], this.m_), true);
      };
      d.setTransform = function(a, b, c, d2, e, f) {
        z(this, [[a, b, 0], [c, d2, 0], [e, f, 1]], true);
      };
      d.drawText_ = function(a, b, c, d2, e) {
        var f = this.m_;
        d2 = 0;
        var r2 = 1e3, t2 = 0, n = [], h;
        h = this.font;
        if (L[h])
          h = L[h];
        else {
          var l = document.createElement("div").style;
          try {
            l.font = h;
          } catch (u) {
          }
          h = L[h] = { style: l.fontStyle || "normal", variant: l.fontVariant || "normal", weight: l.fontWeight || "normal", size: l.fontSize || 10, family: l.fontFamily || "sans-serif" };
        }
        var l = h, m = this.element_;
        h = {};
        for (var p in l)
          h[p] = l[p];
        p = parseFloat(m.currentStyle.fontSize);
        m = parseFloat(l.size);
        "number" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf("px") ? h.size = m : -1 != l.size.indexOf("em") ? h.size = p * m : -1 != l.size.indexOf("%") ? h.size = p / 100 * m : -1 != l.size.indexOf("pt") ? h.size = m / 0.75 : h.size = p;
        h.size *= 0.981;
        p = h.style + " " + h.variant + " " + h.weight + " " + h.size + "px " + h.family;
        m = this.element_.currentStyle;
        l = this.textAlign.toLowerCase();
        switch (l) {
          case "left":
          case "center":
          case "right":
            break;
          case "end":
            l = "ltr" == m.direction ? "right" : "left";
            break;
          case "start":
            l = "rtl" == m.direction ? "right" : "left";
            break;
          default:
            l = "left";
        }
        switch (this.textBaseline) {
          case "hanging":
          case "top":
            t2 = h.size / 1.75;
            break;
          case "middle":
            break;
          default:
          case null:
          case "alphabetic":
          case "ideographic":
          case "bottom":
            t2 = -h.size / 2.25;
        }
        switch (l) {
          case "right":
            d2 = 1e3;
            r2 = 0.05;
            break;
          case "center":
            d2 = r2 = 500;
        }
        b = s(this, b + 0, c + t2);
        n.push('<g_vml_:line from="', -d2, ' 0" to="', r2, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !e, '" stroked="', !!e, '" style="position:absolute;width:1px;height:1px;">');
        e ? S(this, n) : T(
          this,
          n,
          { x: -d2, y: 0 },
          { x: r2, y: h.size }
        );
        e = f[0][0].toFixed(3) + "," + f[1][0].toFixed(3) + "," + f[0][1].toFixed(3) + "," + f[1][1].toFixed(3) + ",0,0";
        b = k(b.x / q) + "," + k(b.y / q);
        n.push('<g_vml_:skew on="t" matrix="', e, '" ', ' offset="', b, '" origin="', d2, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', N(a), '" style="v-text-align:', l, ";font:", N(p), '" /></g_vml_:line>');
        this.element_.insertAdjacentHTML("beforeEnd", n.join(""));
      };
      d.fillText = function(a, b, c, d2) {
        this.drawText_(a, b, c, d2, false);
      };
      d.strokeText = function(a, b, c, d2) {
        this.drawText_(a, b, c, d2, true);
      };
      d.measureText = function(a) {
        this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild);
        var b = this.element_.ownerDocument;
        this.textMeasureEl_.innerHTML = "";
        this.textMeasureEl_.style.font = this.font;
        this.textMeasureEl_.appendChild(b.createTextNode(a));
        return { width: this.textMeasureEl_.offsetWidth };
      };
      d.clip = function() {
      };
      d.arcTo = function() {
      };
      d.createPattern = function(a, b) {
        return new I(a, b);
      };
      w.prototype.addColorStop = function(a, b) {
        b = G(b);
        this.colors_.push({ offset: a, color: b.color, alpha: b.alpha });
      };
      d = A.prototype = Error();
      d.INDEX_SIZE_ERR = 1;
      d.DOMSTRING_SIZE_ERR = 2;
      d.HIERARCHY_REQUEST_ERR = 3;
      d.WRONG_DOCUMENT_ERR = 4;
      d.INVALID_CHARACTER_ERR = 5;
      d.NO_DATA_ALLOWED_ERR = 6;
      d.NO_MODIFICATION_ALLOWED_ERR = 7;
      d.NOT_FOUND_ERR = 8;
      d.NOT_SUPPORTED_ERR = 9;
      d.INUSE_ATTRIBUTE_ERR = 10;
      d.INVALID_STATE_ERR = 11;
      d.SYNTAX_ERR = 12;
      d.INVALID_MODIFICATION_ERR = 13;
      d.NAMESPACE_ERR = 14;
      d.INVALID_ACCESS_ERR = 15;
      d.VALIDATION_ERR = 16;
      d.TYPE_MISMATCH_ERR = 17;
      G_vmlCanvasManager = U;
      CanvasRenderingContext2D = C;
      CanvasGradient = w;
      CanvasPattern = I;
      DOMException = A;
    }();
  }
});

// node_modules/canvasjs-react-charts/index.js
var React = require_react();
var CanvasJS = require_canvasjs_min();
CanvasJS = CanvasJS.Chart ? CanvasJS : window.CanvasJS;
var CanvasJSChart = class extends React.Component {
  constructor(props) {
    super(props);
    this._cjsContainerId = new window.Date().getTime();
    this.options = props.options ? props.options : {};
    this.containerProps = props.containerProps ? props.containerProps : { width: "100%", position: "relative" };
    this.containerProps.height = props.containerProps && props.containerProps.height ? props.containerProps.height : this.options.height ? this.options.height + "px" : "400px";
    this.chartContainerId = "canvasjs-react-chart-container-" + this._cjsContainerId;
  }
  componentDidMount() {
    this.chart = new CanvasJS.Chart(this.chartContainerId, this.options);
    this.chart.render();
    if (this.props.onRef)
      this.props.onRef(this.chart);
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !(nextProps.options === this.options);
  }
  componentDidUpdate() {
    this.chart.options = this.props.options;
    this.chart.render();
  }
  componentWillUnmount() {
    this.chart.destroy();
    if (this.props.onRef)
      this.props.onRef(void 0);
  }
  render() {
    return React.createElement("div", { id: this.chartContainerId, style: this.containerProps });
  }
};
export {
  CanvasJS,
  CanvasJSChart
};
//# sourceMappingURL=canvasjs-react-charts.js.map
